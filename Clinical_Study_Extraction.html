<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clinical Study Extraction System - Preview</title>
    <!-- Load PDF.js library from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Google API client is loaded dynamically in the main script -->
    <!-- ADD PDF-LIB LIBRARY for annotations -->
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <style>
        /* SCSS Variables */
        :root {
            --primary-blue: #007bff;
            --primary-blue-dark: #0056b3;
            --success-green: #4CAF50;
            --success-green-light: #8BC34A;
            --warning-orange: #FF9800;
            --warning-orange-dark: #F57C00;
            --error-red: #f44336;
            --error-red-dark: #c82333;
            --info-blue: #2196F3;

            --gray-100: #f8f9fa;
            --gray-200: #e9ecef;
            --gray-300: #dee2e6;
            --gray-400: #ccc;
            --gray-500: #666;
            --gray-600: #525252;
            --gray-700: #333;
            --gray-800: #2c3e50;
            --gray-900: #1976D2;

            --background-light: #f0f2f5;
            --background-white: #ffffff;

            --spacing-xs: 5px;
            --spacing-sm: 10px;
            --spacing-md: 15px;
            --spacing-lg: 20px;
            --spacing-xl: 30px;

            --border-radius-sm: 3px;
            --border-radius-md: 4px;
            --border-radius-lg: 6px;
            --border-radius-xl: 8px;

            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-md: 2px 0 5px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 4px 6px rgba(0, 0, 0, 0.3);
            --shadow-xl: 0 4px 12px rgba(0, 0, 0, 0.15);

            --transition-fast: 0.2s;
            --transition-normal: 0.3s;
            --transition-slow: 0.4s;
        }

        /* Layout Styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            min-height: 100vh;
            background-color: var(--background-light);
        }

        .main-container {
            display: flex;
            min-height: 100vh;
        }

        .form-panel {
            width: 35%;
            background: var(--background-white);
            overflow-y: auto;
            padding: var(--spacing-lg) var(--spacing-xl);
            box-shadow: var(--shadow-md);
        }

        .pdf-panel {
            width: 45%;
            background: var(--gray-200);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .trace-panel {
            width: 20%;
            background: var(--background-white);
            border-left: 1px solid var(--gray-400);
            overflow-y: auto;
            padding: var(--spacing-lg);
        }

        h1 {
            color: var(--gray-700);
            font-size: 24px;
            margin-bottom: var(--spacing-sm);
        }

        h2 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--primary-blue);
            padding-bottom: var(--spacing-sm);
            margin-top: var(--spacing-lg);
        }

        h3 {
            color: #555;
            margin-top: var(--spacing-lg);
        }

        .subtitle {
            font-size: 14px;
            color: var(--gray-500);
            margin-bottom: var(--spacing-md);
        }

        .stats-container {
            background: #f5f5f5;
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-md);
            margin-bottom: var(--spacing-md);
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
        }

        .stats-row + .stats-row {
            margin-top: var(--spacing-xs);
        }

        /* Form Styles */
        .step {
            display: none;
        }

        .step.active {
            display: block;
        }

        .form-group {
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-xs);
            border-radius: var(--border-radius-md);
            transition: all var(--transition-normal);
            position: relative; /* Needed for has-extraction pseudo-element */
        }

        .form-group.active-extraction {
            background: #fff3e0 !important;
            padding: var(--spacing-sm) !important;
            margin: calc(-1 * var(--spacing-xs)) !important;
            margin-bottom: var(--spacing-md) !important;
            border-left: 4px solid var(--warning-orange) !important;
            animation: pulse 1.5s infinite;
        }
        
        .form-group .ai-field-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .form-group .ai-field-group textarea,
        .form-group .ai-field-group input {
            flex-grow: 1;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
            color: var(--gray-700);
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 8px 10px;
            box-sizing: border-box;
            border: 1px solid var(--gray-400);
            border-radius: var(--border-radius-md);
            font-size: 14px;
        }

        /* Validation */
        .validation-error {
            border-color: var(--error-red) !important;
            background-color: #fff5f5 !important;
        }

        .validation-message {
            color: var(--error-red);
            font-size: 12px;
            margin-top: 4px;
            display: none;
        }

        .validation-error + .validation-message {
            display: block;
        }

        /* Field States */
        .linked-input {
            background-color: #f0f8ff;
            border-color: #b3d7ff;
        }

        .linked-input.has-extraction {
            background-color: #e8f5e9;
            border-color: var(--success-green);
        }

        .linked-input.has-extraction::after {
            content: '‚úì';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--success-green);
            font-weight: bold;
            pointer-events: none; /* Ensure it doesn't interfere with input focus */
        }
        /* Adjustments for textarea */
        textarea.linked-input.has-extraction::after {
            top: 10px; /* Adjust vertical position for textarea */
            transform: none;
        }

        /* Dynamic Containers */
        .dynamic-container {
            border: 1px solid #ddd;
            padding: var(--spacing-md);
            margin-top: var(--spacing-md);
            border-radius: var(--border-radius-md);
            background-color: #f9f9f9;
        }

        /* Grids */
        .grid-2col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
        }

        .grid-3col {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: var(--spacing-md);
        }

        .grid-mrs {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: var(--spacing-xs);
        }

        /* Progress Bar */
        #progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: var(--border-radius-md);
            margin-bottom: var(--spacing-lg);
        }

        #progress-bar {
            width: 0%;
            height: 10px;
            background: linear-gradient(90deg, var(--success-green), var(--success-green-light));
            border-radius: var(--border-radius-md);
            transition: width var(--transition-slow) ease;
        }

        /* Navigation */
        .navigation {
            position: sticky;
            bottom: 0;
            background: var(--background-white);
            padding: var(--spacing-md) var(--spacing-lg);
            border-top: 2px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: var(--spacing-xl);
        }


        /* PDF Viewer Styles */
        .pdf-toolbar {
            background: var(--gray-800);
            color: white;
            padding: var(--spacing-sm);
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
            box-shadow: var(--shadow-sm);
            flex-wrap: wrap;
        }

        .pdf-toolbar button {
            background: #34495e;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: var(--border-radius-md);
            cursor: pointer;
            font-size: 14px;
        }

        .pdf-toolbar button:hover {
            background: #4a5f7f;
        }

        .pdf-toolbar input[type="number"] {
            width: 50px;
            text-align: center;
            padding: 4px;
            border-radius: var(--border-radius-sm); /* Ensure consistent rounding */
        }

        .pdf-toolbar select {
            padding: 4px 8px;
            border-radius: var(--border-radius-md);
        }


        #active-field-indicator {
            background: var(--warning-orange);
            color: black; /* Ensure readability */
            padding: 4px 12px;
            border-radius: var(--border-radius-md);
            margin-left: auto;
            white-space: nowrap; /* Prevent wrapping */
        }

        .pdf-container {
            flex: 1;
            overflow: auto;
            background: var(--gray-600);
            position: relative;
            padding: var(--spacing-lg) 0;
            text-align: center; /* Center the page */
        }

        .pdf-page {
            margin: var(--spacing-lg) auto;
            background: white;
            box-shadow: var(--shadow-lg);
            position: relative;
            display: inline-block; /* Ensure centering works */
            text-align: left; /* Reset text align for content */
        }

        .upload-area {
            border: 2px dashed var(--gray-400);
            border-radius: var(--border-radius-xl);
            padding: 50px;
            text-align: center;
            margin: 50px;
            background: white;
            cursor: pointer;
        }
        .upload-area h3 {
            margin-top: 0;
        }

        .upload-link {
            cursor: pointer;
            color: var(--primary-blue);
            text-decoration: underline;
        }

        .toolbar-text {
            color: white;
            white-space: nowrap; /* Prevent wrapping */
        }

        /* Region Selection Tool Styles */
        .region-selection-box {
            position: absolute;
            border: 2px dashed var(--primary-blue);
            background: rgba(0, 123, 255, 0.1);
            pointer-events: none;
            z-index: 1000;
        }

        .selection-mode-toggle {
            background: var(--primary-blue);
            color: white;
        }

        .selection-mode-toggle.active {
            background: var(--warning-orange);
            animation: pulse 1.5s infinite;
        }

        /* Text Layer */
        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 1; /* IMPROVED: Was 0.2 - now fully visible for better selection */
            line-height: 1;
            -webkit-user-select: text; /* Safari 3+ */
            user-select: text; /* Enable text selection */
        }

        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
            -webkit-user-select: text; /* Safari 3+ */
            user-select: text; /* Enable text selection on spans */
            pointer-events: all; /* Ensure spans respond to mouse events */
        }

        /* IMPROVED: More visible selection colors */
        .textLayer ::selection {
            background: rgba(255, 193, 7, 0.6); /* Changed from blue to amber, increased opacity */
        }
        
        .textLayer ::-moz-selection {
            background: rgba(255, 193, 7, 0.6); /* Firefox support */
        }

        .textLayer.active-selection ::selection {
            background: rgba(255, 193, 7, 0.4);
        }

        .textLayer .highlight {
            background: rgba(255, 193, 7, 0.4) !important;
        }

        .textLayer .extracted {
            background: rgba(76, 175, 80, 0.2) !important;
        }

        .textLayer .search-highlight {
            background: rgba(255, 87, 34, 0.5) !important;
            color: transparent !important;
        }

        /* Extraction Markers */
        .extraction-marker {
            position: absolute;
            border: 2px solid var(--success-green);
            background: rgba(76, 175, 80, 0.15);
            pointer-events: all;
            cursor: pointer;
            box-sizing: border-box; /* Include border in size */
        }

        .extraction-marker:hover {
            background: rgba(76, 175, 80, 0.3);
            z-index: 1000;
        }

        .extraction-marker::before {
            content: attr(data-field);
            position: absolute;
            top: -24px;
            left: 0;
            background: var(--success-green);
            color: white;
            padding: 2px 8px;
            font-size: 11px;
            border-radius: var(--border-radius-sm);
            white-space: nowrap;
            opacity: 0;
            transition: opacity var(--transition-normal);
            z-index: 1001;
            pointer-events: none;
        }
        .extraction-marker[data-method^="gemini"] {
            border-color: #9b61f9;
            background: rgba(155, 97, 249, 0.15);
        }
        .extraction-marker[data-method^="gemini"]::before {
            background: #9b61f9;
        }
        .extraction-marker[data-method^="gemini"]:hover {
             background: rgba(155, 97, 249, 0.3);
        }


        .extraction-marker:hover::before {
            opacity: 1;
        }

        /* Search Result Markers */
        .search-marker {
            position: absolute;
            border: 2px solid #FF5722;
            background: rgba(255, 87, 34, 0.2);
            pointer-events: all;
            cursor: pointer;
            z-index: 500;
            box-sizing: border-box; /* Include border in size */
        }

        .search-marker:hover {
            background: rgba(255, 87, 34, 0.4);
        }

        .search-marker::before {
            content: "Match";
            position: absolute;
            top: -24px;
            left: 0;
            background: #FF5722;
            color: white;
            padding: 2px 8px;
            font-size: 11px;
            border-radius: var(--border-radius-sm);
            white-space: nowrap;
            opacity: 0;
            transition: opacity var(--transition-normal);
            z-index: 1001;
        }

        .search-marker:hover::before {
            opacity: 1;
        }

        /* Image Selection Tool Styles */
        .image-selection-box {
            position: absolute;
            border: 3px dashed #2196F3;
            background: rgba(33, 150, 243, 0.15);
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(33, 150, 243, 0.3);
        }

        /* Image thumbnails in trace log */
        .trace-entry .image-thumbnail {
            width: 100%;
            max-width: 120px;
            height: auto;
            object-fit: cover;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 8px;
            border: 2px solid #2196F3;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .trace-entry .image-thumbnail:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }

        .trace-entry[data-method="image"] {
            border-left: 4px solid #2196F3;
            background: #e3f2fd;
        }


        /* Trace Panel Styles */
        .trace-entry {
            background: var(--gray-100);
            border: 1px solid var(--gray-300);
            border-radius: var(--border-radius-md);
            padding: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
            font-size: 12px;
        }
        
        .trace-entry[data-method^="gemini"] {
            border-left: 4px solid #9b61f9;
        }
        .trace-entry[data-method^="manual"] {
            border-left: 4px solid var(--success-green);
        }

        .trace-entry:hover {
            background: #e3f2fd;
            border-color: var(--info-blue);
            transform: translateX(3px);
        }

        .trace-entry .field-label {
            font-weight: bold;
            color: var(--gray-900);
            display: block;
            margin-bottom: 4px;
        }

        .trace-entry .extracted-text {
            color: var(--gray-700);
            font-size: 11px;
            margin: 6px 0;
            padding: 4px;
            background: white;
            border-left: 3px solid var(--gray-400);
            display: block;
            word-wrap: break-word;
        }
        
        .trace-entry[data-method^="manual"] .extracted-text {
             border-left-color: var(--success-green);
        }
        .trace-entry[data-method^="gemini"] .extracted-text {
             border-left-color: #9b61f9;
        }

        .trace-entry .metadata {
            font-size: 10px;
            color: var(--gray-500);
            text-transform: capitalize;
        }

        /* Export Section */
        .export-section {
            background: #f0f8ff;
            padding: 12px;
            border-radius: var(--border-radius-lg);
            margin-bottom: var(--spacing-md);
        }

        .export-section h4 {
            margin: 0 0 var(--spacing-sm) 0;
            font-size: 14px;
        }

        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .export-buttons button {
            padding: 6px;
            font-size: 11px;
        }

        /* Markdown Section */
        .markdown-section {
            background: #fff3e0;
            padding: 12px;
            border-radius: var(--border-radius-lg);
            margin-bottom: var(--spacing-md);
            border: 1px solid var(--warning-orange);
        }

        .markdown-section h4 {
            margin: 0 0 8px 0;
            color: var(--warning-orange);
            font-size: 14px;
        }

        .markdown-section button {
            padding: 6px 12px;
            font-size: 12px;
            background: var(--warning-orange);
            margin-right: var(--spacing-xs);
        }

        .markdown-section button:hover {
            background: var(--warning-orange-dark);
        }

        #markdown-status {
            font-size: 11px;
            margin-top: var(--spacing-xs);
            color: var(--gray-500);
        }

        .trace-title {
            font-size: 18px;
            margin-top: 0;
        }

        .export-json { background: var(--success-green); color: white; }
        .export-csv { background: var(--info-blue); color: white; }
        .export-audit { background: var(--warning-orange); color: white; }
        .export-pdf { background: #9C27B0; color: white; }

        .search-interface {
            margin-top: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: white;
            border-radius: var(--border-radius-md);
            display: none;
        }

        .search-interface.active {
            display: block;
        }

        .search-interface textarea {
            width: 100%;
            height: 80px;
            margin-bottom: 8px;
            font-size: 12px;
            box-sizing: border-box; /* Include padding/border */
        }

        .search-results {
            max-height: 200px;
            overflow-y: auto;
            margin-top: var(--spacing-sm);
        }

        .search-result-item {
            padding: 8px;
            background: #f5f5f5;
            margin-bottom: var(--spacing-xs);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: 11px;
        }

        .search-result-item:hover {
            background: #e0e0e0;
        }


        /* Button Styles */
        button {
            padding: var(--spacing-sm) var(--spacing-lg);
            cursor: pointer;
            border: none;
            border-radius: var(--border-radius-md);
            background-color: var(--primary-blue);
            color: white;
            font-size: 16px;
            transition: background-color var(--transition-normal);
        }

        button:hover {
            background-color: var(--primary-blue-dark);
        }

        button:disabled {
            background-color: var(--gray-400);
            cursor: not-allowed;
        }

        .add-btn {
            background-color: #28a745;
            font-size: 14px;
            padding: 6px 12px;
            margin-top: var(--spacing-sm);
        }

        .add-btn:hover {
            background-color: #218838;
        }

        .remove-btn {
            background-color: #dc3545;
            font-size: 14px;
            padding: 6px 12px;
            margin-top: var(--spacing-sm);
        }

        .remove-btn:hover {
            background-color: var(--error-red-dark);
        }
        
        .validate-btn {
            background-color: #6c757d;
            color: white;
            padding: 4px 8px;
            font-size: 12px;
            margin-left: 5px;
        }
        .validate-btn:hover {
            background-color: #5a6268;
        }

        .hidden,
        input[type="file"] {
            display: none;
        }

        .full-width {
            width: 100%;
        }
        
        #submit-btn-group {
            display: flex;
            gap: 10px;
        }

        /* Gemini Button Styles */
        .gemini-btn {
            background: linear-gradient(135deg, #4285F4, #9b61f9);
            color: white;
            padding: 8px 14px;
            font-size: 14px;
            margin: var(--spacing-sm) 0;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        .gemini-btn:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transform: translateY(-1px);
        }
        .gemini-loading {
            font-size: 13px;
            color: var(--primary-blue-dark);
            margin: var(--spacing-sm) 0;
        }


        /* Animations and UI Effects */
        @keyframes pulse {
            0% {
                background: #fff3e0;
            }
            50% {
                background: #ffe0b2;
            }
            100% {
                background: #fff3e0;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* Status Message */
        .extraction-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px 20px;
            border-radius: var(--border-radius-xl);
            box-shadow: var(--shadow-xl);
            display: none;
            z-index: 1000;
            max-width: 400px; /* For longer validation messages */
            word-wrap: break-word; /* Wrap long quotes */
        }

        .extraction-status.show {
            display: block;
            animation: slideUp var(--transition-normal);
        }

        /* Loading Spinner */
        .loading-spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            display: none;
            background-color: rgba(255, 255, 255, 0.7); /* Optional overlay */
            padding: 20px;
            border-radius: var(--border-radius-lg);
        }

        .loading-spinner.active {
            display: block;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Settings Modal */
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .settings-modal.active {
            display: flex;
        }

        .settings-content {
            background: white;
            padding: var(--spacing-xl);
            border-radius: var(--border-radius-xl);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow-xl);
        }

        .settings-content h2 {
            margin-top: 0;
            border-bottom: 2px solid var(--primary-blue);
            padding-bottom: var(--spacing-sm);
        }

        .settings-group {
            margin-bottom: var(--spacing-lg);
            padding: var(--spacing-md);
            background: var(--gray-100);
            border-radius: var(--border-radius-md);
        }

        .settings-group h3 {
            margin-top: 0;
            font-size: 16px;
            color: var(--gray-800);
        }

        .settings-group label {
            display: block;
            font-size: 13px;
            margin-bottom: var(--spacing-xs);
            color: var(--gray-600);
        }

        .settings-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--gray-400);
            border-radius: var(--border-radius-md);
            font-size: 13px;
            font-family: monospace;
            box-sizing: border-box;
        }

        .settings-group .help-text {
            font-size: 11px;
            color: var(--gray-500);
            margin-top: 4px;
            line-height: 1.4;
        }

        .settings-actions {
            display: flex;
            gap: var(--spacing-sm);
            justify-content: flex-end;
            margin-top: var(--spacing-lg);
        }

        .key-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: var(--border-radius-sm);
            font-size: 11px;
            margin-left: var(--spacing-xs);
        }

        .key-status.configured {
            background: var(--success-green);
            color: white;
        }

        .key-status.missing {
            background: var(--error-red);
            color: white;
        }

        .security-warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-left: 4px solid #ff9800;
            padding: var(--spacing-md);
            border-radius: var(--border-radius-md);
            margin: var(--spacing-lg) 0;
            font-size: 12px;
            line-height: 1.6;
        }

        .security-warning h4 {
            margin: 0 0 var(--spacing-xs) 0;
            color: #856404;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .security-warning p {
            margin: var(--spacing-xs) 0;
            color: #856404;
        }

        .security-warning ul {
            margin: var(--spacing-xs) 0;
            padding-left: 20px;
            color: #856404;
        }

        .security-warning li {
            margin: 3px 0;
        }

        /* ========================================================================== */
        /* RESPONSIVE DESIGN - Media Queries */
        /* ========================================================================== */

        /* Panel Toggle Buttons (hidden on desktop, visible on mobile/tablet) */
        .panel-toggle {
            display: none;
            position: fixed;
            z-index: 1000;
            background: var(--primary-blue);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: var(--border-radius-md);
            cursor: pointer;
            box-shadow: var(--shadow-lg);
            font-size: 18px;
            transition: all var(--transition-fast);
        }

        .panel-toggle:hover {
            background: var(--primary-blue-dark);
            transform: scale(1.05);
        }

        .panel-toggle:active {
            transform: scale(0.95);
        }

        /* Tablet Layout (768px - 1199px) */
        @media (max-width: 1199px) {
            .main-container {
                flex-wrap: wrap;
            }

            .form-panel {
                width: 45%;
                max-height: 100vh;
                overflow-y: auto;
            }

            .pdf-panel {
                width: 55%;
                max-height: 100vh;
            }

            .trace-panel {
                width: 100%;
                max-height: 400px;
                border-left: none;
                border-top: 2px solid var(--gray-400);
            }

            /* Reduce grid columns on tablet */
            .grid-3col {
                grid-template-columns: 1fr 1fr;
            }

            .grid-mrs {
                grid-template-columns: repeat(4, 1fr);
            }

            /* Make toolbar wrap more gracefully */
            .pdf-toolbar {
                gap: 8px;
            }

            .pdf-toolbar button {
                padding: 5px 10px;
                font-size: 13px;
            }
        }

        /* Mobile Layout (< 768px) */
        @media (max-width: 767px) {
            body {
                overflow-x: hidden;
            }

            .main-container {
                flex-direction: column;
            }

            /* All panels stack vertically */
            .form-panel,
            .pdf-panel,
            .trace-panel {
                width: 100%;
                max-height: none;
                border: none;
            }

            .form-panel {
                order: 1;
                min-height: auto;
                padding: var(--spacing-md);
            }

            .pdf-panel {
                order: 2;
                min-height: 400px;
            }

            .trace-panel {
                order: 3;
                border-top: 2px solid var(--gray-400);
                padding: var(--spacing-md);
            }

            /* Collapsible panels on mobile */
            .form-panel.collapsed,
            .trace-panel.collapsed {
                display: none;
            }

            /* Toggle buttons visible on mobile */
            .panel-toggle {
                display: block;
            }

            #toggle-form {
                top: 10px;
                left: 10px;
            }

            #toggle-trace {
                bottom: 10px;
                right: 10px;
            }

            /* Typography adjustments */
            h1 {
                font-size: 20px;
            }

            h2 {
                font-size: 18px;
            }

            h3 {
                font-size: 16px;
            }

            /* Form layout */
            .grid-2col,
            .grid-3col {
                grid-template-columns: 1fr;
                gap: var(--spacing-sm);
            }

            .grid-mrs {
                grid-template-columns: repeat(2, 1fr);
                gap: var(--spacing-xs);
            }

            /* Buttons */
            button {
                padding: 10px 14px;
                font-size: 14px;
            }

            .navigation {
                flex-direction: column;
                gap: var(--spacing-sm);
                padding: var(--spacing-sm);
            }

            .navigation button {
                width: 100%;
            }

            /* PDF Toolbar */
            .pdf-toolbar {
                flex-direction: column;
                align-items: stretch;
                gap: var(--spacing-xs);
            }

            .pdf-toolbar button,
            .pdf-toolbar select {
                width: 100%;
            }

            #active-field-indicator {
                margin-left: 0;
                margin-top: var(--spacing-xs);
                text-align: center;
            }

            /* Form groups */
            .form-group {
                margin-bottom: var(--spacing-sm);
                padding: var(--spacing-xs);
            }

            input[type="text"],
            input[type="number"],
            input[type="email"],
            select,
            textarea {
                font-size: 16px; /* Prevent iOS zoom on focus */
            }

            /* Modals */
            .settings-modal .settings-content {
                width: 95%;
                max-width: none;
                margin: 5% auto;
                padding: var(--spacing-md);
            }

            /* Table parser modal */
            #table-parser-modal .settings-content {
                max-width: none;
            }

            /* Stats container */
            .stats-row {
                flex-direction: column;
                gap: var(--spacing-xs);
            }

            /* PDF Container */
            .pdf-container {
                padding: var(--spacing-sm) 0;
            }

            .pdf-page {
                max-width: 100%;
                margin: var(--spacing-sm) auto;
            }

            /* Upload area */
            .upload-area {
                margin: var(--spacing-md);
                padding: var(--spacing-lg);
            }
        }

        /* Small Mobile (< 480px) */
        @media (max-width: 479px) {
            .form-panel,
            .trace-panel {
                padding: var(--spacing-sm);
            }

            h1 {
                font-size: 18px;
            }

            .grid-mrs {
                grid-template-columns: 1fr;
            }

            .pdf-toolbar button {
                padding: 8px 10px;
                font-size: 12px;
            }

            .panel-toggle {
                padding: 10px 12px;
                font-size: 16px;
            }
        }

        /* ============================================================================
           PREPROCESSING SIDEBAR
           ============================================================================ */
        .preprocessing-sidebar {
            position: fixed;
            right: 0;
            top: 0;
            width: 350px;
            height: 100vh;
            background: white;
            border-left: 2px solid #e0e0e0;
            box-shadow: -4px 0 12px rgba(0,0,0,0.1);
            z-index: 1001;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .preprocessing-sidebar.collapsed {
            transform: translateX(100%);
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .sidebar-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .sidebar-header .icon-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sidebar-header .icon-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .sidebar-content {
            padding: 20px;
        }

        .sidebar-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .sidebar-section:last-child {
            border-bottom: none;
        }

        .sidebar-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .nav-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .nav-list li {
            padding: 10px 12px;
            margin: 6px 0;
            background: #f8f9fa;
            border-left: 3px solid #667eea;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }

        .nav-list li:hover {
            background: #e8eaf6;
            border-left-color: #5e35b1;
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }

        .nav-list li strong {
            display: block;
            color: #333;
            margin-bottom: 4px;
            text-transform: capitalize;
        }

        .nav-list li small {
            color: #666;
            font-size: 11px;
        }

        .nav-list:empty::after {
            content: "None detected";
            display: block;
            padding: 12px;
            text-align: center;
            color: #999;
            font-style: italic;
            font-size: 13px;
        }

        .sidebar-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        .sidebar-actions button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            background: #667eea;
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .sidebar-actions button:hover {
            background: #5e35b1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .sidebar-actions button:active {
            transform: translateY(0);
        }

        #doc-overview p {
            margin: 6px 0;
            font-size: 13px;
            line-height: 1.6;
        }

        #doc-overview strong {
            color: #667eea;
            font-weight: 600;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .preprocessing-sidebar {
                width: 100%;
                max-width: 350px;
            }
        }

        /* Sidebar toggle button (floating when sidebar is closed) */
        .sidebar-toggle-float {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: #667eea;
            color: white;
            border: none;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            cursor: pointer;
            z-index: 1000;
            font-size: 20px;
            transition: all 0.3s;
            display: none;
        }

        .sidebar-toggle-float:hover {
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .preprocessing-sidebar.collapsed ~ .sidebar-toggle-float {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* ============================================================================
           SMART SUGGESTION POPUP
           ============================================================================ */
        .suggestion-popup {
            position: absolute;
            background: white;
            border: 2px solid #667eea;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            z-index: 10001;
            width: 400px;
            max-width: 90vw;
            animation: fadeInUp 0.3s ease;
        }

        .suggestion-popup.hidden {
            display: none;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .suggestion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px 10px 0 0;
        }

        .suggestion-title {
            font-weight: 600;
            font-size: 14px;
        }

        .suggestion-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .suggestion-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .suggestion-content {
            padding: 12px;
            max-height: 400px;
            overflow-y: auto;
        }

        .suggestion-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            transition: all 0.2s;
        }

        .suggestion-item:hover {
            background: #e8eaf6;
            border-color: #667eea;
            transform: translateX(4px);
        }

        .suggestion-item.suggestion-top {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.05));
            border: 2px solid #667eea;
        }

        .suggestion-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .suggestion-badge.table {
            background: #4CAF50;
            color: white;
        }

        .suggestion-badge.section {
            background: #2196F3;
            color: white;
        }

        .suggestion-info {
            flex: 1;
            min-width: 0;
        }

        .suggestion-item-title {
            font-weight: 600;
            font-size: 13px;
            color: #333;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .suggestion-item-meta {
            font-size: 11px;
            color: #666;
        }

        .suggestion-action {
            padding: 6px 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .suggestion-action:hover {
            background: #5568d3;
            transform: scale(1.05);
        }

        .suggestion-footer {
            padding: 10px 16px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: flex-end;
        }

        .suggestion-disable {
            padding: 6px 12px;
            background: transparent;
            color: #666;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-disable:hover {
            background: #f5f5f5;
            border-color: #bbb;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .suggestion-popup {
                width: 90vw;
                left: 5vw !important;
            }
        }
    </style>
</head>
<body>
    <!-- Mobile Panel Toggle Buttons (hidden on desktop) -->
    <button id="toggle-form" class="panel-toggle" onclick="togglePanel('form')" title="Toggle Form Panel">
        ‚ò∞ Form
    </button>
    <button id="toggle-trace" class="panel-toggle" onclick="togglePanel('trace')" title="Toggle Trace Log">
        üìã Trace
    </button>

    <div class="main-container">
        <!-- Preprocessing Sidebar (Right) -->
        <div id="preprocessing-sidebar" class="preprocessing-sidebar collapsed">
            <div class="sidebar-header">
                <h3>üìä Document Structure</h3>
                <button id="toggle-sidebar" class="icon-btn" title="Toggle sidebar">‚óÄ</button>
            </div>

            <div class="sidebar-content">
                <!-- Document Overview -->
                <div class="sidebar-section">
                    <h4>Overview</h4>
                    <div id="doc-overview">
                        <p style="color: #999; font-style: italic;">No document loaded</p>
                    </div>
                </div>

                <!-- Sections Navigator -->
                <div class="sidebar-section">
                    <h4>üìÑ Sections (<span id="section-count">0</span>)</h4>
                    <ul id="sections-list" class="nav-list"></ul>
                </div>

                <!-- Tables List -->
                <div class="sidebar-section">
                    <h4>üìä Tables (<span id="table-count">0</span>)</h4>
                    <ul id="tables-list" class="nav-list"></ul>
                </div>

                <!-- Citations List -->
                <div class="sidebar-section">
                    <h4>üìö Citations (<span id="citation-count">0</span>)</h4>
                    <ul id="citations-list" class="nav-list"></ul>
                </div>

                <!-- Actions -->
                <div class="sidebar-actions">
                    <button id="export-structure-btn" class="btn-secondary" title="Export preprocessing data as JSON">
                        üíæ Export JSON
                    </button>
                    <button id="toggle-overlays-btn" class="btn-secondary" title="Toggle PDF overlay annotations">
                        üëÅÔ∏è Toggle Overlays
                    </button>
                </div>
            </div>
        </div>

        <!-- Form Panel (Left) -->
        <div class="form-panel">
            <h1>Clinical Study Master Extraction</h1>
            <p class="subtitle">
                Click a field, then highlight text in the PDF to extract with full traceability.
            </p>

            <!-- Progress Bar -->
            <div id="progress-bar-container">
                <div id="progress-bar"></div>
            </div>

            <!-- Main Form -->
            <form id="extraction-form">
                <!-- Step 1: Study ID -->
                <div class="step active" id="step-1">
                    <h2>Step 1: Study ID</h2>
                    <div class="form-group">
                        <label for="citation">Full Citation (Required)</label>
                        <div class="ai-field-group">
                            <textarea id="citation" name="citation" class="linked-input" placeholder="Paste citation or title, then click ‚ú®" required></textarea>
                            <button type="button" class="gemini-btn" title="Find Metadata with AI Search" onclick="findMetadata()" style="padding: 8px 12px; margin: 0; font-size: 14px;">‚ú®</button>
                        </div>
                        <div id="metadata-loading" class="gemini-loading" style="display: none;">‚ú® Searching for metadata...</div>
                    </div>
                    <div class="grid-2col">
                        <div class="form-group">
                            <label for="doi">DOI</label>
                            <input type="text" id="doi" name="doi" class="linked-input" data-validation="doi">
                            <span class="validation-message">Invalid DOI format</span>
                        </div>
                        <div class="form-group">
                            <label for="pmid">PMID</label>
                            <input type="text" id="pmid" name="pmid" class="linked-input" data-validation="pmid">
                            <span class="validation-message">PMID must be numeric</span>
                        </div>
                    </div>
                    <div class="grid-3col">
                        <div class="form-group">
                            <label for="journal">Journal</label>
                            <input type="text" id="journal" name="journal" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="year">Year</label>
                            <input type="number" id="year" name="year" class="linked-input" data-validation="year">
                            <span class="validation-message">Invalid year (1900-2100)</span>
                        </div>
                        <div class="form-group">
                            <label for="country">Country</label>
                            <input type="text" id="country" name="country" class="linked-input">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="centers">Centers (e.g., Single, Multi)</label>
                        <input type="text" id="centers" name="centers" class="linked-input">
                    </div>
                    <div class="form-group">
                        <label for="funding">Funding Sources</label>
                        <textarea id="funding" name="funding" class="linked-input"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="conflicts">Conflicts of Interest</label>
                        <textarea id="conflicts" name="conflicts" class="linked-input"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="registration">Trial Registration ID</label>
                        <input type="text" id="registration" name="registration" class="linked-input">
                    </div>
                </div>

                <!-- Step 2: PICO-T -->
                <div class="step" id="step-2">
                    <h2>Step 2: PICO-T</h2>
                    <button type="button" class="gemini-btn" onclick="generatePICO()">‚ú® Generate PICO-T Summary</button>
                    <div id="pico-loading" class="gemini-loading" style="display: none;">‚ú® Generating PICO-T...</div>

                    <div class="form-group">
                        <label for="eligibility-population">Population</label>
                        <div class="ai-field-group">
                            <textarea id="eligibility-population" name="eligibility-population" class="linked-input"></textarea>
                            <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-population')">‚úì</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="eligibility-intervention">Intervention</label>
                        <div class="ai-field-group">
                            <textarea id="eligibility-intervention" name="eligibility-intervention" class="linked-input"></textarea>
                            <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-intervention')">‚úì</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="eligibility-comparator">Comparator</label>
                        <div class="ai-field-group">
                        <textarea id="eligibility-comparator" name="eligibility-comparator" class="linked-input"></textarea>
                            <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-comparator')">‚úì</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="eligibility-outcomes">Outcomes Measured</label>
                        <div class="ai-field-group">
                            <textarea id="eligibility-outcomes" name="eligibility-outcomes" class="linked-input"></textarea>
                            <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-outcomes')">‚úì</button>
                        </div>
                    </div>
                    <div class="grid-2col">
                        <div class="form-group">
                            <label for="eligibility-timing">Timing/Follow-up</label>
                            <div class="ai-field-group">
                                <input type="text" id="eligibility-timing" name="eligibility-timing" class="linked-input">
                                <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-timing')">‚úì</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="eligibility-type">Study Type (e.g., RCT, Cohort)</label>
                             <div class="ai-field-group">
                                <input type="text" id="eligibility-type" name="eligibility-type" class="linked-input">
                                <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-type')">‚úì</button>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="inclusion-met">Inclusion Criteria Met?</label>
                        <select id="inclusion-met" name="inclusion-met" required>
                            <option value="">Select...</option>
                            <option value="true">Yes</option>
                            <option value="false">No (Stop Extraction)</option>
                        </select>
                    </div>
                </div>

                <!-- Step 3: Baseline -->
                <div class="step" id="step-3">
                    <h2>Step 3: Baseline</h2>
                    <h3>Sample Size</h3>
                    <div class="grid-3col">
                        <div class="form-group">
                            <label for="totalN">Total N (Required)</label>
                            <input type="number" id="totalN" name="totalN" class="linked-input" required>
                        </div>
                        <div class="form-group">
                            <label for="surgicalN">Surgical N</label>
                            <input type="number" id="surgicalN" name="surgicalN" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="controlN">Control N</label>
                            <input type="number" id="controlN" name="controlN" class="linked-input">
                        </div>
                    </div>
                    <h3>Age Demographics</h3>
                    <div class="dynamic-container">
                        <div class="grid-2col">
                            <div class="form-group">
                                <label for="ageMean">Age Mean</label>
                                <input type="number" step="0.1" id="ageMean" name="ageMean" class="linked-input">
                            </div>
                            <div class="form-group">
                                <label for="ageSD">Age SD</label>
                                <input type="number" step="0.1" id="ageSD" name="ageSD" class="linked-input">
                            </div>
                        </div>
                        <div class="grid-3col">
                            <div class="form-group">
                                <label for="ageMedian">Age Median</label>
                                <input type="number" step="0.1" id="ageMedian" name="ageMedian" class="linked-input">
                            </div>
                            <div class="form-group">
                                <label for="ageIQR_lower">Age IQR (Lower/Q1)</label>
                                <input type="number" step="0.1" id="ageIQR_lower" name="ageIQR_lower" class="linked-input">
                            </div>
                            <div class="form-group">
                                <label for="ageIQR_upper">Age IQR (Upper/Q3)</label>
                                <input type="number" step="0.1" id="ageIQR_upper" name="ageIQR_upper" class="linked-input">
                            </div>
                        </div>
                    </div>
                    <h3>Gender</h3>
                    <div class="grid-2col">
                        <div class="form-group">
                            <label for="maleN">Male N</label>
                            <input type="number" id="maleN" name="maleN" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="femaleN">Female N</label>
                            <input type="number" id="femaleN" name="femaleN" class="linked-input">
                        </div>
                    </div>
                    <h3>Baseline Clinical Scores</h3>
                    <div class="grid-3col">
                        <div class="form-group">
                            <label for="prestrokeMRS">Pre-stroke mRS</label>
                            <input type="number" step="0.1" id="prestrokeMRS" name="prestrokeMRS" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="nihssMean">NIHSS Mean/Median</label>
                            <input type="number" step="0.1" id="nihssMean" name="nihssMean" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="gcsMean">GCS Mean/Median</label>
                            <input type="number" step="0.1" id="gcsMean" name="gcsMean" class="linked-input">
                        </div>
                    </div>
                </div>

                <!-- Step 4: Imaging -->
                <div class="step" id="step-4">
                    <h2>Step 4: Imaging</h2>
                    <div class="form-group">
                        <label for="vascularTerritory">Vascular Territory</label>
                        <input type="text" id="vascularTerritory" name="vascularTerritory" class="linked-input">
                    </div>
                    <div class="grid-2col">
                        <div class="form-group">
                            <label for="infarctVolume">Infarct Volume</label>
                            <input type="number" step="0.1" id="infarctVolume" name="infarctVolume" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="strokeVolumeCerebellum">Stroke Volume (Cerebellum)</label>
                            <input type="text" id="strokeVolumeCerebellum" name="strokeVolumeCerebellum" class="linked-input">
                        </div>
                    </div>
                    <h3>Edema Dynamics</h3>
                    <div class="form-group">
                        <label for="edemaDynamics">Edema Description</label>
                        <textarea id="edemaDynamics" name="edemaDynamics" class="linked-input"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="peakSwellingWindow">Peak Swelling Window</label>
                        <input type="text" id="peakSwellingWindow" name="peakSwellingWindow" class="linked-input">
                    </div>
                    <h3>Involvement Areas</h3>
                    <div class="grid-3col">
                        <div class="form-group">
                            <label for="brainstemInvolvement">Brainstem Involvement?</label>
                            <select id="brainstemInvolvement" name="brainstemInvolvement">
                                <option value="null">Unknown</option>
                                <option value="true">Yes</option>
                                <option value="false">No</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="supratentorialInvolvement">Supratentorial?</label>
                            <select id="supratentorialInvolvement" name="supratentorialInvolvement">
                                <option value="null">Unknown</option>
                                <option value="true">Yes</option>
                                <option value="false">No</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="nonCerebellarStroke">Non-cerebellar?</label>
                            <select id="nonCerebellarStroke" name="nonCerebellarStroke">
                                <option value="null">Unknown</option>
                                <option value="true">Yes</option>
                                <option value="false">No</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Step 5: Interventions -->
                <div class="step" id="step-5">
                    <h2>Step 5: Interventions</h2>
                    <h3>Surgical Indications</h3>
                    <div id="indications-container"></div>
                    <button type="button" class="add-btn" onclick="addIndication()">+ Add Indication</button>
                    <h3>Interventions</h3>
                    <div id="interventions-container"></div>
                    <button type="button" class="add-btn" onclick="addIntervention()">+ Add Intervention Type</button>
                </div>

                <!-- Step 6: Study Arms -->
                <div class="step" id="step-6">
                    <h2>Step 6: Study Arms</h2>
                    <p class="subtitle">Define the distinct groups for comparison.</p>
                    <div id="arms-container"></div>
                    <button type="button" class="add-btn" onclick="addArm()">+ Add Study Arm</button>
                </div>

                <!-- Step 7: Outcomes -->
                <div class="step" id="step-7">
                    <h2>Step 7: Outcomes</h2>
                    <h3>Mortality Data</h3>
                    <div id="mortality-global-container"></div>
                    <button type="button" class="add-btn" onclick="addMortality()">+ Add Mortality Data</button>
                    <h3>Modified Rankin Scale (mRS)</h3>
                    <div id="mrs-global-container"></div>
                    <button type="button" class="add-btn" onclick="addMRS()">+ Add mRS Data</button>
                </div>

                <!-- Step 8: Complications -->
                <div class="step" id="step-8">
                    <h2>Step 8: Complications</h2>
                    <h3>Complications</h3>
                    <div id="complications-container"></div>
                    <button type="button" class="add-btn" onclick="addComplication()">+ Add Complication</button>
                    
                    <h3>Predictors of Outcome</h3>
                    <div class="form-group">
                        <label for="predictorsPoorOutcomeSurgical">Summary of Key Findings / Predictors</label>
                        <button type="button" class="gemini-btn" onclick="generateSummary()">‚ú® Summarize Key Findings</button>
                        <div id="summary-loading" class="gemini-loading" style="display: none;">‚ú® Generating Summary...</div>
                        <div class="ai-field-group">
                            <textarea id="predictorsPoorOutcomeSurgical" name="predictorsPoorOutcomeSurgical" class="linked-input" rows="6"></textarea>
                            <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('predictorsPoorOutcomeSurgical')">‚úì</button>
                        </div>
                    </div>
                    <h4>Predictor Analysis</h4>
                    <div id="predictors-container"></div>
                    <button type="button" class="add-btn" onclick="addPredictor()">+ Add Predictor</button>
                </div>
            </form>

            <!-- Navigation -->
            <div class="navigation">
                <div id="step-indicator">Step 1 of 8</div>
                <div>
                    <button id="prev-btn" disabled>Previous</button>
                    <button id="next-btn">Next</button>
                    <div id="submit-btn-group" class="hidden">
                        <button id="submit-gsheets-btn" onclick="handleSubmitToGoogleSheets(event)">Save to Google Sheets</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- PDF Panel (Center) -->
        <div class="pdf-panel">
            <div class="pdf-toolbar">
                <button id="pdf-upload-btn">üìÑ Load PDF</button>
                <input type="file" id="pdf-file" accept=".pdf" aria-label="Upload PDF file">
                <button id="pdf-prev-page" aria-label="Previous Page">‚óÑ</button>
                <span class="toolbar-text">
                    Page <input type="number" id="page-num" value="1" min="1" aria-label="Page number">
                    of <span id="total-pages">0</span>
                </span>
                <button id="pdf-next-page" aria-label="Next Page">‚ñ∫</button>
                <select id="zoom-level" aria-label="Zoom level">
                    <option value="0.75">75%</option>
                    <option value="1" selected>100%</option>
                    <option value="1.25">125%</option>
                    <option value="1.5">150%</option>
                </select>
                <button id="fit-width">Fit Width</button>
                <button id="region-mode-btn" class="selection-mode-toggle" onclick="toggleRegionMode()" title="Toggle Region Selection Mode">üî≤ Region</button>
                <label style="display: inline-flex; align-items: center; margin-left: 5px; font-size: 12px; cursor: pointer;" title="Use AI Vision to parse tables from regions">
                    <input type="checkbox" id="ai-table-mode" style="margin-right: 4px; width: auto;">
                    <span>ü§ñ AI Table</span>
                </label>
                <button id="image-mode-btn" class="selection-mode-toggle" onclick="toggleImageMode()" title="Toggle Image Capture Mode">üì∑ Image</button>
                <button id="import-annotations-btn" onclick="importPDFAnnotations()" title="Import PDF Annotations">üìù Annotations</button>
                <button id="settings-btn" onclick="openSettings()" title="Configure API Keys">‚öôÔ∏è Settings</button>
                <span id="active-field-indicator">No field selected</span>
            </div>
            <div id="pdf-container" class="pdf-container">
                <div id="upload-area" class="upload-area" role="button" tabindex="0" aria-label="Upload PDF Area">
                    <h3>üìÑ Drop PDF file here or click to browse</h3>
                    <label for="pdf-file-2" class="upload-link">
                        Select PDF File
                    </label>
                    <input type="file" id="pdf-file-2" accept=".pdf" aria-label="Upload PDF file (alternative)">
                </div>
                <div id="pdf-pages" style="display: none;" aria-live="polite">
                    <!-- PDF pages will be rendered here -->
                </div>
            </div>
        </div>

        <!-- Trace Panel (Right) -->
        <div class="trace-panel">
            <h2 class="trace-title">Extraction Trace Log</h2>
            <div class="markdown-section">
                <h4>üìù Markdown Assistant</h4>
                <button onclick="document.getElementById('markdown-file').click()">Load Markdown</button>
                <button onclick="toggleSearchInterface()">Search Text</button>
                <input type="file" id="markdown-file" accept=".md,.txt" aria-label="Upload markdown file">
                <div id="markdown-status">No markdown file loaded.</div>
                <div id="search-interface" class="search-interface">
                    <label for="search-query" class="hidden">Search Query</label>
                    <textarea id="search-query" placeholder="Paste or type text to search in PDF..."></textarea>
                    <button onclick="searchInPDF()" class="full-width">üîç Find in PDF</button>
                    <div id="search-results" class="search-results" aria-live="polite">
                        <!-- Search results will appear here -->
                    </div>
                </div>
            </div>
            <div class="export-section">
                <h4>Export Options</h4>
                <div class="export-buttons">
                    <button onclick="exportJSON()" class="export-json">üìÑ JSON</button>
                    <button onclick="exportCSV()" class="export-csv">üìä CSV</button>
                    <button onclick="exportAudit()" class="export-audit">üìã Audit</button>
                    <button onclick="exportAnnotatedPDF()" class="export-pdf">üìë PDF</button>
                </div>
            </div>
            <div class="stats-container">
                <div class="stats-row">
                    <span>Total Extractions:</span>
                    <strong id="extraction-count">0</strong>
                </div>
                <div class="stats-row">
                    <span>Pages with Data:</span>
                    <strong id="pages-with-data">0</strong>
                </div>
            </div>
            <div id="trace-log" aria-live="polite">
                <!-- Trace log entries will appear here -->
            </div>
        </div>
    </div>

    <!-- Status Message -->
    <div id="extraction-status" class="extraction-status" role="alert" aria-live="assertive">
        <span id="status-message"></span>
    </div>

    <!-- Loading Spinner -->
    <div class="loading-spinner" id="loading-spinner" role="status" aria-label="Loading">
        <div class="spinner"></div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="settings-modal" role="dialog" aria-labelledby="settings-title">
        <div class="settings-content">
            <h2 id="settings-title">‚öôÔ∏è Application Settings</h2>
            
            <div class="settings-group">
                <h3>ü§ñ AI Provider <span id="ai-status" class="key-status missing">Not Configured</span></h3>
                <label for="ai-provider">AI Provider</label>
                <select id="ai-provider" onchange="updateProviderFields()">
                    <option value="gemini">Google Gemini (Recommended)</option>
                    <option value="anthropic">Anthropic Claude</option>
                    <option value="openai">OpenAI GPT-4</option>
                </select>
                <p class="help-text">Select the AI provider for PICO-T generation, summaries, and validation.</p>
                
                <label for="ai-api-key" style="margin-top: 15px;">API Key</label>
                <input type="password" id="ai-api-key" placeholder="Enter your AI API key">
                <p class="help-text" id="ai-help-text">
                    Get Gemini key from: <a href="https://makersuite.google.com/app/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio</a>
                </p>
            </div>

            <div class="settings-group">
                <h3>üìä Google Sheets Integration <span id="sheets-status" class="key-status missing">Not Configured</span></h3>
                <label for="google-client-id">OAuth Client ID</label>
                <input type="text" id="google-client-id" placeholder="123456789-abc.apps.googleusercontent.com">
                <p class="help-text">Get from: <a href="https://console.cloud.google.com/apis/credentials" target="_blank" rel="noopener">Google Cloud Console</a> ‚Üí OAuth 2.0 Client ID</p>
                
                <label for="google-sheet-id" style="margin-top: 15px;">Google Sheet ID</label>
                <input type="text" id="google-sheet-id" placeholder="1BxiMVs0XRA5nFMdKv...">
                <p class="help-text">From your sheet URL: docs.google.com/spreadsheets/d/<strong>[SHEET_ID]</strong>/edit</p>
            </div>

            <!-- Security Notice -->
            <div class="security-warning">
                <h4>üîê Security & Privacy Notice</h4>
                <p><strong>API Key Storage:</strong> Your API keys are stored in browser localStorage using Base64 encoding. This is <strong>NOT encryption</strong> - it only obfuscates the data.</p>
                <p><strong>What this means:</strong></p>
                <ul>
                    <li>Keys can be accessed via browser DevTools (F12 ‚Üí Application ‚Üí localStorage)</li>
                    <li>Browser extensions may be able to read localStorage</li>
                    <li>Keys persist until you clear browser data or click "Clear All"</li>
                </ul>
                <p><strong>Best Practices:</strong></p>
                <ul>
                    <li>Don't use this on shared or public computers</li>
                    <li>Use API keys with usage limits and monitoring</li>
                    <li>Clear settings when done: Click "Clear All" button</li>
                    <li>For better security, clear browser data after each session</li>
                </ul>
                <p><strong>Data Privacy:</strong> All PDF processing happens locally in your browser. No data is sent to external servers except when using AI features (PDF text sent to selected AI provider) or Google Sheets export.</p>
            </div>

            <!-- Session Management -->
            <div class="settings-group">
                <h3>üíæ Session Management <span id="session-status" class="key-status missing">No Session</span></h3>
                <p class="help-text">Your work is automatically saved to browser storage. Export sessions to files for backup, sharing, or working across devices.</p>

                <!-- Auto-Save Status -->
                <div id="session-info" style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px; font-size: 12px;">
                    <p style="margin: 0;">
                        <strong>Auto-save:</strong> <span id="session-timestamp">Never</span>
                    </p>
                    <p style="margin: 5px 0 0 0;">
                        <strong>Current step:</strong> <span id="session-step">N/A</span>
                    </p>
                </div>

                <!-- Export Session to File -->
                <div style="margin-top: 15px; padding: 10px; background: #e8f5e9; border-radius: 4px; border-left: 4px solid #4caf50;">
                    <p style="margin: 0 0 8px 0; font-weight: 600; font-size: 13px;">üì• Export Session to File</p>
                    <p class="help-text" style="margin: 0 0 10px 0;">Save complete progress to a JSON file. Share with colleagues or use as backup.</p>

                    <label style="display: block; font-size: 12px; margin-bottom: 5px;">
                        <input type="checkbox" id="include-pdf-export" style="width: auto; margin-right: 5px;">
                        Include PDF file (~1.33x larger)
                    </label>
                    <p class="help-text" style="margin: 0 0 10px 0;">
                        <span id="export-size-estimate">Estimated size: Calculating...</span>
                    </p>

                    <button onclick="exportSessionToFile()" style="padding: 8px 15px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; font-weight: 600;">
                        üì• Download Session File
                    </button>
                </div>

                <!-- Import Session from File -->
                <div style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 4px; border-left: 4px solid #2196f3;">
                    <p style="margin: 0 0 8px 0; font-weight: 600; font-size: 13px;">üì§ Import Session from File</p>
                    <p class="help-text" style="margin: 0 0 10px 0;">Restore a previously saved session from a JSON file.</p>

                    <input type="file" id="session-import-file" accept=".json" style="display: none;" onchange="handleSessionImport(event)">
                    <button onclick="document.getElementById('session-import-file').click()" style="padding: 8px 15px; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; font-weight: 600;">
                        üì§ Upload Session File
                    </button>
                </div>

                <!-- Clear Browser Storage -->
                <button onclick="clearSessionData()" style="margin-top: 15px; padding: 8px 15px; background: var(--error-red); color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">
                    üóëÔ∏è Clear Browser Storage
                </button>
                <p class="help-text" style="margin-top: 5px;">This clears auto-saved data in browser storage only. Exported files are not affected.</p>
            </div>

            <div class="settings-actions">
                <button onclick="closeSettings()" style="background: var(--gray-500);">Cancel</button>
                <button onclick="clearSettings()" style="background: var(--error-red);">Clear All</button>
                <button onclick="saveSettings()" style="background: var(--success-green);">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Table Parser Result Modal -->
    <div id="table-parser-modal" class="settings-modal" role="dialog" aria-labelledby="table-parser-title">
        <div class="settings-content" style="max-width: 900px;">
            <h2 id="table-parser-title">ü§ñ AI Table Parser Results</h2>

            <div class="settings-group">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <strong>Provider:</strong> <span id="table-provider-name">-</span> |
                        <strong>Rows:</strong> <span id="table-row-count">0</span> |
                        <strong>Columns:</strong> <span id="table-col-count">0</span>
                    </div>
                    <div>
                        <button onclick="exportTableAsJSON()" style="padding: 6px 12px; margin-right: 5px;" title="Export as JSON">üìÑ JSON</button>
                        <button onclick="exportTableAsCSV()" style="padding: 6px 12px;" title="Export as CSV">üìä CSV</button>
                    </div>
                </div>

                <div id="table-preview-container" style="max-height: 400px; overflow: auto; border: 1px solid var(--gray-300); border-radius: 4px; padding: 10px; background: white;">
                    <table id="table-preview" style="width: 100%; border-collapse: collapse; font-size: 13px;">
                        <!-- Table content will be dynamically inserted here -->
                    </table>
                </div>

                <div id="table-json-container" style="margin-top: 15px; display: none;">
                    <label style="font-weight: 600;">Raw JSON:</label>
                    <pre id="table-json" style="background: #f5f5f5; padding: 10px; border-radius: 4px; max-height: 200px; overflow: auto; font-size: 12px;"></pre>
                </div>

                <label style="margin-top: 10px; display: inline-flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="show-raw-json" onchange="toggleRawJSON()" style="margin-right: 5px; width: auto;">
                    <span>Show raw JSON</span>
                </label>
            </div>

            <div class="settings-actions">
                <button onclick="closeTableParser()" style="background: var(--gray-500);">Close</button>
                <button onclick="copyTableToClipboard()" style="background: var(--primary-blue);">üìã Copy to Clipboard</button>
            </div>
        </div>
    </div>

    <!-- Main Application Logic (Bundled/Simplified) -->
    <script type="module">
        // ============================================================================
        // CONFIGURATION SECTION
        // ============================================================================
        // Configure your API keys and Google Sheets integration below
        // All features work without API keys except:
        //   - AI-powered PICO-T generation
        //   - AI summary generation
        //   - AI field validation
        //   - Metadata search (uses Google Search grounding)
        //   - Google Sheets export
        // ============================================================================
        
        const CONFIG = {
            // ============================================================================
            // STEP 1: ADD YOUR API KEYS HERE
            // ============================================================================
            
            // AI API KEY - Required for AI features (works with all providers)
            // Supported providers: Gemini, Anthropic Claude, OpenAI GPT
            // Configure provider in Settings (‚öôÔ∏è button)
            // Features: PICO-T generation, summaries, validation, metadata search
            // Example: "AIzaSyD7..." (Gemini), "sk-ant-..." (Anthropic), "sk-..." (OpenAI)
            AI_API_KEY: "AIzaSyB0fmdmQ5tP5sWaI7scEa_72iKLb3pns70",
            
            // GOOGLE CLOUD API KEY - Currently unused (reserved for future features)
            // Get from: https://console.cloud.google.com
            // Go to: APIs & Services > Credentials > Create Credentials > API Key
            // Example: "AIzaSyA9876543210zyxwvutsrqponmlkjihgfedcba"
            GOOGLE_API_KEY: "PASTE_YOUR_GOOGLE_API_KEY_HERE",
            
            // GOOGLE OAUTH CLIENT ID - Required for Google Sheets export
            // Get from: https://console.cloud.google.com
            // Go to: APIs & Services > Credentials > Create Credentials > OAuth 2.0 Client ID
            // Application type: Web application
            // Authorized JavaScript origins: http://localhost:8000
            // Example: "123456789-abcdefghijklmnop.apps.googleusercontent.com"
            GOOGLE_CLIENT_ID: "84349733634-cmkfsru9aul9f7bndeq2s78rifr42gdh.apps.googleusercontent.com",
            
            // GOOGLE SHEET ID - Your destination Google Sheet
            // From your Google Sheet URL: docs.google.com/spreadsheets/d/{SHEET_ID}/edit
            // Required tabs: "Submissions" and "Extractions"
            // Example: "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms"
            GOOGLE_SHEET_ID: "1P7EQq4hTx8-5YTXQPEcIYLLKq9tsxjNagA8qWVv6JVw",
            
            // Google Sheets API scope (do not modify)
            GOOGLE_SCOPES: "https://www.googleapis.com/auth/spreadsheets"
            
            // ============================================================================
            // SETUP INSTRUCTIONS:
            // 1. Fill in the API keys above
            // 2. Save this file
            // 3. Run a local server: python -m http.server 8000
            // 4. Open in browser: http://localhost:8000/Clinical_Study_Extraction.html
            // 5. Load a PDF and start extracting!
            // ============================================================================
        };
        
        const PDFConfig = {
            workerSrc: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js',
            documentOptions: {
                cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/cmaps/',
                cMapPacked: true,
                password: ''
            }
        };


        // ============================================================================
        // PDF ANNOTATION MANAGER (Using pdf-lib)
        // ============================================================================
        
        const PDFAnnotationManager = {
            annotations: [],
            
            async addHighlight(params) {
                const annotation = {
                    id: `anno_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: 'highlight',
                    pageNum: params.pageNum,
                    x: params.x,
                    y: params.y,
                    width: params.width,
                    height: params.height,
                    color: params.color || '#FFFF00',
                    fieldName: params.fieldName,
                    text: params.text,
                    timestamp: new Date().toISOString()
                };
                
                this.annotations.push(annotation);
                this.renderAnnotationOverlay(annotation);
                return annotation;
            },
            
            renderAnnotationOverlay(annotation) {
                const state = AppStateManager.getState();
                if (state.currentPage !== annotation.pageNum) return;
                
                const highlightLayer = document.getElementById('highlight-layer');
                if (!highlightLayer) return;
                
                const highlight = document.createElement('div');
                highlight.className = 'pdf-highlight';
                highlight.id = annotation.id;
                Object.assign(highlight.style, {
                    position: 'absolute',
                    left: `${annotation.x}px`,
                    top: `${annotation.y}px`,
                    width: `${annotation.width}px`,
                    height: `${annotation.height}px`,
                    backgroundColor: this.hexToRgba(annotation.color, 0.3),
                    border: `2px solid ${annotation.color}`,
                    pointerEvents: 'auto',
                    cursor: 'pointer'
                });
                highlight.title = `${annotation.fieldName}: ${annotation.text.substring(0, 50)}...`;
                highlight.onclick = () => {
                    if (confirm('Remove this highlight?')) {
                        this.removeAnnotation(annotation.id);
                    }
                };
                highlightLayer.appendChild(highlight);
            },
            
            renderCurrentPageAnnotations() {
                const state = AppStateManager.getState();
                const highlightLayer = document.getElementById('highlight-layer');
                if (!highlightLayer) return;
                highlightLayer.innerHTML = '';
                this.annotations
                    .filter(anno => anno.pageNum === state.currentPage)
                    .forEach(anno => this.renderAnnotationOverlay(anno));
            },
            
            removeAnnotation(annotationId) {
                this.annotations = this.annotations.filter(a => a.id !== annotationId);
                const element = document.getElementById(annotationId);
                if (element) element.remove();
                StatusManager.show('Highlight removed', 'info', 2000);
            },
            
            async exportAnnotatedPDF() {
                const state = AppStateManager.getState();
                if (!state.pdfBlob) {
                    StatusManager.show('No PDF loaded to annotate', 'warning');
                    return;
                }
                StatusManager.showLoading(true);
                StatusManager.show('Creating annotated PDF...', 'info');
                try {
                    const arrayBuffer = await state.pdfBlob.arrayBuffer();
                    const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                    const annotationsByPage = {};
                    this.annotations.forEach(anno => {
                        if (!annotationsByPage[anno.pageNum]) annotationsByPage[anno.pageNum] = [];
                        annotationsByPage[anno.pageNum].push(anno);
                    });
                    for (const [pageNum, annos] of Object.entries(annotationsByPage)) {
                        const pageIndex = parseInt(pageNum) - 1;
                        const page = pdfDoc.getPage(pageIndex);
                        const { height } = page.getSize();
                        annos.forEach(anno => {
                            const pdfY = height - anno.y - anno.height;
                            const color = this.hexToRgb(anno.color);
                            page.drawRectangle({
                                x: anno.x,
                                y: pdfY,
                                width: anno.width,
                                height: anno.height,
                                borderColor: PDFLib.rgb(color.r, color.g, color.b),
                                borderWidth: 2,
                                color: PDFLib.rgb(color.r, color.g, color.b),
                                opacity: 0.3
                            });
                            page.drawText(anno.fieldName, {
                                x: anno.x,
                                y: pdfY + anno.height + 5,
                                size: 8,
                                color: PDFLib.rgb(1, 0, 0)
                            });
                        });
                    }
                    const pdfBytes = await pdfDoc.save();
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `annotated_${state.documentName}`;
                    a.click();
                    URL.revokeObjectURL(url);
                    StatusManager.showLoading(false);
                    StatusManager.show('‚úì Annotated PDF exported', 'success');
                } catch (error) {
                    console.error('PDF Annotation Export Error:', error);
                    StatusManager.showLoading(false);
                    StatusManager.show(`Export failed: ${error.message}`, 'error');
                }
            },
            
            async createExtractionWithHighlight(fieldName, text, pageNum, coords) {
                const extraction = ExtractionTracker.addExtraction({
                    fieldName: fieldName,
                    text: text,
                    page: pageNum,
                    method: 'manual',
                    coordinates: coords
                });
                await this.addHighlight({
                    pageNum: pageNum,
                    x: coords.x,
                    y: coords.y,
                    width: coords.width,
                    height: coords.height,
                    color: this.getColorForField(fieldName),
                    fieldName: fieldName,
                    text: text
                });
                return extraction;
            },
            
            getColorForField(fieldName) {
                const colorMap = {
                    citation: '#FFD700', doi: '#87CEEB', pmid: '#90EE90',
                    population: '#FFB6C1', intervention: '#DDA0DD', comparator: '#F0E68C',
                    outcome: '#FFA07A', default: '#FFFF00'
                };
                for (const [key, color] of Object.entries(colorMap)) {
                    if (fieldName.toLowerCase().includes(key)) return color;
                }
                return colorMap.default;
            },
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16) / 255,
                    g: parseInt(result[2], 16) / 255,
                    b: parseInt(result[3], 16) / 255
                } : { r: 1, g: 1, b: 0 };
            },
            
            hexToRgba(hex, alpha) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                if (!result) return `rgba(255, 255, 0, ${alpha})`;
                const r = parseInt(result[1], 16);
                const g = parseInt(result[2], 16);
                const b = parseInt(result[3], 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            },
            
            getAllAnnotations() {
                return this.annotations;
            },
            
            clearAllAnnotations() {
                this.annotations = [];
                const highlightLayer = document.getElementById('highlight-layer');
                if (highlightLayer) highlightLayer.innerHTML = '';
                StatusManager.show('All highlights cleared', 'info');
            }
        };
        
        window.PDFAnnotationManager = PDFAnnotationManager;

        // ============================================================================
        // REGION SELECTION MANAGER - Feature 1: Region-based Text Selection
        // ============================================================================
        
        const RegionSelectionManager = {
            mode: false,
            startPoint: null,
            currentBox: null,
            listeners: [],
            
            enable() {
                this.mode = true;
                const btn = document.getElementById('region-mode-btn');
                btn?.classList.add('active');
                
                // Add event listeners to PDF page
                const pdfContainer = document.getElementById('pdf-container');
                if (!pdfContainer) return;
                
                const mouseDownHandler = (e) => this.handleMouseDown(e);
                const mouseMoveHandler = (e) => this.handleMouseMove(e);
                const mouseUpHandler = (e) => this.handleMouseUp(e);
                
                pdfContainer.addEventListener('mousedown', mouseDownHandler);
                pdfContainer.addEventListener('mousemove', mouseMoveHandler);
                pdfContainer.addEventListener('mouseup', mouseUpHandler);
                
                // Store listeners for cleanup
                this.listeners = [
                    { element: pdfContainer, type: 'mousedown', handler: mouseDownHandler },
                    { element: pdfContainer, type: 'mousemove', handler: mouseMoveHandler },
                    { element: pdfContainer, type: 'mouseup', handler: mouseUpHandler }
                ];
                
                // Change cursor
                pdfContainer.style.cursor = 'crosshair';
            },
            
            disable() {
                this.mode = false;
                const btn = document.getElementById('region-mode-btn');
                btn?.classList.remove('active');
                
                // Remove event listeners
                this.listeners.forEach(({ element, type, handler }) => {
                    element.removeEventListener(type, handler);
                });
                this.listeners = [];
                
                // Reset cursor
                const pdfContainer = document.getElementById('pdf-container');
                if (pdfContainer) pdfContainer.style.cursor = '';
                
                // Remove any active box
                this.removeCurrentBox();
            },
            
            handleMouseDown(e) {
                if (!this.mode) return;
                
                // Check if clicking on the PDF page itself
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const containerBounds = e.currentTarget.getBoundingClientRect();
                
                // Calculate position relative to page
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                // Only start if clicking within page bounds
                if (x >= 0 && x <= pageBounds.width && y >= 0 && y <= pageBounds.height) {
                    this.startPoint = { x, y };
                    this.createBox(x, y);
                }
            },
            
            handleMouseMove(e) {
                if (!this.mode || !this.startPoint || !this.currentBox) return;
                
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                // Update box dimensions
                const width = Math.abs(x - this.startPoint.x);
                const height = Math.abs(y - this.startPoint.y);
                const left = Math.min(x, this.startPoint.x);
                const top = Math.min(y, this.startPoint.y);
                
                this.currentBox.style.left = left + 'px';
                this.currentBox.style.top = top + 'px';
                this.currentBox.style.width = width + 'px';
                this.currentBox.style.height = height + 'px';
            },
            
            async handleMouseUp(e) {
                if (!this.mode || !this.startPoint || !this.currentBox) return;
                
                const state = AppStateManager.getState();
                if (!state.activeField) {
                    StatusManager.show('Please select a form field first', 'warning');
                    this.removeCurrentBox();
                    this.startPoint = null;
                    return;
                }
                
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                // Calculate final rectangle
                const width = Math.abs(x - this.startPoint.x);
                const height = Math.abs(y - this.startPoint.y);
                const left = Math.min(x, this.startPoint.x);
                const top = Math.min(y, this.startPoint.y);
                
                // Minimum size check (prevent accidental clicks)
                if (width < 10 || height < 10) {
                    this.removeCurrentBox();
                    this.startPoint = null;
                    return;
                }
                
                const region = { x: left, y: top, width, height };

                // Check if AI Table Mode is enabled
                const aiTableMode = document.getElementById('ai-table-mode')?.checked;

                if (aiTableMode) {
                    // Parse table with AI Vision
                    try {
                        await TableParserManager.parseTableFromRegion(region, state.currentPage);
                    } catch (error) {
                        // Error already handled in TableParserManager
                    } finally {
                        this.removeCurrentBox();
                        this.startPoint = null;
                    }
                    return;
                }

                // Extract text from region (normal mode)
                StatusManager.showLoading(true);
                try {
                    const extractedText = await this.extractTextFromRegion(region, state.currentPage);
                    
                    if (!extractedText || extractedText.trim().length === 0) {
                        StatusManager.show('No text found in selected region', 'warning');
                        this.removeCurrentBox();
                        this.startPoint = null;
                        return;
                    }
                    
                    // Create extraction record
                    const sanitizedText = SecurityUtils.sanitizeText(extractedText);
                    const extraction = ExtractionTracker.addExtraction({
                        fieldName: state.activeField,
                        text: sanitizedText,
                        page: state.currentPage,
                        coordinates: region,
                        method: 'region',
                        documentName: state.documentName
                    });
                    
                    if (extraction && state.activeFieldElement) {
                        const element = state.activeFieldElement;
                        if (element.type === 'number') {
                            const match = sanitizedText.match(/-?\d+(\.\d+)?/);
                            element.value = match ? match[0] : '';
                        } else {
                            element.value = sanitizedText;
                        }
                        element.classList.add('has-extraction');
                    }
                    
                    if (extraction) {
                        addExtractionMarker(extraction);
                        StatusManager.show(`‚úì Extracted ${extractedText.length} chars from region`, 'success');
                        autoAdvanceField();
                    }
                    
                } catch (error) {
                    console.error('Region extraction error:', error);
                    StatusManager.show(`Region extraction failed: ${error.message}`, 'error');
                } finally {
                    StatusManager.showLoading(false);
                    this.removeCurrentBox();
                    this.startPoint = null;
                }
            },
            
            createBox(x, y) {
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                // Remove any existing box
                this.removeCurrentBox();
                
                // Create new selection box
                const box = document.createElement('div');
                box.className = 'region-selection-box';
                box.style.left = x + 'px';
                box.style.top = y + 'px';
                box.style.width = '0px';
                box.style.height = '0px';
                
                pageDiv.appendChild(box);
                this.currentBox = box;
            },
            
            removeCurrentBox() {
                if (this.currentBox) {
                    this.currentBox.remove();
                    this.currentBox = null;
                }
            },
            
            async extractTextFromRegion(region, pageNum) {
                const state = AppStateManager.getState();
                if (!state.pdfDoc) return '';
                
                try {
                    const page = await state.pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const viewport = page.getViewport({ scale: state.scale });
                    
                    // Filter text items within region bounds
                    const itemsInRegion = [];
                    
                    textContent.items.forEach(item => {
                        if (!item.str || !item.transform) return;
                        
                        // Get item position and dimensions
                        const tx = window.pdfjsLib.Util.transform(viewport.transform, item.transform);
                        const itemX = tx[4];
                        const itemY = tx[5];
                        const fontSize = Math.sqrt((tx[0] * tx[0]) + (tx[1] * tx[1]));
                        const itemWidth = item.width * tx[0];
                        const itemHeight = fontSize;
                        
                        // Check if item overlaps with region
                        const overlapsX = itemX < region.x + region.width && itemX + itemWidth > region.x;
                        const overlapsY = itemY < region.y + region.height && itemY + itemHeight > region.y;
                        
                        if (overlapsX && overlapsY) {
                            itemsInRegion.push({
                                text: item.str,
                                x: itemX,
                                y: itemY,
                                width: itemWidth,
                                height: itemHeight
                            });
                        }
                    });
                    
                    if (itemsInRegion.length === 0) return '';
                    
                    // Sort items for proper reading order (top to bottom, left to right)
                    itemsInRegion.sort((a, b) => {
                        // Group by rows (Y proximity within 5px)
                        const rowDiff = Math.abs(a.y - b.y);
                        if (rowDiff < 5) {
                            return a.x - b.x; // Same row, sort by X
                        }
                        return a.y - b.y; // Different rows, sort by Y
                    });
                    
                    // Detect if this is a table (multiple columns)
                    const isTable = this.detectTableStructure(itemsInRegion);
                    
                    if (isTable) {
                        return this.extractTableText(itemsInRegion);
                    } else {
                        // Simple concatenation with spaces
                        return itemsInRegion.map(item => item.text).join(' ');
                    }
                    
                } catch (error) {
                    console.error('Text extraction error:', error);
                    throw error;
                }
            },
            
            detectTableStructure(items) {
                if (items.length < 4) return false; // Too few items for a table
                
                // Group items by Y coordinate (rows)
                const rows = [];
                let currentRow = [items[0]];
                
                for (let i = 1; i < items.length; i++) {
                    const prevItem = items[i - 1];
                    const currItem = items[i];
                    
                    // Same row if Y difference < 5px
                    if (Math.abs(currItem.y - prevItem.y) < 5) {
                        currentRow.push(currItem);
                    } else {
                        rows.push(currentRow);
                        currentRow = [currItem];
                    }
                }
                rows.push(currentRow);
                
                // Table detected if:
                // 1. Multiple rows (at least 2)
                // 2. Consistent column count across rows
                if (rows.length < 2) return false;
                
                const colCounts = rows.map(row => row.length);
                const avgCols = colCounts.reduce((a, b) => a + b, 0) / colCounts.length;
                
                // Consider it a table if most rows have similar column counts
                return avgCols >= 2;
            },
            
            extractTableText(items) {
                // Group items by rows
                const rows = [];
                let currentRow = [items[0]];
                
                for (let i = 1; i < items.length; i++) {
                    const prevItem = items[i - 1];
                    const currItem = items[i];
                    
                    if (Math.abs(currItem.y - prevItem.y) < 5) {
                        currentRow.push(currItem);
                    } else {
                        rows.push(currentRow);
                        currentRow = [currItem];
                    }
                }
                rows.push(currentRow);
                
                // Format as tab-separated values (preserves structure)
                const formattedRows = rows.map(row => {
                    return row.map(item => item.text).join('\t');
                });
                
                return formattedRows.join('\n');
            }
        };
        
        /**
         * Toggle region selection mode
         */
        window.toggleRegionMode = function() {
            if (RegionSelectionManager.mode) {
                RegionSelectionManager.disable();
                StatusManager.show('Region selection mode disabled', 'info');
            } else {
                RegionSelectionManager.enable();
                StatusManager.show('üî≤ Region mode: Draw a box to extract text', 'info', 5000);
            }
        };

        // ============================================================================
        // IMAGE EXTRACTION MANAGER - Feature 4: Image Capture from PDF
        // ============================================================================
        
        const ImageExtractionManager = {
            mode: false,
            startPoint: null,
            currentBox: null,
            listeners: [],
            capturedCanvas: null,
            
            enable() {
                // Disable region mode if active
                if (RegionSelectionManager.mode) {
                    RegionSelectionManager.disable();
                }
                
                this.mode = true;
                const btn = document.getElementById('image-mode-btn');
                btn?.classList.add('active');
                
                const pdfContainer = document.getElementById('pdf-container');
                if (!pdfContainer) return;
                
                const mouseDownHandler = (e) => this.handleMouseDown(e);
                const mouseMoveHandler = (e) => this.handleMouseMove(e);
                const mouseUpHandler = (e) => this.handleMouseUp(e);
                
                pdfContainer.addEventListener('mousedown', mouseDownHandler);
                pdfContainer.addEventListener('mousemove', mouseMoveHandler);
                pdfContainer.addEventListener('mouseup', mouseUpHandler);
                
                this.listeners = [
                    { element: pdfContainer, type: 'mousedown', handler: mouseDownHandler },
                    { element: pdfContainer, type: 'mousemove', handler: mouseMoveHandler },
                    { element: pdfContainer, type: 'mouseup', handler: mouseUpHandler }
                ];
                
                pdfContainer.style.cursor = 'crosshair';
            },
            
            disable() {
                this.mode = false;
                const btn = document.getElementById('image-mode-btn');
                btn?.classList.remove('active');
                
                this.listeners.forEach(({ element, type, handler }) => {
                    element.removeEventListener(type, handler);
                });
                this.listeners = [];
                
                const pdfContainer = document.getElementById('pdf-container');
                if (pdfContainer) pdfContainer.style.cursor = '';
                
                this.removeCurrentBox();
            },
            
            handleMouseDown(e) {
                if (!this.mode) return;
                
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                if (x >= 0 && x <= pageBounds.width && y >= 0 && y <= pageBounds.height) {
                    this.startPoint = { x, y };
                    this.createBox(x, y);
                }
            },
            
            handleMouseMove(e) {
                if (!this.mode || !this.startPoint || !this.currentBox) return;
                
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                const width = Math.abs(x - this.startPoint.x);
                const height = Math.abs(y - this.startPoint.y);
                const left = Math.min(x, this.startPoint.x);
                const top = Math.min(y, this.startPoint.y);
                
                this.currentBox.style.left = left + 'px';
                this.currentBox.style.top = top + 'px';
                this.currentBox.style.width = width + 'px';
                this.currentBox.style.height = height + 'px';
            },
            
            async handleMouseUp(e) {
                if (!this.mode || !this.startPoint || !this.currentBox) return;
                
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                const width = Math.abs(x - this.startPoint.x);
                const height = Math.abs(y - this.startPoint.y);
                const left = Math.min(x, this.startPoint.x);
                const top = Math.min(y, this.startPoint.y);
                
                // Minimum size check
                if (width < 50 || height < 50) {
                    StatusManager.show('Selection too small (minimum 50x50px)', 'warning');
                    this.removeCurrentBox();
                    this.startPoint = null;
                    return;
                }
                
                const region = { x: left, y: top, width, height };
                
                try {
                    StatusManager.showLoading(true);
                    StatusManager.show('üì∑ Capturing image...', 'info');
                    
                    const canvas = await this.captureRegion(region);
                    this.capturedCanvas = canvas;
                    
                    // Auto-download as PNG (high quality)
                    const dataUrl = canvas.toDataURL('image/png', 1.0);
                    const filename = `figure_p${AppStateManager.getState().currentPage}_${Date.now()}.png`;
                    
                    // Download image
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = filename;
                    a.click();
                    
                    // Create extraction record with thumbnail
                    const state = AppStateManager.getState();
                    const extraction = ExtractionTracker.addExtraction({
                        fieldName: state.activeField || 'Image Capture',
                        text: `[Image: ${filename}]`,
                        page: state.currentPage,
                        coordinates: region,
                        method: 'image',
                        imageData: dataUrl,
                        documentName: state.documentName
                    });
                    
                    if (extraction) {
                        StatusManager.show(`‚úì Image saved: ${filename}`, 'success');
                    }
                    
                } catch (error) {
                    console.error('Image capture error:', error);
                    StatusManager.show(`Image capture failed: ${error.message}`, 'error');
                } finally {
                    StatusManager.showLoading(false);
                    this.removeCurrentBox();
                    this.startPoint = null;
                }
            },
            
            createBox(x, y) {
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                this.removeCurrentBox();
                
                const box = document.createElement('div');
                box.className = 'image-selection-box';
                box.style.left = x + 'px';
                box.style.top = y + 'px';
                box.style.width = '0px';
                box.style.height = '0px';
                
                pageDiv.appendChild(box);
                this.currentBox = box;
            },
            
            removeCurrentBox() {
                if (this.currentBox) {
                    this.currentBox.remove();
                    this.currentBox = null;
                }
            },
            
            async captureRegion(region) {
                const state = AppStateManager.getState();
                if (!state.pdfDoc) throw new Error('No PDF loaded');
                
                const page = await state.pdfDoc.getPage(state.currentPage);
                const viewport = page.getViewport({ scale: state.scale });
                
                // Create canvas for the selected region with high-DPI support
                const dpr = window.devicePixelRatio || 1;
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = Math.floor(region.width * dpr);
                canvas.height = Math.floor(region.height * dpr);
                canvas.style.width = region.width + 'px';
                canvas.style.height = region.height + 'px';
                
                // Render full page to temporary canvas
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = Math.floor(viewport.width * dpr);
                tempCanvas.height = Math.floor(viewport.height * dpr);
                
                const transform = [dpr, 0, 0, dpr, 0, 0];
                
                await page.render({
                    canvasContext: tempCtx,
                    viewport: viewport,
                    transform: transform
                }).promise;
                
                // Crop to selected region
                ctx.drawImage(
                    tempCanvas,
                    region.x * dpr,
                    region.y * dpr,
                    region.width * dpr,
                    region.height * dpr,
                    0,
                    0,
                    region.width * dpr,
                    region.height * dpr
                );
                
                return canvas;
            }
        };
        
        /**
         * Toggle image capture mode
         */
        window.toggleImageMode = function() {
            if (ImageExtractionManager.mode) {
                ImageExtractionManager.disable();
                StatusManager.show('Image capture mode disabled', 'info');
            } else {
                ImageExtractionManager.enable();
                StatusManager.show('üì∑ Image mode: Draw a box to capture a figure/image', 'info', 5000);
            }
        };

        // ============================================================================
        // RESPONSIVE PANEL TOGGLE - Mobile/Tablet Support
        // ============================================================================

        /**
         * Toggle panel visibility on mobile/tablet
         * @param {string} panel - 'form' or 'trace'
         */
        window.togglePanel = function(panel) {
            const formPanel = document.querySelector('.form-panel');
            const tracePanel = document.querySelector('.trace-panel');

            if (panel === 'form') {
                formPanel.classList.toggle('collapsed');

                // Save state to localStorage
                const isCollapsed = formPanel.classList.contains('collapsed');
                localStorage.setItem('formPanelCollapsed', isCollapsed);

                // Update button text
                const btn = document.getElementById('toggle-form');
                btn.textContent = isCollapsed ? '‚ò∞ Show Form' : '‚ò∞ Hide Form';

                StatusManager.show(isCollapsed ? 'Form panel hidden' : 'Form panel visible', 'info', 2000);
            } else if (panel === 'trace') {
                tracePanel.classList.toggle('collapsed');

                // Save state to localStorage
                const isCollapsed = tracePanel.classList.contains('collapsed');
                localStorage.setItem('tracePanelCollapsed', isCollapsed);

                // Update button text
                const btn = document.getElementById('toggle-trace');
                btn.textContent = isCollapsed ? 'üìã Show Trace' : 'üìã Hide Trace';

                StatusManager.show(isCollapsed ? 'Trace panel hidden' : 'Trace panel visible', 'info', 2000);
            }
        };

        /**
         * Restore panel states from localStorage on page load
         */
        function restorePanelStates() {
            // Only apply on mobile/tablet (< 768px)
            if (window.innerWidth >= 768) return;

            const formPanel = document.querySelector('.form-panel');
            const tracePanel = document.querySelector('.trace-panel');

            const formCollapsed = localStorage.getItem('formPanelCollapsed') === 'true';
            const traceCollapsed = localStorage.getItem('tracePanelCollapsed') === 'true';

            if (formCollapsed) {
                formPanel.classList.add('collapsed');
                document.getElementById('toggle-form').textContent = '‚ò∞ Show Form';
            }

            if (traceCollapsed) {
                tracePanel.classList.add('collapsed');
                document.getElementById('toggle-trace').textContent = 'üìã Show Trace';
            }
        }

        // Restore panel states on page load
        window.addEventListener('DOMContentLoaded', restorePanelStates);

        // Reset panel states when resizing to desktop
        window.addEventListener('resize', () => {
            if (window.innerWidth >= 768) {
                const formPanel = document.querySelector('.form-panel');
                const tracePanel = document.querySelector('.trace-panel');
                formPanel.classList.remove('collapsed');
                tracePanel.classList.remove('collapsed');
                document.getElementById('toggle-form').textContent = '‚ò∞ Form';
                document.getElementById('toggle-trace').textContent = 'üìã Trace';
            }
        });

        // ============================================================================
        // TABLE PARSER MANAGER - Feature 5: AI Vision Table Parsing
        // ============================================================================

        const TableParserManager = {
            currentTableData: null,

            /**
             * Parse table from region using AI Vision
             * @param {Object} region - The region coordinates {x, y, width, height}
             * @param {number} pageNum - The PDF page number
             */
            async parseTableFromRegion(region, pageNum) {
                try {
                    StatusManager.showLoading(true);
                    StatusManager.show('ü§ñ Capturing table image...', 'info');

                    // Capture region as image using ImageExtractionManager's method
                    const canvas = await ImageExtractionManager.captureRegion(region);
                    const base64Image = canvas.toDataURL('image/png', 1.0);

                    // Remove data URL prefix to get pure base64
                    const base64Data = base64Image.split(',')[1];

                    StatusManager.show('üîç Analyzing table with AI Vision...', 'info');

                    // Get current AI provider
                    const provider = AppStateManager.getState().aiProvider || 'gemini';

                    // Parse table with vision API
                    const tableData = await this.callVisionAPI(provider, base64Data);

                    // Store result
                    this.currentTableData = {
                        provider: provider,
                        data: tableData,
                        region: region,
                        page: pageNum,
                        timestamp: new Date().toISOString()
                    };

                    // Create extraction record
                    const extraction = ExtractionTracker.addExtraction({
                        fieldName: 'AI Table',
                        text: `[Table: ${tableData.rows?.length || 0} rows √ó ${tableData.headers?.length || 0} cols]`,
                        page: pageNum,
                        coordinates: region,
                        method: 'ai-table',
                        imageData: base64Image,
                        tableData: tableData,
                        documentName: AppStateManager.getState().documentName
                    });

                    if (extraction) {
                        addExtractionMarker(extraction);
                    }

                    // Display results in modal
                    this.displayTableResults(tableData, provider);

                    StatusManager.show(`‚úì Table parsed: ${tableData.rows?.length || 0} rows`, 'success');

                } catch (error) {
                    console.error('Table parsing error:', error);
                    StatusManager.show(`‚ùå Table parsing failed: ${error.message}`, 'error');
                    throw error;
                } finally {
                    StatusManager.showLoading(false);
                }
            },

            /**
             * Call Vision API to parse table
             * @param {string} provider - AI provider (gemini, anthropic, openai)
             * @param {string} base64Image - Base64 encoded image
             */
            async callVisionAPI(provider, base64Image) {
                const systemPrompt = `You are a table extraction expert. Analyze the provided image and extract the table data into structured JSON format.

**Instructions:**
1. Identify all table headers/column names
2. Extract all data rows
3. Preserve cell values exactly as they appear
4. Handle merged cells by repeating values
5. Return clean, structured JSON

**Output Format:**
{
  "headers": ["Column1", "Column2", "Column3", ...],
  "rows": [
    ["cell1", "cell2", "cell3", ...],
    ["cell1", "cell2", "cell3", ...],
    ...
  ],
  "metadata": {
    "hasHeaders": true/false,
    "rowCount": number,
    "columnCount": number,
    "notes": "any important observations"
  }
}`;

                const userPrompt = "Extract the table from this image into structured JSON format as specified.";

                if (provider === 'gemini') {
                    return await this.callGeminiVision(base64Image, systemPrompt, userPrompt);
                } else if (provider === 'anthropic') {
                    return await this.callClaudeVision(base64Image, systemPrompt, userPrompt);
                } else if (provider === 'openai') {
                    return await this.callGPT4Vision(base64Image, systemPrompt, userPrompt);
                } else {
                    throw new Error(`Unsupported AI provider: ${provider}`);
                }
            },

            /**
             * Call Gemini Vision API
             */
            async callGeminiVision(base64Image, systemPrompt, userPrompt) {
                const apiKey = CONFIG.AI_API_KEY;
                if (!apiKey || apiKey === "PASTE_YOUR_AI_API_KEY_HERE") {
                    throw new Error("Please configure your Gemini API key in Settings");
                }

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;

                const payload = {
                    contents: [{
                        parts: [
                            { text: userPrompt },
                            {
                                inline_data: {
                                    mime_type: "image/png",
                                    data: base64Image
                                }
                            }
                        ]
                    }],
                    systemInstruction: {
                        parts: [{ text: systemPrompt }]
                    },
                    generationConfig: {
                        temperature: 0.1,
                        topK: 40,
                        topP: 0.95,
                        maxOutputTokens: 8192,
                        responseMimeType: "application/json"
                    }
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Gemini API error (${response.status}): ${errorText}`);
                }

                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!text) {
                    throw new Error('No response from Gemini Vision API');
                }

                // Parse JSON response
                try {
                    return JSON.parse(text);
                } catch (e) {
                    throw new Error(`Failed to parse Gemini response as JSON: ${e.message}`);
                }
            },

            /**
             * Call Claude Vision API
             */
            async callClaudeVision(base64Image, systemPrompt, userPrompt) {
                const apiKey = CONFIG.AI_API_KEY;
                if (!apiKey || apiKey === "PASTE_YOUR_AI_API_KEY_HERE") {
                    throw new Error("Please configure your Claude API key in Settings");
                }

                const apiUrl = 'https://api.anthropic.com/v1/messages';

                const payload = {
                    model: "claude-3-5-sonnet-20241022",
                    max_tokens: 4096,
                    temperature: 0.1,
                    system: systemPrompt,
                    messages: [{
                        role: "user",
                        content: [
                            {
                                type: "image",
                                source: {
                                    type: "base64",
                                    media_type: "image/png",
                                    data: base64Image
                                }
                            },
                            {
                                type: "text",
                                text: userPrompt
                            }
                        ]
                    }]
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Claude API error (${response.status}): ${errorText}`);
                }

                const data = await response.json();
                const text = data.content?.[0]?.text;

                if (!text) {
                    throw new Error('No response from Claude Vision API');
                }

                // Extract JSON from potential markdown code blocks
                const jsonMatch = text.match(/```json\s*([\s\S]*?)\s*```/) || text.match(/{[\s\S]*}/);
                const jsonText = jsonMatch ? (jsonMatch[1] || jsonMatch[0]) : text;

                try {
                    return JSON.parse(jsonText);
                } catch (e) {
                    throw new Error(`Failed to parse Claude response as JSON: ${e.message}`);
                }
            },

            /**
             * Call GPT-4V API
             */
            async callGPT4Vision(base64Image, systemPrompt, userPrompt) {
                const apiKey = CONFIG.AI_API_KEY;
                if (!apiKey || apiKey === "PASTE_YOUR_AI_API_KEY_HERE") {
                    throw new Error("Please configure your OpenAI API key in Settings");
                }

                const apiUrl = 'https://api.openai.com/v1/chat/completions';

                const payload = {
                    model: "gpt-4-turbo",
                    max_tokens: 4096,
                    temperature: 0.1,
                    response_format: { type: "json_object" },
                    messages: [
                        {
                            role: "system",
                            content: systemPrompt
                        },
                        {
                            role: "user",
                            content: [
                                {
                                    type: "text",
                                    text: userPrompt
                                },
                                {
                                    type: "image_url",
                                    image_url: {
                                        url: `data:image/png;base64,${base64Image}`
                                    }
                                }
                            ]
                        }
                    ]
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`OpenAI API error (${response.status}): ${errorText}`);
                }

                const data = await response.json();
                const text = data.choices?.[0]?.message?.content;

                if (!text) {
                    throw new Error('No response from GPT-4V API');
                }

                try {
                    return JSON.parse(text);
                } catch (e) {
                    throw new Error(`Failed to parse GPT-4V response as JSON: ${e.message}`);
                }
            },

            /**
             * Display table results in modal
             */
            displayTableResults(tableData, provider) {
                const modal = document.getElementById('table-parser-modal');
                const providerNames = {
                    gemini: 'Google Gemini Vision',
                    anthropic: 'Claude 3.5 Sonnet',
                    openai: 'GPT-4 Turbo Vision'
                };

                // Update metadata
                document.getElementById('table-provider-name').textContent = providerNames[provider] || provider;
                document.getElementById('table-row-count').textContent = tableData.rows?.length || 0;
                document.getElementById('table-col-count').textContent = tableData.headers?.length || tableData.rows?.[0]?.length || 0;

                // Render table preview
                const tablePreview = document.getElementById('table-preview');
                let html = '<thead><tr>';

                // Render headers
                if (tableData.headers && tableData.headers.length > 0) {
                    tableData.headers.forEach(header => {
                        html += `<th style="border: 1px solid #ddd; padding: 8px; background: #f0f0f0; font-weight: 600;">${this.escapeHtml(header)}</th>`;
                    });
                } else if (tableData.rows && tableData.rows.length > 0) {
                    // Use first row as headers if not provided
                    tableData.rows[0].forEach((cell, i) => {
                        html += `<th style="border: 1px solid #ddd; padding: 8px; background: #f0f0f0; font-weight: 600;">Column ${i + 1}</th>`;
                    });
                }

                html += '</tr></thead><tbody>';

                // Render rows
                const startRow = (tableData.headers && tableData.headers.length > 0) ? 0 : 1;
                if (tableData.rows && tableData.rows.length > 0) {
                    for (let i = startRow; i < tableData.rows.length; i++) {
                        html += '<tr>';
                        tableData.rows[i].forEach(cell => {
                            html += `<td style="border: 1px solid #ddd; padding: 8px;">${this.escapeHtml(String(cell))}</td>`;
                        });
                        html += '</tr>';
                    }
                }

                html += '</tbody>';
                tablePreview.innerHTML = html;

                // Update raw JSON
                document.getElementById('table-json').textContent = JSON.stringify(tableData, null, 2);

                // Show modal
                modal.classList.add('active');
            },

            /**
             * Escape HTML to prevent XSS
             */
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        };


        // --- CLIENTS ---
        let gapiLoaded = false;
        let gapiTokenClient;
        window.gapiLoaded = () => { gapiLoaded = true; console.log("Google API client loaded."); };
        window.gisLoaded = () => {
            if (CONFIG.GOOGLE_CLIENT_ID) {
                gapiTokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CONFIG.GOOGLE_CLIENT_ID,
                    scope: CONFIG.GOOGLE_SCOPES,
                    callback: '', // Callback is set dynamically on click
                });
                console.log("Google Auth client initialized.");
            } else {
                console.warn("Google Client ID missing. 'Save to Google Sheets' will not work.");
            }
        };
        // Load Google scripts dynamically
        (function() {
            const gapiScript = document.createElement('script');
            gapiScript.src = 'https://apis.google.com/js/api.js?onload=gapiLoaded';
            gapiScript.async = true;
            gapiScript.defer = true;
            document.head.appendChild(gapiScript);

            const gisScript = document.createElement('script');
            gisScript.src = 'https://accounts.google.com/gsi/client?onload=gisLoaded';
            gisScript.async = true;
            gisScript.defer = true;
            document.head.appendChild(gisScript);
        })();


        // --- Core Modules (Simplified Implementations) ---

        // AppState (Observer Pattern Approximation)
        let AppState = {
            pdfDoc: null,
            pdfBlob: null, // Original file for export
            currentPage: 1,
            totalPages: 0,
            scale: 1.0,
            activeField: null,
            activeFieldElement: null,
            documentName: '',
            extractions: [],
            currentStep: 0,
            totalSteps: 8,
            markdownContent: '',
            markdownLoaded: false,
            pdfTextCache: new Map(),
            searchMarkers: [],
            maxCacheSize: 50,
            isProcessing: false,
            lastSubmissionId: null
        };
        const subscribers = new Set();
        const AppStateManager = {
            getState: () => ({ ...AppState }), // Return a copy
            setState: (updates) => {
                AppState = { ...AppState, ...updates };
                subscribers.forEach(cb => cb(AppState));
            },
            subscribe: (cb) => {
                subscribers.add(cb);
                return () => subscribers.delete(cb);
            }
        };

        // StatusManager
        const StatusManager = {
             statusDiv: document.getElementById('extraction-status'),
             messageSpan: document.getElementById('status-message'),
             spinnerDiv: document.getElementById('loading-spinner'),
             timeoutId: null, // Store timeout ID
             show: function(message, type = 'info', duration = 3000) {
                if (!this.statusDiv || !this.messageSpan) return;
                // Clear existing timeout if any
                if (this.timeoutId) clearTimeout(this.timeoutId);

                this.messageSpan.textContent = message;
                this.statusDiv.className = 'extraction-status show';
                const colors = { success: '#4CAF50', warning: '#FF9800', error: '#f44336', info: '#2196F3' };
                this.statusDiv.style.background = colors[type] || colors.info;
                this.statusDiv.style.color = 'white';

                this.timeoutId = setTimeout(() => {
                    this.statusDiv?.classList.remove('show');
                    this.timeoutId = null; // Clear the stored ID
                }, duration);
             },
            showLoading: function(show) {
                this.spinnerDiv?.classList.toggle('active', show);
            }
        };

        // SecurityUtils
        const SecurityUtils = {
            sanitizeText: (text) => {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                 // Basic sanitization: remove tags, trim, limit length
                return div.innerHTML.replace(/<[^>]*>?/gm, '').trim().substring(0, 10000);
            },
             validateExtraction: (extraction) => {
                // Simplified validation
                return extraction && extraction.fieldName && extraction.text && extraction.coordinates && extraction.page >= 0; // Page 0 for AI
            },
            escapeHtml: (text) => {
                if (typeof text !== 'string') return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },
            validateInput: (input) => {
                const validationType = input.dataset.validation;
                const value = input.value.trim();

                if (input.required && !value) {
                    return { valid: false, message: 'This field is required' };
                }

                if (validationType === 'doi' && value) {
                    const doiRegex = /^10\.\d{4,}\/-?[A-Za-z0-9._;()/:]+$/; // Accepts some special characters
                    if (!doiRegex.test(value)) return { valid: false, message: 'Invalid DOI format' };
                }
                if (validationType === 'pmid' && value) {
                    if (!/^\d+$/.test(value)) return { valid: false, message: 'PMID must be numeric' };
                }
                 if (validationType === 'year' && value) {
                    const year = parseInt(value);
                    if (isNaN(year) || year < 1900 || year > 2100) return { valid: false, message: 'Invalid year (1900-2100)' };
                }

                return { valid: true };
            },
             // Encode/Decode for localStorage (simplified for preview - no actual encryption)
            encodeData: (data) => btoa(JSON.stringify(data)),
            decodeData: (encodedData) => JSON.parse(atob(encodedData))
        };

         // MemoryManager (Simplified - just basic cleanup)
        const MemoryManager = {
            listeners: [],
            timeouts: [],
            registerEventListener: function(el, type, handler) {
                el.addEventListener(type, handler);
                this.listeners.push({ el, type, handler });
            },
            registerTimeout: function(id) {
                this.timeouts.push(id);
            },
            cleanup: function() {
                this.listeners.forEach(({ el, type, handler }) => el.removeEventListener(type, handler));
                this.timeouts.forEach(id => clearTimeout(id));
                this.listeners = [];
                this.timeouts = [];
                console.log("Cleanup performed (simplified)");
            }
        };
        window.addEventListener('beforeunload', () => MemoryManager.cleanup());


        // ============================================================================
        // PDF PREPROCESSING SYSTEM
        // ============================================================================

        /**
         * ProgressManager - Tracks and displays preprocessing progress
         * 5-stage progress indicator for PDF analysis
         */
        const PreprocessingProgressManager = {
            stages: [
                { name: 'Loading PDF', weight: 20 },
                { name: 'Extracting text', weight: 20 },
                { name: 'Detecting sections', weight: 20 },
                { name: 'Finding tables', weight: 20 },
                { name: 'Parsing citations', weight: 20 }
            ],
            currentStage: 0,
            currentProgress: 0,

            init: function() {
                // Create progress bar if it doesn't exist
                if (!document.getElementById('preprocessing-progress')) {
                    const progressHTML = `
                        <div id="preprocessing-progress" style="display:none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
                                                              background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                                                              z-index: 10000; min-width: 400px; max-width: 90%;">
                            <div style="font-weight: bold; margin-bottom: 10px;" id="preprocessing-stage">Initializing...</div>
                            <div style="background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden; margin-bottom: 10px;">
                                <div id="preprocessing-bar" style="background: linear-gradient(90deg, #4CAF50, #45a049); height: 100%; width: 0%;
                                                                   transition: width 0.3s ease; border-radius: 10px;"></div>
                            </div>
                            <div style="font-size: 12px; color: #666;" id="preprocessing-detail">Starting preprocessing...</div>
                        </div>
                    `;
                    document.body.insertAdjacentHTML('beforeend', progressHTML);
                }
            },

            show: function() {
                this.init();
                document.getElementById('preprocessing-progress').style.display = 'block';
                this.currentStage = 0;
                this.currentProgress = 0;
                this.update(0, 'Initializing preprocessing...');
            },

            hide: function() {
                const el = document.getElementById('preprocessing-progress');
                if (el) el.style.display = 'none';
            },

            setStage: function(stageIndex, detail = '') {
                if (stageIndex < 0 || stageIndex >= this.stages.length) return;

                this.currentStage = stageIndex;
                const stage = this.stages[stageIndex];

                // Calculate progress based on completed stages
                let cumulativeProgress = 0;
                for (let i = 0; i < stageIndex; i++) {
                    cumulativeProgress += this.stages[i].weight;
                }

                this.currentProgress = cumulativeProgress;
                this.update(this.currentProgress, detail || stage.name);

                document.getElementById('preprocessing-stage').textContent = stage.name;
            },

            updateStageProgress: function(stageProgress, detail = '') {
                // stageProgress: 0-1 within current stage
                const stage = this.stages[this.currentStage];
                const stageBaseProgress = this.currentProgress;
                const totalProgress = stageBaseProgress + (stage.weight * stageProgress);

                this.update(totalProgress, detail);
            },

            update: function(percentage, detail = '') {
                percentage = Math.min(100, Math.max(0, percentage));

                const bar = document.getElementById('preprocessing-bar');
                const detailEl = document.getElementById('preprocessing-detail');

                if (bar) bar.style.width = percentage + '%';
                if (detailEl && detail) detailEl.textContent = detail;
            },

            complete: function(message = 'Preprocessing complete!') {
                this.update(100, message);
                setTimeout(() => this.hide(), 2000);
            },

            error: function(message = 'Preprocessing failed') {
                const bar = document.getElementById('preprocessing-bar');
                if (bar) bar.style.background = '#f44336';
                this.update(this.currentProgress, '‚ùå ' + message);
                setTimeout(() => this.hide(), 3000);
            }
        };

        /**
         * CacheManager - IndexedDB caching for parsed PDF structure
         * Stores sections, tables, citations to avoid re-parsing
         */
        const PreprocessingCacheManager = {
            dbName: 'PDFPreprocessingCache',
            dbVersion: 1,
            storeName: 'parsedPDFs',
            db: null,

            init: async function() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = () => {
                        console.error('IndexedDB error:', request.error);
                        reject(request.error);
                    };

                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
                            store.createIndex('filename', 'filename', { unique: false });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                            store.createIndex('filesize', 'filesize', { unique: false });
                        }
                    };
                });
            },

            generateKey: function(filename, filesize) {
                // Unique key based on filename + filesize
                return `${filename}_${filesize}`;
            },

            get: async function(filename, filesize) {
                if (!this.db) await this.init();

                const key = this.generateKey(filename, filesize);

                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction([this.storeName], 'readonly');
                    const store = tx.objectStore(this.storeName);
                    const request = store.get(key);

                    request.onsuccess = () => {
                        const result = request.result;

                        // Check if cache is expired (7 days)
                        if (result) {
                            const age = Date.now() - result.timestamp;
                            const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days

                            if (age > maxAge) {
                                console.log('Cache expired, deleting...');
                                this.delete(key);
                                resolve(null);
                            } else {
                                console.log('Cache hit!', key);
                                resolve(result.data);
                            }
                        } else {
                            console.log('Cache miss:', key);
                            resolve(null);
                        }
                    };

                    request.onerror = () => reject(request.error);
                });
            },

            set: async function(filename, filesize, data) {
                if (!this.db) await this.init();

                const key = this.generateKey(filename, filesize);

                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction([this.storeName], 'readwrite');
                    const store = tx.objectStore(this.storeName);

                    const record = {
                        id: key,
                        filename: filename,
                        filesize: filesize,
                        timestamp: Date.now(),
                        data: data
                    };

                    const request = store.put(record);

                    request.onsuccess = () => {
                        console.log('Cache stored:', key);
                        resolve();
                    };

                    request.onerror = () => reject(request.error);
                });
            },

            delete: async function(key) {
                if (!this.db) await this.init();

                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction([this.storeName], 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    const request = store.delete(key);

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            },

            clearOld: async function(maxAge = 7 * 24 * 60 * 60 * 1000) {
                if (!this.db) await this.init();

                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction([this.storeName], 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    const index = store.index('timestamp');

                    const cutoff = Date.now() - maxAge;
                    const range = IDBKeyRange.upperBound(cutoff);

                    const request = index.openCursor(range);
                    let deleted = 0;

                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            cursor.delete();
                            deleted++;
                            cursor.continue();
                        } else {
                            console.log(`Cleared ${deleted} old cache entries`);
                            resolve(deleted);
                        }
                    };

                    request.onerror = () => reject(request.error);
                });
            },

            clearAll: async function() {
                if (!this.db) await this.init();

                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction([this.storeName], 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    const request = store.clear();

                    request.onsuccess = () => {
                        console.log('Cache cleared');
                        resolve();
                    };

                    request.onerror = () => reject(request.error);
                });
            }
        };

        /**
         * PDFStructureAnalyzer - Main preprocessing orchestrator
         * Extracts text with coordinates, detects sections, tables, and citations
         */
        const PDFStructureAnalyzer = {
            // Extract enhanced text content from all pages
            extractTextWithMetadata: async function(pdfDoc) {
                const pages = [];

                for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                    PreprocessingProgressManager.updateStageProgress(
                        pageNum / pdfDoc.numPages,
                        `Extracting text from page ${pageNum} of ${pdfDoc.numPages}...`
                    );

                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 1.0 });
                    const textContent = await page.getTextContent();

                    // Extract structured text with coordinates and font info
                    const items = textContent.items.map(item => ({
                        text: item.str,
                        x: item.transform[4],
                        y: viewport.height - item.transform[5], // Convert to top-left origin
                        width: item.width,
                        height: item.height,
                        fontSize: Math.abs(item.transform[0]), // Scale factor = font size
                        fontName: item.fontName
                    }));

                    // Calculate font statistics for this page
                    const fontSizes = items.map(i => i.fontSize).filter(s => s > 0);
                    const avgFontSize = fontSizes.length > 0
                        ? fontSizes.reduce((a,b) => a+b, 0) / fontSizes.length
                        : 12;
                    const maxFontSize = fontSizes.length > 0 ? Math.max(...fontSizes) : 12;

                    pages.push({
                        pageNum,
                        width: viewport.width,
                        height: viewport.height,
                        items,
                        fontStatistics: {
                            avg: avgFontSize,
                            max: maxFontSize,
                            min: Math.min(...fontSizes)
                        },
                        itemCount: items.length
                    });
                }

                return pages;
            },

            // Main analysis entry point
            analyze: async function(pdfDoc, filename, filesize) {
                try {
                    PreprocessingProgressManager.show();

                    // Stage 1: Loading (already done by PDFLoader)
                    PreprocessingProgressManager.setStage(0, 'PDF loaded successfully');

                    // Check cache first
                    const cached = await PreprocessingCacheManager.get(filename, filesize);
                    if (cached) {
                        console.log('Using cached preprocessing results');
                        PreprocessingProgressManager.complete('Loaded from cache!');
                        return cached;
                    }

                    // Stage 2: Extract text with metadata
                    PreprocessingProgressManager.setStage(1, 'Extracting text and metadata...');
                    const pages = await this.extractTextWithMetadata(pdfDoc);

                    // Stage 3: Detect sections
                    PreprocessingProgressManager.setStage(2, 'Identifying document sections...');
                    const sections = await this.detectSections(pages);

                    // Stage 4: Find tables
                    PreprocessingProgressManager.setStage(3, 'Detecting tables...');
                    const tables = await this.detectTables(pages);

                    // Stage 5: Parse citations
                    PreprocessingProgressManager.setStage(4, 'Extracting citations...');
                    const citations = await this.extractCitations(pages, sections);

                    // Compile results
                    const result = {
                        filename,
                        filesize,
                        totalPages: pdfDoc.numPages,
                        timestamp: new Date().toISOString(),
                        pages,
                        sections,
                        tables,
                        citations,
                        metadata: {
                            totalTextItems: pages.reduce((sum, p) => sum + p.itemCount, 0),
                            sectionCount: sections.length,
                            tableCount: tables.length,
                            citationCount: citations.length
                        }
                    };

                    // Cache the results
                    await PreprocessingCacheManager.set(filename, filesize, result);

                    PreprocessingProgressManager.complete(
                        `Analysis complete: ${sections.length} sections, ${tables.length} tables, ${citations.length} citations`
                    );

                    return result;

                } catch (error) {
                    console.error('Preprocessing error:', error);
                    PreprocessingProgressManager.error(error.message || 'Preprocessing failed');
                    throw error;
                }
            },

            // Detect sections using font size and pattern matching
            detectSections: async function(pages) {
                const sections = [];
                const patterns = {
                    abstract: /\b(abstract|summary)\b/i,
                    introduction: /\b(introduction|background)\b/i,
                    methods: /\b(methods?|materials? and methods?|methodology|patients? and methods?)\b/i,
                    results: /\b(results?|findings?|outcomes?)\b/i,
                    discussion: /\b(discussion|conclusion)\b/i,
                    references: /\b(references?|bibliography|citations?|works? cited)\b/i
                };

                pages.forEach(page => {
                    const { items, fontStatistics } = page;
                    const headingThreshold = fontStatistics.avg * 1.15; // 15% larger than average

                    items.forEach((item, index) => {
                        // Check if this is a heading (larger font)
                        const isHeading = item.fontSize > headingThreshold ||
                                        item.fontSize === fontStatistics.max;

                        if (isHeading && item.text.length > 2) {
                            // Check against section patterns
                            for (const [sectionType, pattern] of Object.entries(patterns)) {
                                if (pattern.test(item.text)) {
                                    sections.push({
                                        type: sectionType,
                                        title: item.text.trim(),
                                        page: page.pageNum,
                                        y: item.y,
                                        x: item.x,
                                        fontSize: item.fontSize
                                    });
                                    break;
                                }
                            }
                        }
                    });
                });

                // Sort by page and Y position
                sections.sort((a, b) => {
                    if (a.page !== b.page) return a.page - b.page;
                    return a.y - b.y;
                });

                return sections;
            },

            // Detect tables using coordinate clustering
            detectTables: async function(pages) {
                const tables = [];

                // This is a placeholder - table detection is complex
                // For now, we'll implement a simple version
                // TODO: Enhance with proper coordinate clustering algorithm

                pages.forEach(page => {
                    // Look for "Table" labels
                    page.items.forEach((item, index) => {
                        if (/^Table\s+\d+/i.test(item.text)) {
                            tables.push({
                                page: page.pageNum,
                                label: item.text.trim(),
                                x: item.x,
                                y: item.y,
                                // Estimate bounding box (simplified)
                                bounds: {
                                    x: item.x,
                                    y: item.y,
                                    width: 500, // Placeholder
                                    height: 200 // Placeholder
                                }
                            });
                        }
                    });
                });

                return tables;
            },

            // Extract citations from References section
            extractCitations: async function(pages, sections) {
                const citations = [];

                // Find References section
                const referencesSection = sections.find(s => s.type === 'references');
                if (!referencesSection) {
                    console.log('No references section found');
                    return citations;
                }

                // Extract text from references section onwards
                const refStartPage = referencesSection.page;
                let currentCitation = '';
                let citationNumber = 0;

                pages.forEach(page => {
                    if (page.pageNum < refStartPage) return;

                    // Sort items by Y position (top to bottom)
                    const sortedItems = [...page.items].sort((a, b) => a.y - b.y);

                    sortedItems.forEach(item => {
                        const text = item.text.trim();

                        // Detect citation start (number or author name)
                        if (/^\[?\d+\]?\.?\s*$/.test(text) || /^[A-Z][a-z]+,?\s+[A-Z]/.test(text)) {
                            // Save previous citation
                            if (currentCitation) {
                                citations.push(this.parseCitation(currentCitation, citationNumber));
                                citationNumber++;
                            }
                            currentCitation = text;
                        } else {
                            currentCitation += ' ' + text;
                        }
                    });
                });

                // Add last citation
                if (currentCitation) {
                    citations.push(this.parseCitation(currentCitation, citationNumber));
                }

                return citations;
            },

            // Parse individual citation to extract DOI, PMID, etc.
            parseCitation: function(text, number) {
                // Extract DOI
                const doiMatch = text.match(/10\.\d{4,}\/[^\s]+/);
                const doi = doiMatch ? doiMatch[0].replace(/[.,;]$/, '') : null;

                // Extract PMID
                const pmidMatch = text.match(/PMID:?\s*(\d+)/i);
                const pmid = pmidMatch ? pmidMatch[1] : null;

                // Extract year
                const yearMatch = text.match(/\b(19|20)\d{2}\b/);
                const year = yearMatch ? yearMatch[0] : null;

                // Extract journal (simplified - text between year and DOI/PMID)
                let journal = null;
                if (year) {
                    const afterYear = text.split(year)[1];
                    if (afterYear) {
                        journal = afterYear.split(/DOI|PMID|10\.\d/i)[0].trim();
                        journal = journal.substring(0, 100); // Limit length
                    }
                }

                return {
                    number,
                    text: text.trim(),
                    doi,
                    pmid,
                    year,
                    journal
                };
            }
        };

        /**
         * PreprocessingSidebarManager - Manages the interactive sidebar UI
         * Displays sections, tables, citations with navigation
         */
        const PreprocessingSidebarManager = {
            isOpen: false,
            overlaysEnabled: true,

            init: function() {
                // Toggle sidebar button
                const toggleBtn = document.getElementById('toggle-sidebar');
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', () => this.toggle());
                }

                // Export button
                const exportBtn = document.getElementById('export-structure-btn');
                if (exportBtn) {
                    exportBtn.addEventListener('click', () => this.exportJSON());
                }

                // Toggle overlays button
                const overlaysBtn = document.getElementById('toggle-overlays-btn');
                if (overlaysBtn) {
                    overlaysBtn.addEventListener('click', () => this.toggleOverlays());
                }
            },

            toggle: function() {
                const sidebar = document.getElementById('preprocessing-sidebar');
                const btn = document.getElementById('toggle-sidebar');

                if (!sidebar || !btn) return;

                this.isOpen = !this.isOpen;

                if (this.isOpen) {
                    sidebar.classList.remove('collapsed');
                    btn.textContent = '‚ñ∂';
                } else {
                    sidebar.classList.add('collapsed');
                    btn.textContent = '‚óÄ';
                }
            },

            populate: function(preprocessingData) {
                if (!preprocessingData) return;

                console.log('Populating sidebar with preprocessing data:', preprocessingData);

                // Update overview
                const overview = document.getElementById('doc-overview');
                if (overview) {
                    overview.innerHTML = `
                        <p><strong>File:</strong> ${preprocessingData.filename}</p>
                        <p><strong>Pages:</strong> ${preprocessingData.totalPages}</p>
                        <p><strong>Analyzed:</strong> ${new Date(preprocessingData.timestamp).toLocaleString()}</p>
                        <p><strong>Text Items:</strong> ${preprocessingData.metadata.totalTextItems.toLocaleString()}</p>
                    `;
                }

                // Populate sections
                this.populateSections(preprocessingData.sections);

                // Populate tables
                this.populateTables(preprocessingData.tables);

                // Populate citations
                this.populateCitations(preprocessingData.citations);

                // Update counts
                const sectionCount = document.getElementById('section-count');
                const tableCount = document.getElementById('table-count');
                const citationCount = document.getElementById('citation-count');

                if (sectionCount) sectionCount.textContent = preprocessingData.sections.length;
                if (tableCount) tableCount.textContent = preprocessingData.tables.length;
                if (citationCount) citationCount.textContent = preprocessingData.citations.length;

                // Auto-open sidebar
                if (!this.isOpen) this.toggle();
            },

            populateSections: function(sections) {
                const list = document.getElementById('sections-list');
                if (!list) return;

                list.innerHTML = '';

                sections.forEach(section => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <strong>${section.type}</strong><br>
                        <small>${section.title} (Page ${section.page})</small>
                    `;
                    li.addEventListener('click', () => {
                        PDFRenderer.renderPage(section.page);
                        StatusManager.show(`üìÑ Jumped to ${section.type} section`, 'info', 2000);
                    });
                    list.appendChild(li);
                });
            },

            populateTables: function(tables) {
                const list = document.getElementById('tables-list');
                if (!list) return;

                list.innerHTML = '';

                tables.forEach(table => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <strong>${table.label}</strong><br>
                        <small>Page ${table.page}</small>
                    `;
                    li.addEventListener('click', () => {
                        PDFRenderer.renderPage(table.page);
                        StatusManager.show(`üìä Jumped to ${table.label}`, 'info', 2000);
                    });
                    list.appendChild(li);
                });
            },

            populateCitations: function(citations) {
                const list = document.getElementById('citations-list');
                if (!list) return;

                list.innerHTML = '';

                const displayCount = Math.min(10, citations.length);

                citations.slice(0, displayCount).forEach((citation, index) => {
                    const li = document.createElement('li');

                    const shortText = citation.text.length > 80
                        ? citation.text.substring(0, 80) + '...'
                        : citation.text;

                    li.innerHTML = `
                        <small>${shortText}</small><br>
                        ${citation.doi ? `<small><strong>DOI:</strong> ${citation.doi}</small><br>` : ''}
                        ${citation.pmid ? `<small><strong>PMID:</strong> ${citation.pmid}</small>` : ''}
                    `;
                    list.appendChild(li);
                });

                if (citations.length > displayCount) {
                    const more = document.createElement('li');
                    more.style.background = '#e8eaf6';
                    more.style.borderLeft = '3px solid #5e35b1';
                    more.style.cursor = 'default';
                    more.innerHTML = `<small style="color: #5e35b1; font-weight: 600;">... and ${citations.length - displayCount} more citations</small>`;
                    list.appendChild(more);
                }
            },

            exportJSON: function() {
                const state = AppStateManager.getState();
                const data = state.preprocessingData;

                if (!data) {
                    StatusManager.show('‚ö†Ô∏è No preprocessing data to export', 'warning');
                    return;
                }

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `${data.filename.replace('.pdf', '')}_structure.json`;
                a.click();

                URL.revokeObjectURL(url);
                StatusManager.show('üíæ Structure exported successfully!', 'success', 3000);
            },

            toggleOverlays: function() {
                this.overlaysEnabled = !this.overlaysEnabled;

                const btn = document.getElementById('toggle-overlays-btn');
                if (btn) {
                    btn.textContent = this.overlaysEnabled ? 'üëÅÔ∏è Toggle Overlays' : 'üö´ Toggle Overlays';
                }

                if (this.overlaysEnabled) {
                    PreprocessingOverlayRenderer.show();
                    StatusManager.show('üëÅÔ∏è Overlays enabled', 'info', 2000);
                } else {
                    PreprocessingOverlayRenderer.hide();
                    StatusManager.show('üö´ Overlays disabled', 'info', 2000);
                }
            }
        };

        /**
         * PreprocessingOverlayRenderer - Renders bounding boxes on PDF canvas
         * Shows sections (blue), tables (green), citations (yellow)
         */
        const PreprocessingOverlayRenderer = {
            enabled: true,
            currentPage: 1,

            show: function() {
                this.enabled = true;
                this.render(this.currentPage);
            },

            hide: function() {
                this.enabled = false;
                this.clearOverlays();
            },

            render: function(pageNum) {
                if (!this.enabled) return;

                this.currentPage = pageNum;
                const state = AppStateManager.getState();
                const data = state.preprocessingData;

                if (!data) return;

                // Find the PDF canvas for this page
                const pageContainer = document.getElementById(`pdf-page-${pageNum}`);
                if (!pageContainer) return;

                const canvas = pageContainer.querySelector('canvas');
                if (!canvas) return;

                // Create or get overlay canvas
                let overlay = pageContainer.querySelector('.pdf-overlay');
                if (!overlay) {
                    overlay = document.createElement('canvas');
                    overlay.className = 'pdf-overlay';
                    overlay.style.position = 'absolute';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.pointerEvents = 'none';
                    overlay.width = canvas.width;
                    overlay.height = canvas.height;
                    pageContainer.appendChild(overlay);
                }

                const ctx = overlay.getContext('2d');
                ctx.clearRect(0, 0, overlay.width, overlay.height);

                // Get scale factor
                const scale = canvas.width / data.pages[pageNum - 1]?.width || 1;

                // Draw section boxes (blue)
                const pageSections = data.sections.filter(s => s.page === pageNum);
                pageSections.forEach(section => {
                    this.drawBox(
                        ctx,
                        section.x * scale,
                        section.y * scale,
                        400 * scale,
                        30 * scale,
                        'rgba(33, 150, 243, 0.15)',
                        '#2196F3',
                        2
                    );
                });

                // Draw table boxes (green)
                const pageTables = data.tables.filter(t => t.page === pageNum);
                pageTables.forEach(table => {
                    const bounds = table.bounds;
                    this.drawBox(
                        ctx,
                        bounds.x * scale,
                        bounds.y * scale,
                        bounds.width * scale,
                        bounds.height * scale,
                        'rgba(76, 175, 80, 0.15)',
                        '#4CAF50',
                        3
                    );
                });
            },

            drawBox: function(ctx, x, y, width, height, fillColor, strokeColor, lineWidth = 2) {
                // Fill
                ctx.fillStyle = fillColor;
                ctx.fillRect(x, y, width, height);

                // Stroke
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = lineWidth;
                ctx.strokeRect(x, y, width, height);
            },

            clearOverlays: function() {
                const overlays = document.querySelectorAll('.pdf-overlay');
                overlays.forEach(overlay => overlay.remove());
            }
        };

        // Expose PreprocessingOverlayRenderer globally for sidebar and other components
        window.PreprocessingOverlayRenderer = PreprocessingOverlayRenderer;

        // Initialize sidebar on DOM load
        window.addEventListener('DOMContentLoaded', () => {
            PreprocessingSidebarManager.init();
        });

        // ========================================================================
        // SMART SUGGESTION ENGINE
        // ========================================================================

        /**
         * FieldSuggestionEngine - Maps form fields to relevant PDF sections/tables
         * Provides intelligent suggestions for where to find data
         */
        const FieldSuggestionEngine = {
            preprocessingData: null,

            // Field mapping database: field ID ‚Üí likely locations
            fieldMappings: {
                // Study ID fields
                'citation': { sections: ['abstract', 'methods'], tables: [], keywords: ['study', 'title', 'authors'], priority: 'HIGH' },
                'doi': { sections: ['abstract', 'references'], tables: [], keywords: ['doi', 'digital object'], priority: 'HIGH' },
                'pmid': { sections: ['abstract', 'references'], tables: [], keywords: ['pmid', 'pubmed'], priority: 'HIGH' },
                'journal': { sections: ['abstract'], tables: [], keywords: ['journal', 'published'], priority: 'MEDIUM' },
                'year': { sections: ['abstract'], tables: [], keywords: ['year', '20'], priority: 'MEDIUM' },

                // Demographics
                'totalN': { sections: ['methods', 'results'], tables: [1, 2], keywords: ['patients', 'enrolled', 'sample size', 'total'], priority: 'HIGH' },
                'surgicalN': { sections: ['methods', 'results'], tables: [1, 3], keywords: ['surgical', 'intervention', 'treatment'], priority: 'HIGH' },
                'controlN': { sections: ['methods', 'results'], tables: [1, 3], keywords: ['control', 'conservative', 'medical'], priority: 'HIGH' },
                'ageMean': { sections: ['methods', 'results'], tables: [1], keywords: ['age', 'mean', 'years', 'old'], priority: 'HIGH' },
                'ageSD': { sections: ['methods', 'results'], tables: [1], keywords: ['age', 'sd', 'standard deviation'], priority: 'HIGH' },
                'maleN': { sections: ['methods', 'results'], tables: [1], keywords: ['male', 'sex', 'gender', 'men'], priority: 'MEDIUM' },
                'femaleN': { sections: ['methods', 'results'], tables: [1], keywords: ['female', 'sex', 'gender', 'women'], priority: 'MEDIUM' },

                // Baseline characteristics
                'prestrokeMRS': { sections: ['methods', 'results'], tables: [1], keywords: ['baseline', 'mrs', 'pre-stroke', 'modified rankin'], priority: 'MEDIUM' },
                'nihssMean': { sections: ['methods', 'results'], tables: [1], keywords: ['nihss', 'stroke severity', 'neurological'], priority: 'MEDIUM' },
                'gcsMean': { sections: ['methods', 'results'], tables: [1], keywords: ['gcs', 'glasgow', 'coma scale'], priority: 'MEDIUM' },

                // Imaging
                'vascularTerritory': { sections: ['methods', 'results'], tables: [1, 2], keywords: ['vascular', 'territory', 'pica', 'sca', 'aica'], priority: 'MEDIUM' },
                'infarctVolume': { sections: ['results'], tables: [2], keywords: ['volume', 'infarct', 'mm3', 'ml', 'cerebellar'], priority: 'HIGH' },
                'strokeVolumeCerebellum': { sections: ['results'], tables: [2], keywords: ['cerebellar', 'volume', 'stroke'], priority: 'MEDIUM' },
                'brainstemInvolvement': { sections: ['results'], tables: [2], keywords: ['brainstem', 'midbrain', 'pons'], priority: 'MEDIUM' },

                // Outcomes
                'mortality_deaths': { sections: ['results'], tables: [4, 5], keywords: ['mortality', 'deaths', 'deceased', 'died'], priority: 'HIGH' },
                'mortality_total': { sections: ['results'], tables: [4, 5], keywords: ['mortality', 'total', 'patients'], priority: 'HIGH' },
                'mrs_0': { sections: ['results'], tables: [5], keywords: ['mrs', 'modified rankin', 'score 0', 'no symptoms'], priority: 'HIGH' },
                'mrs_6': { sections: ['results'], tables: [5], keywords: ['mrs', 'modified rankin', 'score 6', 'dead'], priority: 'HIGH' },

                // Interventions
                'intervention_type': { sections: ['methods', 'results'], tables: [3], keywords: ['sdc', 'evd', 'decompression', 'surgery'], priority: 'HIGH' },
                'intervention_time': { sections: ['methods', 'results'], tables: [3], keywords: ['time to surgery', 'hours', 'timing'], priority: 'HIGH' },

                // Predictors
                'pred_var': { sections: ['discussion', 'results'], tables: [6], keywords: ['predictor', 'factor', 'associated'], priority: 'MEDIUM' },
                'pred_effect': { sections: ['discussion', 'results'], tables: [6], keywords: ['odds ratio', 'or', 'hr', 'hazard'], priority: 'MEDIUM' },
                'pred_pvalue': { sections: ['discussion', 'results'], tables: [6], keywords: ['p-value', 'p <', 'significance'], priority: 'MEDIUM' }
            },

            init: function(preprocessingData) {
                this.preprocessingData = preprocessingData;
                console.log('FieldSuggestionEngine initialized with', preprocessingData.metadata);
            },

            getSuggestions: function(fieldId, fieldLabel) {
                if (!this.preprocessingData) return [];

                const suggestions = [];
                const mapping = this.fieldMappings[fieldId] || this.inferMappingFromLabel(fieldLabel);

                if (!mapping) return [];

                // Find matching sections
                mapping.sections.forEach(sectionType => {
                    const section = this.preprocessingData.sections.find(s =>
                        s.type === sectionType || s.title.toLowerCase().includes(sectionType)
                    );
                    if (section) {
                        suggestions.push({
                            type: 'SECTION',
                            title: section.title,
                            page: section.page,
                            relevance: mapping.priority === 'HIGH' ? 0.9 : 0.7,
                            sectionType: section.type,
                            action: 'jumpToPage'
                        });
                    }
                });

                // Find matching tables
                mapping.tables.forEach(tableNum => {
                    const table = this.preprocessingData.tables.find(t =>
                        t.label.includes(`Table ${tableNum}`) || t.label.includes(`${tableNum}`)
                    );
                    if (table) {
                        suggestions.push({
                            type: 'TABLE',
                            title: table.label,
                            page: table.page,
                            relevance: mapping.priority === 'HIGH' ? 0.95 : 0.85,
                            tableData: table,
                            action: 'jumpToPage'
                        });
                    }
                });

                // Sort by relevance
                return suggestions.sort((a, b) => b.relevance - a.relevance);
            },

            inferMappingFromLabel: function(label) {
                if (!label) return null;

                const lower = label.toLowerCase();

                // Simple keyword matching
                if (lower.includes('age')) return { sections: ['methods', 'results'], tables: [1], keywords: ['age'], priority: 'HIGH' };
                if (lower.includes('mortality') || lower.includes('death')) return { sections: ['results'], tables: [4, 5], keywords: ['mortality'], priority: 'HIGH' };
                if (lower.includes('mrs') || lower.includes('rankin')) return { sections: ['results'], tables: [5], keywords: ['mrs'], priority: 'HIGH' };
                if (lower.includes('volume')) return { sections: ['results'], tables: [2], keywords: ['volume'], priority: 'MEDIUM' };

                return null;
            }
        };

        /**
         * SuggestionUIManager - Handles suggestion popup display and interactions
         */
        const SuggestionUIManager = {
            currentPopup: null,
            enabled: true,

            init: function() {
                // Create popup container if not exists
                if (!document.getElementById('suggestion-popup')) {
                    const popup = document.createElement('div');
                    popup.id = 'suggestion-popup';
                    popup.className = 'suggestion-popup hidden';
                    popup.innerHTML = `
                        <div class="suggestion-header">
                            <span class="suggestion-title">üí° Smart Suggestions</span>
                            <button class="suggestion-close" onclick="SuggestionUIManager.hide()">‚úï</button>
                        </div>
                        <div class="suggestion-content"></div>
                        <div class="suggestion-footer">
                            <button class="suggestion-disable" onclick="SuggestionUIManager.toggleEnabled()">Disable for session</button>
                        </div>
                    `;
                    document.body.appendChild(popup);
                }

                // Attach listeners to all form fields
                this.attachFieldListeners();
            },

            attachFieldListeners: function() {
                const fields = document.querySelectorAll('input[type="text"], input[type="number"], textarea, select');
                fields.forEach(field => {
                    field.addEventListener('focus', (e) => this.onFieldFocus(e));
                    field.addEventListener('blur', () => this.hideDelayed());
                });
            },

            onFieldFocus: function(event) {
                if (!this.enabled) return;
                if (!FieldSuggestionEngine.preprocessingData) return;

                const field = event.target;
                const fieldId = field.id;
                const fieldLabel = field.labels?.[0]?.textContent || field.placeholder || fieldId;

                // Don't show if field already has value
                if (field.value && field.value.trim().length > 0) return;

                const suggestions = FieldSuggestionEngine.getSuggestions(fieldId, fieldLabel);

                if (suggestions.length > 0) {
                    this.show(field, fieldLabel, suggestions);
                }
            },

            show: function(field, fieldLabel, suggestions) {
                const popup = document.getElementById('suggestion-popup');
                if (!popup) return;

                // Position popup near field
                const rect = field.getBoundingClientRect();
                popup.style.top = (rect.bottom + window.scrollY + 5) + 'px';
                popup.style.left = rect.left + 'px';

                // Update title
                popup.querySelector('.suggestion-title').textContent = `üí° Suggestions for "${fieldLabel}"`;

                // Render suggestions
                const content = popup.querySelector('.suggestion-content');
                content.innerHTML = suggestions.map((s, i) => `
                    <div class="suggestion-item ${i === 0 ? 'suggestion-top' : ''}" data-page="${s.page}">
                        <div class="suggestion-badge ${s.type.toLowerCase()}">${s.type}</div>
                        <div class="suggestion-info">
                            <div class="suggestion-item-title">${s.title}</div>
                            <div class="suggestion-item-meta">Page ${s.page} ‚Ä¢ ${Math.round(s.relevance * 100)}% match</div>
                        </div>
                        <button class="suggestion-action" onclick="SuggestionUIManager.jumpToPage(${s.page})">
                            Jump to Page ‚Üí
                        </button>
                    </div>
                `).join('');

                popup.classList.remove('hidden');
                this.currentPopup = popup;
            },

            hide: function() {
                const popup = document.getElementById('suggestion-popup');
                if (popup) {
                    popup.classList.add('hidden');
                }
                this.currentPopup = null;
            },

            hideDelayed: function() {
                setTimeout(() => {
                    // Only hide if user didn't click inside popup
                    const popup = document.getElementById('suggestion-popup');
                    if (popup && !popup.matches(':hover')) {
                        this.hide();
                    }
                }, 200);
            },

            jumpToPage: function(pageNum) {
                PDFRenderer.renderPage(pageNum);
                this.hide();
                StatusManager.show(`Jumped to page ${pageNum}`, 'info', 2000);
            },

            toggleEnabled: function() {
                this.enabled = !this.enabled;
                this.hide();
                StatusManager.show(
                    this.enabled ? 'Smart suggestions enabled' : 'Smart suggestions disabled for this session',
                    this.enabled ? 'success' : 'warning',
                    3000
                );
            }
        };

        // Initialize suggestion UI on DOM load
        window.addEventListener('DOMContentLoaded', () => {
            SuggestionUIManager.init();
        });


        // --- PDF Modules ---
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = PDFConfig.workerSrc;

        /**
         * PDFLoader - Handles loading and initializing PDF documents
         * Validates API keys, loads PDF with PDF.js, and initializes the viewer
         */
        const PDFLoader = {
            loadPDF: async (file) => {
                // Validate file input
                if (!file) {
                    StatusManager.show('No file selected', 'error');
                    return;
                }
                
                if (file.type !== 'application/pdf') {
                    StatusManager.show('Please select a valid PDF file', 'error');
                    return;
                }
                
                // Check file size (warn if > 50MB)
                const maxSize = 50 * 1024 * 1024; // 50MB
                if (file.size > maxSize) {
                    if (!confirm(`Large file (${Math.round(file.size / 1024 / 1024)}MB). This may take a while. Continue?`)) {
                        return;
                    }
                }
                
                AppStateManager.setState({ isProcessing: true });
                StatusManager.showLoading(true);
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // Validate AI API key for AI features (non-blocking)
                    const aiApiKey = CONFIG.AI_API_KEY;
                    if (!aiApiKey || aiApiKey === "PASTE_YOUR_AI_API_KEY_HERE") {
                        console.warn("AI API Key not configured. AI features will be disabled.");
                        StatusManager.show("Note: AI features require API key configuration (set in ‚öôÔ∏è Settings)", "warning", 5000);
                    }
                    
                    // Load PDF with PDF.js
                    StatusManager.show('Loading PDF...', 'info');
                    const pdfDoc = await window.pdfjsLib.getDocument({
                        data: arrayBuffer,
                        ...PDFConfig.documentOptions
                    }).promise;
                    
                    const sanitizedName = SecurityUtils.sanitizeText(file.name);

                    AppStateManager.setState({
                        pdfDoc,
                        pdfBlob: file, // Store original file for export
                        totalPages: pdfDoc.numPages,
                        documentName: sanitizedName,
                        isProcessing: false,
                        pdfTextCache: new Map() // Clear cache on new load
                    });

                    document.getElementById('total-pages').textContent = pdfDoc.numPages.toString();
                    document.getElementById('upload-area').style.display = 'none';
                    document.getElementById('pdf-pages').style.display = 'block';

                    StatusManager.showLoading(false);
                    StatusManager.show(`‚úì PDF loaded: ${sanitizedName} (${pdfDoc.numPages} pages)`, 'success');
                    await PDFRenderer.renderPage(1); // Render first page after load

                    // ===== PDF PREPROCESSING =====
                    // Automatically analyze PDF structure (sections, tables, citations)
                    try {
                        const preprocessingResult = await PDFStructureAnalyzer.analyze(
                            pdfDoc,
                            sanitizedName,
                            file.size
                        );

                        // Store preprocessing results in app state
                        AppStateManager.setState({
                            preprocessingData: preprocessingResult
                        });

                        console.log('Preprocessing complete:', preprocessingResult.metadata);

                        // Show summary notification
                        const { sectionCount, tableCount, citationCount } = preprocessingResult.metadata;
                        StatusManager.show(
                            `üìä Document analyzed: ${sectionCount} sections, ${tableCount} tables, ${citationCount} citations`,
                            'success',
                            5000
                        );

                        // Populate sidebar with preprocessing results
                        PreprocessingSidebarManager.populate(preprocessingResult);

                        // Render overlays on first page
                        PreprocessingOverlayRenderer.render(1);

                        // Initialize smart suggestion engine
                        FieldSuggestionEngine.init(preprocessingResult);
                        console.log('Smart Suggestion Engine enabled - focus on form fields to see suggestions');

                    } catch (preprocessingError) {
                        console.error('Preprocessing failed (non-fatal):', preprocessingError);
                        // Don't block PDF usage if preprocessing fails
                        StatusManager.show(
                            '‚ö†Ô∏è Document structure analysis failed (PDF still usable)',
                            'warning',
                            3000
                        );
                    }

                    return pdfDoc;
                } catch (error) {
                    console.error("PDF Load Error:", error);
                    StatusManager.showLoading(false);
                    
                    // Provide user-friendly error messages
                    let errorMessage = 'Failed to load PDF';
                    if (error.message?.includes('password')) {
                        errorMessage = 'PDF is password-protected. Please unlock it first.';
                    } else if (error.message?.includes('Invalid PDF')) {
                        errorMessage = 'Invalid or corrupted PDF file.';
                    } else if (error.name === 'AbortError') {
                        errorMessage = 'PDF loading was cancelled.';
                    } else {
                        errorMessage += `: ${error.message || 'Unknown error'}`;
                    }
                    
                    StatusManager.show(errorMessage, 'error');
                    AppStateManager.setState({ isProcessing: false });
                    throw error;
                }
            }
        };

        const TextSelection = {
            // ============================================================================
            // PHASE 4: NATIVE BROWSER SELECTION API
            // ============================================================================
            enableNativeSelection: (textLayer, pageNum) => {
                // Use native browser selection for better UX
                textLayer.addEventListener('mouseup', (e) => {
                    const state = AppStateManager.getState();
                    
                    // Check if a field is active
                    if (!state.activeField) {
                        StatusManager.show('Please select a form field first', 'warning');
                        window.getSelection().removeAllRanges(); // Clear selection
                        return;
                    }

                    // Get native browser selection
                    const selection = window.getSelection();
                    if (!selection || selection.rangeCount === 0) return;

                    const selectedText = selection.toString().trim();
                    if (!selectedText) return;

                    try {
                        // Get selection boundaries
                        const range = selection.getRangeAt(0);
                        const rects = range.getClientRects();
                        
                        if (rects.length === 0) return;

                        // Get text layer bounding box
                        const textLayerRect = textLayer.getBoundingClientRect();
                        
                        // Calculate bounding box for all selection rectangles
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        
                        for (let i = 0; i < rects.length; i++) {
                            const rect = rects[i];
                            minX = Math.min(minX, rect.left - textLayerRect.left);
                            minY = Math.min(minY, rect.top - textLayerRect.top);
                            maxX = Math.max(maxX, rect.right - textLayerRect.left);
                            maxY = Math.max(maxY, rect.bottom - textLayerRect.top);
                        }

                        const coordinates = {
                            x: Math.round(minX),
                            y: Math.round(minY),
                            width: Math.round(maxX - minX),
                            height: Math.round(maxY - minY)
                        };

                        // Sanitize and extract
                        const sanitizedText = SecurityUtils.sanitizeText(selectedText);
                        
                        const extraction = ExtractionTracker.addExtraction({
                            fieldName: state.activeField,
                            text: sanitizedText,
                            page: pageNum,
                            coordinates: coordinates,
                            method: 'manual',
                            documentName: state.documentName
                        });

                        if (extraction && state.activeFieldElement) {
                            const element = state.activeFieldElement;
                            if (element.type === 'number') {
                                const match = sanitizedText.match(/-?\d+(\.\d+)?/);
                                element.value = match ? match[0] : '';
                            } else {
                                element.value = sanitizedText;
                            }
                            element.classList.add('has-extraction');
                        }

                        if (extraction) {
                            addExtractionMarker(extraction);
                            StatusManager.show(`‚úì Extracted to ${state.activeField}`, 'success');
                            autoAdvanceField();
                            
                            // Visual feedback: mark extracted text
                            const selectedNodes = [];
                            const iterator = document.createNodeIterator(
                                range.commonAncestorContainer,
                                NodeFilter.SHOW_ELEMENT,
                                null
                            );
                            
                            let node;
                            while ((node = iterator.nextNode())) {
                                if (node.classList && node.classList.contains('textLayer') && node.tagName === 'SPAN') {
                                    selectedNodes.push(node);
                                }
                            }
                            
                            selectedNodes.forEach(node => {
                                node.classList.add('extracted');
                            });
                        } else {
                            StatusManager.show(`Extraction failed validation for ${state.activeField}`, 'error');
                        }

                        // Clear selection after extraction
                        selection.removeAllRanges();

                    } catch (error) {
                        console.error('Selection Error:', error);
                        StatusManager.show('Failed to process selection', 'error');
                    }
                });

                // Optional: Double-click to select word
                textLayer.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    // Browser handles word selection automatically
                });
            },
            
            // Keep old method for backwards compatibility (not used anymore)
            enable: (textLayer, textItems, pageNum) => {
                console.warn('TextSelection.enable() is deprecated. Use enableNativeSelection() instead.');
                TextSelection.enableNativeSelection(textLayer, pageNum);
            }
        };

        const PDFRenderer = {
            renderPage: async (pageNum) => {
                 const state = AppStateManager.getState();
                if (!state.pdfDoc || state.isProcessing) return;

                AppStateManager.setState({ isProcessing: true });
                StatusManager.showLoading(true);

                 try {
                    const page = await state.pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: state.scale });
                    const container = document.getElementById('pdf-pages');
                    if (!container) return;
                    container.innerHTML = ''; // Clear previous page

                    const pageDiv = document.createElement('div');
                    pageDiv.className = 'pdf-page';
                    pageDiv.id = `pdf-page-${pageNum}`;  // Add ID for overlay rendering
                    pageDiv.style.position = 'relative';  // For absolute positioning of overlays
                    pageDiv.style.width = viewport.width + 'px';
                    pageDiv.style.height = viewport.height + 'px';

                    // ============================================================================
                    // PHASE 2: HIGH-DPI CANVAS RENDERING
                    // ============================================================================
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    
                    // Support high-DPI displays (Retina, 4K, etc.)
                    const outputScale = window.devicePixelRatio || 1;
                    canvas.width = Math.floor(viewport.width * outputScale);
                    canvas.height = Math.floor(viewport.height * outputScale);
                    canvas.style.width = Math.floor(viewport.width) + 'px';
                    canvas.style.height = Math.floor(viewport.height) + 'px';

                    // Apply transform for high-DPI rendering
                    const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;

                    await page.render({
                        canvasContext: context,
                        viewport: viewport,
                        transform: transform
                    }).promise;
                    pageDiv.appendChild(canvas);

                    // Create highlight layer for annotations
                    const highlightLayer = document.createElement('div');
                    highlightLayer.id = 'highlight-layer';
                    highlightLayer.className = 'highlight-layer';
                    highlightLayer.style.position = 'absolute';
                    highlightLayer.style.left = '0';
                    highlightLayer.style.top = '0';
                    highlightLayer.style.width = viewport.width + 'px';
                    highlightLayer.style.height = viewport.height + 'px';
                    highlightLayer.style.pointerEvents = 'none';
                    pageDiv.appendChild(highlightLayer);

                    // ============================================================================
                    // PHASE 3 & 4: USE PDF.JS TEXT LAYER + NATIVE SELECTION API
                    // ============================================================================
                    const textContent = await page.getTextContent();
                    const textLayerDiv = document.createElement('div');
                    textLayerDiv.className = 'textLayer';
                    textLayerDiv.style.width = viewport.width + 'px';
                    textLayerDiv.style.height = viewport.height + 'px';

                    // Use PDF.js built-in renderTextLayer for perfect alignment
                    await window.pdfjsLib.renderTextLayer({
                        textContentSource: textContent,
                        container: textLayerDiv,
                        viewport: viewport,
                        textDivs: []
                    }).promise;

                    pageDiv.appendChild(textLayerDiv);

                    // Enable native browser selection with extraction on mouseup
                    TextSelection.enableNativeSelection(textLayerDiv, pageNum);
                    
                    addExtractionMarkersForPage(pageNum); // Use global helper
                    container.appendChild(pageDiv);

                    AppStateManager.setState({ currentPage: pageNum });
                    document.getElementById('page-num').value = pageNum.toString();
                    clearSearchMarkers(); // Use global helper

                    // Render preprocessing overlays for this page
                    PreprocessingOverlayRenderer.render(pageNum);

                 } catch (error) {
                    console.error("PDF Render Error:", error);
                    StatusManager.show(`Failed to render page ${pageNum}: ${error.message || 'Unknown error'}`, 'error');
                } finally {
                    // Render annotations for this page
                    PDFAnnotationManager.renderCurrentPageAnnotations();
                    
                    AppStateManager.setState({ isProcessing: false });
                    StatusManager.showLoading(false);
                }
            }
        };

        // Expose PDFRenderer globally for sidebar navigation
        window.PDFRenderer = PDFRenderer;

        // --- Extraction Tracker ---
        const ExtractionTracker = {
            extractions: [],
            fieldMap: new Map(),
            init: function() {
                this.loadFromStorage();
            },
            addExtraction: function(data) {
                 const sanitizedData = {
                    ...data,
                    text: SecurityUtils.sanitizeText(data.text),
                    fieldName: SecurityUtils.sanitizeText(data.fieldName),
                    documentName: SecurityUtils.sanitizeText(data.documentName)
                };
                 const validationData = { ...sanitizedData, id: 'temp', timestamp: new Date().toISOString() };

                 if (!SecurityUtils.validateExtraction(validationData)) {
                    console.error('Invalid extraction data:', validationData);
                    return null;
                }


                const extraction = {
                    id: `ext_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    timestamp: new Date().toISOString(),
                    ...sanitizedData
                };
                this.extractions.push(extraction);
                this.fieldMap.set(data.fieldName, extraction);
                this.updateTraceLog(extraction);
                this.updateStats();
                this.saveToStorage();
                AppStateManager.setState({ extractions: this.extractions }); // Update global state
                return extraction;
            },
            updateTraceLog: function(extraction) {
                 const logContainer = document.getElementById('trace-log');
                 if (!logContainer) return;
                const entry = document.createElement('div');
                entry.className = 'trace-entry';
                entry.dataset.extractionId = extraction.id;
                entry.dataset.method = extraction.method; // For styling
                
                // Check if this is an image extraction
                if (extraction.method === 'image' && extraction.imageData) {
                    entry.innerHTML = `
                        <span class="field-label">üì∑ ${SecurityUtils.escapeHtml(extraction.fieldName)}</span>
                        <span class="extracted-text">"${SecurityUtils.escapeHtml(extraction.text)}"</span>
                        <img src="${extraction.imageData}" class="image-thumbnail" alt="Extracted image" 
                             onclick="event.stopPropagation(); window.open(this.src, '_blank')" 
                             title="Click to view full size">
                        <div class="metadata">
                            Page ${extraction.page} | ${extraction.method} | ${new Date(extraction.timestamp).toLocaleTimeString()}
                        </div>`;
                } else {
                    // Regular text extraction
                    const truncatedText = extraction.text.length > 80 ? extraction.text.substring(0, 80) + '...' : extraction.text;
                    entry.innerHTML = `
                        <span class="field-label">${SecurityUtils.escapeHtml(extraction.fieldName)}</span>
                        <span class="extracted-text">"${SecurityUtils.escapeHtml(truncatedText)}"</span>
                        <div class="metadata">
                            Page ${extraction.page} | ${extraction.method} | ${new Date(extraction.timestamp).toLocaleTimeString()}
                        </div>`;
                }
                
                 entry.onclick = () => this.navigateToExtraction(extraction);
                logContainer.insertBefore(entry, logContainer.firstChild);
            },
             navigateToExtraction: function(extraction) {
                // AI extractions don't have coordinates, just show text
                if (extraction.method !== 'manual') {
                    StatusManager.show(`AI Extraction: ${extraction.text}`, 'info', 5000);
                    return;
                }
                const state = AppStateManager.getState();
                if (extraction.page !== state.currentPage) {
                    PDFRenderer.renderPage(extraction.page);
                }
                // Add highlight effect after delay
                setTimeout(() => {
                    const marker = document.querySelector(`.extraction-marker[data-extraction-id="${extraction.id}"]`);
                    if (marker) {
                        marker.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        marker.style.background = 'rgba(255, 193, 7, 0.5)';
                        setTimeout(() => { marker.style.background = ''; }, 1000);
                    }
                }, 500);
            },
            updateStats: function() {
                document.getElementById('extraction-count').textContent = this.extractions.length;
                const uniquePages = new Set(this.extractions.map(e => e.page));
                document.getElementById('pages-with-data').textContent = uniquePages.size;
            },
            saveToStorage: function() {
                try {
                    localStorage.setItem('clinical_extractions_simple', JSON.stringify(this.extractions));
                } catch (e) { console.error("Save failed", e); }
            },
            loadFromStorage: function() {
                try {
                    const saved = localStorage.getItem('clinical_extractions_simple');
                    if (saved) {
                        this.extractions = JSON.parse(saved);
                        this.extractions.forEach(ext => {
                            this.fieldMap.set(ext.fieldName, ext);
                            this.updateTraceLog(ext); // Populate log on load
                        });
                        this.updateStats();
                        AppStateManager.setState({ extractions: this.extractions }); // Update global state
                    }
                } catch (e) { console.error("Load failed", e); this.extractions = []; }
            },
             getExtractions: function() { return this.extractions; } // Add getter
        };
        ExtractionTracker.init(); // Load saved data


        // --- Form Management ---
        const FormManager = {
            validator: SecurityUtils, // Use SecurityUtils directly for validation
            initialize: function() {
                this.initializeFormFields();
                this.initializeNavigation();
                DynamicFields.initialize(); // Initialize dynamic fields
                this.showStep(0);
            },
             initializeFormFields: function() {
                const inputs = document.querySelectorAll('.linked-input');
                inputs.forEach(input => {
                    // Use MemoryManager if available, otherwise basic listeners
                    const manager = window.MemoryManager || MemoryManager;
                    manager.registerEventListener(input, 'focus', () => {
                        document.querySelectorAll('.form-group').forEach(g => g.classList.remove('active-extraction'));
                        const fieldName = input.name || input.id;
                        AppStateManager.setState({ activeField: fieldName, activeFieldElement: input });
                        input.closest('.form-group')?.classList.add('active-extraction');
                        document.getElementById('active-field-indicator').textContent = `Extracting: ${fieldName}`;
                        document.getElementById('active-field-indicator').style.background = '#4CAF50';
                    });
                     manager.registerEventListener(input, 'blur', () => {
                        this.validateFieldUIUpdate(input);
                    });
                });
            },
            validateFieldUIUpdate: function(input) {
                const result = this.validator.validateInput(input);
                input.classList.toggle('validation-error', !result.valid);
                const messageEl = input.nextElementSibling;
                if (messageEl && messageEl.classList.contains('validation-message')) {
                    messageEl.textContent = result.valid ? '' : result.message;
                    messageEl.style.display = result.valid ? 'none' : 'block';
                }
                return result.valid;
            },
            initializeNavigation: function() {
                 document.getElementById('prev-btn').onclick = () => this.previousStep();
                 document.getElementById('next-btn').onclick = () => this.nextStep();
                 document.getElementById('submit-gsheets-btn').onclick = (e) => handleSubmitToGoogleSheets(e);
            },
            showStep: function(stepIndex) {
                 const steps = document.querySelectorAll('.step');
                 const state = AppStateManager.getState();
                 steps.forEach((step, index) => step.classList.toggle('active', index === stepIndex));
                 document.getElementById('prev-btn').disabled = (stepIndex === 0);
                 document.getElementById('step-indicator').textContent = `Step ${stepIndex + 1} of ${state.totalSteps}`;
                 const isLastStep = stepIndex === state.totalSteps - 1;
                 document.getElementById('next-btn').style.display = isLastStep ? 'none' : 'inline-block';
                 document.getElementById('submit-btn-group').style.display = isLastStep ? 'flex' : 'none';
                 document.querySelector('.form-panel').scrollTop = 0;
                 // Update progress bar
                 const progressBar = document.getElementById('progress-bar');
                 if (progressBar) {
                    const progress = ((stepIndex + 1) / state.totalSteps) * 100;
                    progressBar.style.width = progress + '%';
                 }
                 // Re-initialize fields in case dynamic ones were added
                 this.initializeFormFields();
                  // Update arm selectors if on relevant steps
                  if (stepIndex >= 6 && window.updateArmSelectors) {
                    window.updateArmSelectors();
                  }
            },
            nextStep: function() {
                 const state = AppStateManager.getState();
                
                 // --- VALIDATION LOGIC REMOVED ---
                 /*
                 const currentStepElement = document.getElementById(`step-${state.currentStep + 1}`);
                 let isValid = true;
                 currentStepElement.querySelectorAll('[required]').forEach(input => {
                    if (!input.value) {
                        isValid = false;
                        input.style.borderColor = 'red';
                    } else {
                        input.style.borderColor = ''; // Reset border color
                    }
                 });
                  // Also validate fields with data-validation
                  currentStepElement.querySelectorAll('[data-validation]').forEach(input => {
                      if (!this.validateFieldUIUpdate(input)) {
                          isValid = false;
                      }
                  });


                 if (!isValid) {
                    StatusManager.show('Please fill required fields and correct errors.', 'warning');
                    return;
                 }
                 */
                // --- END OF VALIDATION LOGIC ---


                // Check inclusion criteria on step 2 (this is a soft check, so it's fine to keep)
                if (state.currentStep === 1) {
                    const inclusionMet = document.getElementById('inclusion-met').value;
                    if (inclusionMet === 'false') {
                         // Use a simple confirm for preview, replace with modal in full app
                        if (!confirm('Study does not meet inclusion criteria according to your selection. Continue extraction anyway?')) {
                            return; // Stop navigation
                        }
                    }
                }

                if (state.currentStep < state.totalSteps - 1) {
                    const newStep = state.currentStep + 1;
                    AppStateManager.setState({ currentStep: newStep });
                    this.showStep(newStep);
                }
            },
            previousStep: function() {
                const state = AppStateManager.getState();
                if (state.currentStep > 0) {
                     const newStep = state.currentStep - 1;
                    AppStateManager.setState({ currentStep: newStep });
                    this.showStep(newStep);
                }
            },
             validateAllSteps: function() {
                let allValid = true;
                const steps = document.querySelectorAll('.step');
                steps.forEach((step, index) => {
                    step.querySelectorAll('[required], [data-validation]').forEach(input => {
                        if (!this.validateFieldUIUpdate(input)) {
                            allValid = false;
                        }
                    });
                });
                if (!allValid) {
                     StatusManager.show('Please correct errors on all steps before submitting.', 'warning');
                }
                return allValid;
             },
            collectFormData: function() {
                const formData = {};
                document.querySelectorAll('#extraction-form input, #extraction-form textarea, #extraction-form select').forEach(input => {
                    if (input.value) formData[input.name || input.id] = input.value;
                });
                return formData;
            }
        };

        // --- Dynamic Fields ---
        // Simplified dynamic fields logic for preview
        const DynamicFields = {
            counters: { indication: 0, intervention: 0, arm: 0, mortality: 0, mrs: 0, complication: 0, predictor: 0 },
            initialize: function() {
                 // Expose functions globally for HTML onclick
                 window.addIndication = () => this.addIndication();
                 window.addIntervention = () => this.addIntervention();
                 window.addArm = () => this.addArm();
                 window.addMortality = () => this.addMortality();
                 window.addMRS = () => this.addMRS();
                 window.addComplication = () => this.addComplication();
                 window.addPredictor = () => this.addPredictor();
                 window.removeElement = (btn) => this.removeElement(btn);
                 window.updateArmSelectors = () => this.updateArmSelectors(); // Ensure this is also global
            },
            addField: function(type, containerId) {
                 const container = document.getElementById(containerId);
                 if (!container) return;
                 const count = this.counters[type]++;
                 const div = document.createElement('div');
                 div.className = 'dynamic-container';
                 let htmlContent = '';

                 switch (type) {
                    case 'indication':
                        htmlContent = `
                            <h4>Indication ${count + 1}</h4>
                            <div class="grid-2col">
                                <div class="form-group">
                                    <label>Sign/Symptom</label>
                                    <select name="indication_sign_${count}" class="linked-input">
                                        <option value="">Select...</option>
                                        <option value="Drowsiness">Drowsiness</option>
                                        <option value="GCS_Drop">Drop in GCS</option>
                                        <option value="Imaging_Mass_Effect">Imaging signs of mass effect</option>
                                        <option value="Other">Other</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Count (N)</label>
                                    <input type="number" name="indication_count_${count}" class="linked-input">
                                </div>
                            </div>`;
                        break;
                    case 'intervention':
                        htmlContent = `
                            <h4>Intervention Type ${count + 1}</h4>
                            <div class="form-group"><label>Surgical Type</label><select name="intervention_type_${count}" class="linked-input"><option value="">Select...</option><option value="SDC_EVD">SDC + EVD</option><option value="SDC_ALONE">SDC Alone</option><option value="EVD_ALONE">EVD Alone</option></select></div>
                            <div class="form-group"><label>Time To Surgery (Hours)</label><input type="number" step="0.1" name="intervention_time_${count}" class="linked-input"></div>
                            <div class="form-group"><label>Duraplasty?</label><select name="intervention_duraplasty_${count}" class="linked-input"><option value="null">Unknown</option><option value="true">Yes</option><option value="false">No</option></select></div>`;
                        break;
                    case 'arm':
                        htmlContent = `
                            <h3>Study Arm ${count + 1}</h3>
                            <div class="grid-2col">
                                <div class="form-group"><label>Label</label><input type="text" name="arm_label_${count}" class="linked-input arm-label-input" oninput="updateArmSelectors()"></div>
                                <div class="form-group"><label>Sample Size (N)</label><input type="number" name="arm_n_${count}" class="linked-input"></div>
                            </div>`;
                        break;
                    case 'mortality':
                        htmlContent = `
                            <h4>Mortality Data Point ${count + 1}</h4>
                            <div class="grid-2col">
                                <div class="form-group"><label>Arm</label><select name="mortality_arm_${count}" class="arm-selector linked-input"></select></div>
                                <div class="form-group"><label>Timepoint</label><input type="text" name="mortality_tp_${count}" class="linked-input"></div>
                            </div>
                            <div class="grid-2col">
                                <div class="form-group"><label>Deaths (N)</label><input type="number" name="mortality_deaths_${count}" class="linked-input"></div>
                                <div class="form-group"><label>Total (N)</label><input type="number" name="mortality_total_${count}" class="linked-input"></div>
                            </div>`;
                        break;
                    case 'mrs':
                        htmlContent = `
                            <h4>mRS Data Point ${count + 1}</h4>
                            <div class="grid-2col">
                                <div class="form-group"><label>Arm</label><select name="mrs_arm_${count}" class="arm-selector linked-input"></select></div>
                                <div class="form-group"><label>Timepoint</label><input type="text" name="mrs_tp_${count}" class="linked-input"></div>
                            </div>
                            <h5>Distribution (Counts)</h5>
                            <div class="grid-mrs">
                                ${[0,1,2,3,4,5,6].map(i => `<div class="form-group"><label>${i}</label><input type="number" name="mrs_${i}_${count}" class="linked-input"></div>`).join('')}
                            </div>`;
                        break;
                    case 'complication':
                         htmlContent = `
                            <h4>Complication ${count + 1}</h4>
                            <div class="grid-2col">
                                <div class="form-group"><label>Description</label><input type="text" name="comp_desc_${count}" class="linked-input"></div>
                                <div class="form-group"><label>Arm</label><select name="comp_arm_${count}" class="arm-selector linked-input"></select></div>
                            </div>
                            <div class="form-group"><label>Count (N)</label><input type="number" name="comp_count_${count}" class="linked-input"></div>`;
                        break;
                    case 'predictor':
                         htmlContent = `
                            <h4>Predictor Analysis ${count + 1}</h4>
                            <div class="form-group"><label>Predictor Variable</label><input type="text" name="pred_var_${count}" class="linked-input"></div>
                            <div class="grid-3col">
                                <div class="form-group"><label>Effect Size (OR/HR)</label><input type="number" step="0.01" name="pred_effect_${count}" class="linked-input"></div>
                                <div class="form-group"><label>95% CI (Lower)</label><input type="number" step="0.01" name="pred_ci_lower_${count}" class="linked-input"></div>
                                <div class="form-group"><label>95% CI (Upper)</label><input type="number" step="0.01" name="pred_ci_upper_${count}" class="linked-input"></div>
                            </div>
                            <div class="form-group"><label>p-Value</label><input type="number" step="0.001" name="pred_pvalue_${count}" class="linked-input"></div>`;
                        break;
                }

                htmlContent += `<button type="button" class="remove-btn" onclick="removeElement(this)">Remove</button>`;
                div.innerHTML = htmlContent;

                 container.appendChild(div);
                 FormManager.initializeFormFields(); // Re-bind listeners for new fields
                 if (type === 'arm') this.updateArmSelectors(); // Update selectors if an arm was added
                 if (type === 'mortality' || type === 'mrs' || type === 'complication') this.updateArmSelectors(); // Update selectors for fields that use arms
            },
             addIndication: function() { this.addField('indication', 'indications-container'); },
             addIntervention: function() { this.addField('intervention', 'interventions-container'); },
             addArm: function() { this.addField('arm', 'arms-container'); },
             addMortality: function() { this.addField('mortality', 'mortality-global-container'); },
             addMRS: function() { this.addField('mrs', 'mrs-global-container'); },
             addComplication: function() { this.addField('complication', 'complications-container'); },
             addPredictor: function() { this.addField('predictor', 'predictors-container'); },
             removeElement: function(button) {
                button.closest('.dynamic-container')?.remove();
                this.updateArmSelectors();
            },
             updateArmSelectors: function() {
                const armLabels = Array.from(document.querySelectorAll('.arm-label-input'))
                    .map(input => input.value.trim())
                    .filter(Boolean);

                document.querySelectorAll('.arm-selector').forEach(select => {
                    const currentValue = select.value;
                    select.innerHTML = '<option value="">Select Arm...</option>'; // Clear existing options
                    armLabels.forEach(label => {
                        const option = new Option(label, label);
                        select.add(option);
                    });
                    // Try to reselect the previous value if it still exists
                    if (armLabels.includes(currentValue)) {
                        select.value = currentValue;
                    }
                });
            }
        };

        // --- Export Manager ---
        const ExportManager = {
            exportJSON: function() {
                const state = AppStateManager.getState();
                const formData = FormManager.collectFormData();
                const data = { document: state.documentName, exportDate: new Date().toISOString(), formData, extractions: ExtractionTracker.getExtractions() };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                this.downloadFile(blob, `extraction_${Date.now()}.json`);
                StatusManager.show('JSON export successful (Preview)', 'success');
            },
            exportCSV: function() {
                let csv = 'Field,Text,Page,X,Y,Width,Height,Timestamp\n';
                ExtractionTracker.getExtractions().forEach(ext => {
                     csv += `"${ext.fieldName}","${ext.text.replace(/"/g, '""')}",${ext.page},${ext.coordinates.x},${ext.coordinates.y},${ext.coordinates.width},${ext.coordinates.height},"${ext.timestamp}"\n`;
                });
                const blob = new Blob([csv], { type: 'text/csv' });
                this.downloadFile(blob, `extraction_${Date.now()}.csv`);
                StatusManager.show('CSV export successful (Preview)', 'success');
            },
            exportAudit: function() {
                 const formData = FormManager.collectFormData();
                 // Generate simplified HTML locally for preview
                 const state = AppStateManager.getState();
                 const extractions = ExtractionTracker.getExtractions();
                 let html = `<h1>Audit Report</h1><h2>Document: ${state.documentName}</h2><h3>Form Data</h3><ul>`;
                 Object.entries(formData).forEach(([key, value]) => html += `<li><b>${key}:</b> ${value}</li>`);
                 html += `</ul><h3>Extractions</h3>`;
                 extractions.forEach(ext => html += `<p><b>${ext.fieldName} (Page ${ext.page}):</b> "${ext.text}" <i>@ ${ext.timestamp}</i></p>`);
                 const blob = new Blob([html], { type: 'text/html' });
                 const url = URL.createObjectURL(blob);
                 window.open(url, '_blank');
                 setTimeout(() => URL.revokeObjectURL(url), 1000); // Clean up blob URL
                 StatusManager.show('Audit report generated (Preview)', 'success');
            },
             downloadFile: function(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a); // Required for Firefox
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(url), 1000); // Clean up blob URL
            }
        };

        // --- GEMINI API FUNCTIONS ---

        /**
         * Normalizes text for processing.
         * @param {string} text - The input text.
         * @returns {string} - The normalized text.
         */
        function normalizeText(text) {
            if (!text) return '';
            return text
                .replace(/\s+/g, ' ')
                .replace(/[\n\r]/g, ' ')
                .replace(/["\"]+/g, '"')
                .replace(/[\''\']+/g, "'")
                .trim()
                .toLowerCase();
        }

        /**
         * Gets text content from a specific PDF page, using cache if available.
         * @param {number} pageNum - The page number.
         * @returns {Promise<{fullText: string, items: Array<any>}>}
         */
        async function getPageText(pageNum) {
            const state = AppStateManager.getState();
            if (state.pdfTextCache.has(pageNum)) {
                return state.pdfTextCache.get(pageNum);
            }
            if (!state.pdfDoc) {
                throw new Error('No PDF loaded');
            }
            try {
                const page = await state.pdfDoc.getPage(pageNum);
                const textContent = await page.getTextContent();
                let fullText = '';
                const items = [];
                textContent.items.forEach(item => {
                    if (item.str) {
                        fullText += item.str + ' ';
                        items.push({ text: item.str, transform: item.transform });
                    }
                });
                const pageData = { fullText, items };
                // Simple cache management
                if (state.pdfTextCache.size >= state.maxCacheSize) {
                    const firstKey = state.pdfTextCache.keys().next().value;
                    if (firstKey) state.pdfTextCache.delete(firstKey);
                }
                state.pdfTextCache.set(pageNum, pageData);
                return pageData;
            } catch (error) {
                console.error(`Error getting text from page ${pageNum}:`, error);
                return { fullText: '', items: [] };
            }
        }
         
        /**
         * Calls the Gemini API with Google Search grounding.
         * @param {string} systemPrompt - The system instruction.
         * @param {string} userPrompt - The user query.
         * @param {object} jsonSchema - The JSON schema for the response.
         * @returns {Promise<string>} - The text content from the API response.
         */
        async function callGeminiWithSearch(systemPrompt, userPrompt, jsonSchema) {
            const apiKey = CONFIG.AI_API_KEY;
            if (!apiKey) {
                throw new Error("AI API Key is missing in CONFIG.AI_API_KEY");
            }

            // Strategy 1: Try Gemini 2.5 Flash with modern google_search tool
            try {
                console.log("üîç Attempting: Gemini 2.5 Flash + google_search (modern)");
                StatusManager.show('Trying Gemini 2.5 Flash with Search...', 'info');

                const result = await tryGeminiSearchAPI({
                    apiKey,
                    model: 'gemini-2.5-flash',
                    systemPrompt,
                    userPrompt,
                    jsonSchema,
                    searchTool: { "google_search": {} }, // Modern syntax
                    useSchema: true
                });

                console.log("‚úÖ Success with Gemini 2.5 Flash + google_search");
                return result;

            } catch (error1) {
                console.warn("‚ùå Gemini 2.5 Flash + google_search failed:", error1.message);

                // Strategy 2: Try Gemini 2.0 Flash with google_search (alternative modern model)
                try {
                    console.log("üîç Attempting: Gemini 2.0 Flash + google_search (alternative)");
                    StatusManager.show('Retrying with Gemini 2.0 Flash...', 'info');

                    const result = await tryGeminiSearchAPI({
                        apiKey,
                        model: 'gemini-2.0-flash',
                        systemPrompt,
                        userPrompt,
                        jsonSchema,
                        searchTool: { "google_search": {} }, // Modern syntax
                        useSchema: true
                    });

                    console.log("‚úÖ Success with Gemini 2.0 Flash + google_search");
                    return result;

                } catch (error2) {
                    console.warn("‚ùå Gemini 2.0 Flash + google_search failed:", error2.message);

                    // Strategy 3: Try Gemini 2.5 Flash without Search (fallback)
                    try {
                        console.log("üîç Attempting: Gemini 2.5 Flash WITHOUT search (schema only)");
                        StatusManager.show('Retrying without Search...', 'info');

                        const result = await tryGeminiSearchAPI({
                            apiKey,
                            model: 'gemini-2.5-flash',
                            systemPrompt,
                            userPrompt,
                            jsonSchema,
                            searchTool: null, // No search
                            useSchema: true
                        });

                        console.log("‚úÖ Success with Gemini 2.5 Flash (no search)");
                        return result;

                    } catch (error3) {
                        console.error("‚ùå All strategies failed:", { error1, error2, error3 });
                        throw new Error(`All citation search methods failed. Last error: ${error3.message}`);
                    }
                }
            }
        }

        /**
         * Helper function to try a specific Gemini API configuration
         */
        async function tryGeminiSearchAPI({ apiKey, model, systemPrompt, userPrompt, jsonSchema, searchTool, useSchema }) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };

            // Add search tool if provided
            if (searchTool) {
                payload.tools = [searchTool];
            }

            // Add JSON schema if requested
            if (useSchema && jsonSchema) {
                payload.generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: jsonSchema
                };
            }

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                const errorMsg = errorBody.error?.message || response.statusText;
                console.error(`API Error ${response.status}:`, errorBody);
                throw new Error(`${response.status}: ${errorMsg}`);
            }

            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (text) {
                // Log grounding metadata if available
                const metadata = result.candidates?.[0]?.groundingMetadata;
                if (metadata) {
                    console.log("üîç Grounding metadata:", metadata);
                }
                return text;
            } else {
                throw new Error("No text returned from Gemini API");
            }
        }


        /**
         * ‚ú® Generates PICO-T summary using multi-provider AI support with PDF text.
         */
        async function generatePICO() {
            const state = AppStateManager.getState();
            if (!state.pdfDoc) {
                StatusManager.show('Please load a PDF first.', 'warning');
                return;
            }
            if (state.isProcessing) {
                StatusManager.show('Please wait for the current operation to finish.', 'warning');
                return;
            }

            AppStateManager.setState({ isProcessing: true });
            document.getElementById('pico-loading').style.display = 'block';
            
            const provider = AppState.aiProvider || 'gemini';
            StatusManager.show(`‚ú® Extracting PDF text and generating PICO-T with ${AIProviders[provider].name}...`, 'info');

            try {
                // Extract text from first 5 pages (usually contains methods/intro)
                let pdfText = '';
                const pagesToExtract = Math.min(5, state.totalPages);
                
                for (let i = 1; i <= pagesToExtract; i++) {
                    const pageData = await getPageText(i);
                    pdfText += pageData.fullText + '\n';
                }

                const systemPrompt = "You are an expert clinical research assistant. Extract PICO-T information from the provided clinical study text and return it as a JSON object. Be concise and accurate. If information is not found, return an empty string for that field.";
                const userPrompt = `From the following clinical study text, extract PICO-T information:\n\n${pdfText.substring(0, 30000)}\n\nRespond with JSON containing: population, intervention, comparator, outcomes, timing, studyType`;
                
                const picoSchema = {
                    type: "OBJECT",
                    properties: {
                        "population": { "type": "STRING", "description": "The study population" },
                        "intervention": { "type": "STRING", "description": "The intervention performed" },
                        "comparator": { "type": "STRING", "description": "The comparison group" },
                        "outcomes": { "type": "STRING", "description": "The primary outcomes measured" },
                        "timing": { "type": "STRING", "description": "The follow-up timing" },
                        "studyType": { "type": "STRING", "description": "The type of study" }
                    }
                };

                // Use multi-provider AI call
                const responseText = await AIProviders.callAI(systemPrompt, userPrompt, picoSchema);
                const data = JSON.parse(responseText);

                // Populate fields
                document.getElementById('eligibility-population').value = data.population || '';
                document.getElementById('eligibility-intervention').value = data.intervention || '';
                document.getElementById('eligibility-comparator').value = data.comparator || '';
                document.getElementById('eligibility-outcomes').value = data.outcomes || '';
                document.getElementById('eligibility-timing').value = data.timing || '';
                document.getElementById('eligibility-type').value = data.studyType || '';
                 
                // Add to trace log
                const coords = { x: 0, y: 0, width: 0, height: 0 };
                const method = `${provider}-pico`;
                if (data.population) ExtractionTracker.addExtraction({ fieldName: 'population (AI)', text: data.population, page: 0, coordinates: coords, method, documentName: state.documentName });
                if (data.intervention) ExtractionTracker.addExtraction({ fieldName: 'intervention (AI)', text: data.intervention, page: 0, coordinates: coords, method, documentName: state.documentName });
                if (data.comparator) ExtractionTracker.addExtraction({ fieldName: 'comparator (AI)', text: data.comparator, page: 0, coordinates: coords, method, documentName: state.documentName });
                if (data.outcomes) ExtractionTracker.addExtraction({ fieldName: 'outcomes (AI)', text: data.outcomes, page: 0, coordinates: coords, method, documentName: state.documentName });
                if (data.timing) ExtractionTracker.addExtraction({ fieldName: 'timing (AI)', text: data.timing, page: 0, coordinates: coords, method, documentName: state.documentName });
                if (data.studyType) ExtractionTracker.addExtraction({ fieldName: 'studyType (AI)', text: data.studyType, page: 0, coordinates: coords, method, documentName: state.documentName });

                StatusManager.show(`‚ú® PICO-T fields auto-populated by ${AIProviders[provider].name}!`, 'success');

            } catch (error) {
                console.error("AI PICO-T Error:", error);
                StatusManager.show(`AI extraction failed: ${error.message}`, 'error');
            } finally {
                AppStateManager.setState({ isProcessing: false });
                document.getElementById('pico-loading').style.display = 'none';
            }
        }
         
        /**
         * ‚ú® Generates a summary of key findings using multi-provider AI support with PDF text.
         */
        async function generateSummary() {
            const state = AppStateManager.getState();
            if (!state.pdfDoc) {
                StatusManager.show('Please load a PDF first.', 'warning');
                return;
            }
            if (state.isProcessing) {
                StatusManager.show('Please wait for the current operation to finish.', 'warning');
                return;
            }

            AppStateManager.setState({ isProcessing: true });
            document.getElementById('summary-loading').style.display = 'block';
            
            const provider = AppState.aiProvider || 'gemini';
            StatusManager.show(`‚ú® Extracting PDF text and generating summary with ${AIProviders[provider].name}...`, 'info');

            try {
                // Extract text from all pages
                let pdfText = '';
                
                for (let i = 1; i <= state.totalPages; i++) {
                    const pageData = await getPageText(i);
                    pdfText += pageData.fullText + '\n';
                }

                const systemPrompt = "You are an expert clinical research assistant. Your task is to write a concise summary (2-3 paragraphs) focusing on the key findings, outcomes, and any identified predictors of those outcomes from the provided clinical study text.";
                const userPrompt = `Summarize the key findings, outcomes, and predictors from this clinical study:\n\n${pdfText.substring(0, 50000)}`; // Limit text length
                
                // Use multi-provider AI call
                const summaryText = await AIProviders.callAI(systemPrompt, userPrompt);
                 
                if (!summaryText) {
                    throw new Error("No response from AI provider");
                }
                 
                document.getElementById('predictorsPoorOutcomeSurgical').value = summaryText;
                 
                // Add to trace log with provider-specific method
                const method = `${provider}-summary`;
                ExtractionTracker.addExtraction({ 
                    fieldName: 'summary (AI)', 
                    text: summaryText, 
                    page: 0, 
                    coordinates: {x:0, y:0, width:0, height:0}, 
                    method: method, 
                    documentName: state.documentName 
                });
                 
                StatusManager.show(`‚ú® Key findings summary generated by ${AIProviders[provider].name}!`, 'success');

            } catch (error) {
                console.error("AI Summary Error:", error);
                StatusManager.show(`AI summary failed: ${error.message}`, 'error');
            } finally {
                AppStateManager.setState({ isProcessing: false });
                document.getElementById('summary-loading').style.display = 'none';
            }
        }

        /**
         * ‚ú® Validates a field's content against the PDF text using multi-provider AI support.
         */
        async function validateFieldWithAI(fieldId) {
            const state = AppStateManager.getState();
            const field = document.getElementById(fieldId);
            if (!field) {
                StatusManager.show(`Field ${fieldId} not found.`, 'error');
                return;
            }
             
            const claim = field.value;
            if (!claim) {
                StatusManager.show('Field is empty, nothing to validate.', 'warning');
                return;
            }

            if (!state.pdfDoc) {
                StatusManager.show('Please load a PDF first.', 'warning');
                return;
            }
            if (state.isProcessing) {
                StatusManager.show('Please wait for the current operation to finish.', 'warning');
                return;
            }
             
            AppStateManager.setState({ isProcessing: true });
            StatusManager.showLoading(true);
            
            const provider = AppState.aiProvider || 'gemini';
            StatusManager.show(`‚ú® Validating claim with ${AIProviders[provider].name}: "${claim.substring(0, 30)}..."`, 'info');

            try {
                // Extract text from all pages
                let pdfText = '';
                
                for (let i = 1; i <= state.totalPages; i++) {
                    const pageData = await getPageText(i);
                    pdfText += pageData.fullText + '\n';
                }

                const systemPrompt = "You are an expert fact-checker for clinical research. Validate if a claim is supported by the provided text. Return a JSON response indicating if the claim is supported, the confidence level, and a direct supporting quote if found.";
                const userPrompt = `Clinical study text:\n${pdfText.substring(0, 50000)}\n\nClaim to validate: "${claim}"\n\nIs this claim supported by the text above? Provide a supporting quote if yes.`;
                
                const validationSchema = {
                    type: "OBJECT",
                    properties: {
                        "is_supported": { "type": "BOOLEAN", "description": "Whether the claim is supported by the text" },
                        "confidence_score": { "type": "NUMBER", "description": "Confidence level from 0.0 to 1.0" },
                        "supporting_quote": { "type": "STRING", "description": "Direct quote from text that supports the claim, or empty string if not supported" },
                        "explanation": { "type": "STRING", "description": "Brief explanation of the validation result" }
                    }
                };

                // Use multi-provider AI call
                const responseText = await AIProviders.callAI(systemPrompt, userPrompt, validationSchema);
                const validation = JSON.parse(responseText);

                if (validation.is_supported) {
                    const quote = validation.supporting_quote.substring(0, 100);
                    StatusManager.show(`‚úì VALIDATED by ${AIProviders[provider].name} (${Math.round(validation.confidence_score * 100)}%): "${quote}..."`, 'success', 10000);
                    field.style.borderColor = 'var(--success-green)';
                } else {
                    StatusManager.show(`‚úó NOT SUPPORTED (${Math.round(validation.confidence_score * 100)}%): ${validation.explanation}`, 'warning', 10000);
                    field.style.borderColor = 'var(--warning-orange)';
                }

            } catch (error) {
                console.error("AI Validation Error:", error);
                StatusManager.show(`AI validation failed: ${error.message}`, 'error');
            } finally {
                AppStateManager.setState({ isProcessing: false });
                StatusManager.showLoading(false);
            }
        }
         
        /**
         * ‚ú® Finds study metadata using Gemini with Google Search.
         */
        async function findMetadata() {
            const state = AppStateManager.getState();
            if (state.isProcessing) {
                StatusManager.show('Please wait for the current operation to finish.', 'warning');
                return;
            }
            const citationText = document.getElementById('citation').value;
            if (!citationText) {
                StatusManager.show('Please enter a citation or title first.', 'warning');
                return;
            }
             
            AppStateManager.setState({ isProcessing: true });
            document.getElementById('metadata-loading').style.display = 'block';
            StatusManager.show('‚ú® Searching Google for metadata...', 'info');

            try {
                const systemPrompt = "You are a research assistant. Find the metadata for the given study. Use Google Search to find the information. If a value isn't found, return an empty string for it. Provide only the JSON response.";
                const userPrompt = `Find the DOI, PMID, journal name, and publication year for the following study: "${citationText}"`;
                 
                const metadataSchema = {
                    type: "OBJECT",
                    properties: {
                        "doi": { "type": "STRING", "description": "The DOI of the paper" },
                        "pmid": { "type": "STRING", "description": "The PubMed ID (PMID) of the paper" },
                        "journal": { "type": "STRING", "description": "The name of the journal" },
                        "year": { "type": "STRING", "description": "The 4-digit publication year" }
                    }
                };

                const responseJson = await callGeminiWithSearch(systemPrompt, userPrompt, metadataSchema);
                const data = JSON.parse(responseJson);
                 
                if (data.doi) document.getElementById('doi').value = data.doi;
                if (data.pmid) document.getElementById('pmid').value = data.pmid;
                if (data.journal) document.getElementById('journal').value = data.journal;
                if (data.year) document.getElementById('year').value = data.year;

                StatusManager.show('‚ú® Metadata auto-populated!', 'success');

            } catch (error) {
                console.error("Gemini Metadata Error:", error);
                StatusManager.show(`AI metadata search failed: ${error.message}`, 'error');
            } finally {
                AppStateManager.setState({ isProcessing: false });
                document.getElementById('metadata-loading').style.display = 'none';
            }
        }


        // --- Helper Functions (made global for HTML access) ---
        window.calculateBoundingBox = (items) => {
             let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
             items.forEach(item => {
                if (!item) return; // Skip if item is null/undefined
                const x = item.x ?? parseFloat(item.element?.dataset.x || '0');
                const y = item.y ?? parseFloat(item.element?.dataset.y || '0');
                const width = item.width ?? parseFloat(item.element?.dataset.width || '0');
                const height = item.height ?? parseFloat(item.element?.dataset.height || '0');
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + width);
                maxY = Math.max(maxY, y + height);
            });
            if (!isFinite(minX)) return { x: 0, y: 0, width: 0, height: 0 }; // Handle case with no valid items
            return { x: Math.round(minX), y: Math.round(minY), width: Math.round(maxX - minX), height: Math.round(maxY - minY) };
        };

        window.addExtractionMarker = (extraction) => {
             const pageDiv = document.querySelector('.pdf-page');
            if (!pageDiv || !extraction || !extraction.coordinates) return;
            const marker = document.createElement('div');
            marker.className = 'extraction-marker';
            marker.dataset.extractionId = extraction.id;
            marker.dataset.field = extraction.fieldName;
            marker.dataset.method = extraction.method; // For styling
            marker.style.left = extraction.coordinates.x + 'px';
            marker.style.top = extraction.coordinates.y + 'px';
            marker.style.width = extraction.coordinates.width + 'px';
            marker.style.height = extraction.coordinates.height + 'px';
            pageDiv.appendChild(marker);
        };

        window.addExtractionMarkersForPage = (pageNum) => {
            const pageDiv = document.querySelector('.pdf-page');
            if (!pageDiv) return;
             // Clear existing markers for the page first
             pageDiv.querySelectorAll('.extraction-marker').forEach(m => m.remove());
            // Add markers
            ExtractionTracker.getExtractions()
                .filter(ext => ext.page === pageNum)
                .forEach(ext => addExtractionMarker(ext));
        };

        window.autoAdvanceField = () => {
             const state = AppStateManager.getState();
             const currentStepElement = document.getElementById(`step-${state.currentStep + 1}`);
             if (!currentStepElement || !state.activeFieldElement) return;
             const inputs = Array.from(currentStepElement.querySelectorAll('.linked-input:not([disabled])'));
             const currentIndex = inputs.indexOf(state.activeFieldElement);
             if (currentIndex >= 0 && currentIndex < inputs.length - 1) {
                inputs[currentIndex + 1].focus();
             }
        };

        window.clearSearchMarkers = () => {
            AppState.searchMarkers.forEach(marker => marker.remove());
            AppState.searchMarkers = [];
            document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight'));
        };


        // --- Initialization ---
        FormManager.initialize();

        // Setup PDF Controls
        document.getElementById('pdf-upload-btn').onclick = () => document.getElementById('pdf-file').click();
        document.getElementById('pdf-file').onchange = (e) => PDFLoader.loadPDF(e.target.files[0]);
        document.getElementById('pdf-file-2').onchange = (e) => PDFLoader.loadPDF(e.target.files[0]); // For label click
        document.getElementById('pdf-prev-page').onclick = () => {
            const state = AppStateManager.getState();
            if (state.currentPage > 1) PDFRenderer.renderPage(state.currentPage - 1);
        };
        document.getElementById('pdf-next-page').onclick = () => {
            const state = AppStateManager.getState();
            if (state.currentPage < state.totalPages) PDFRenderer.renderPage(state.currentPage + 1);
        };
         document.getElementById('page-num').onchange = (e) => {
            const pageNum = parseInt(e.target.value);
            const state = AppStateManager.getState();
            if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= state.totalPages) {
                PDFRenderer.renderPage(pageNum);
            } else {
                // Reset input to current page if invalid
                e.target.value = state.currentPage.toString();
            }
        };
        document.getElementById('zoom-level').onchange = (e) => {
            const scale = parseFloat(e.target.value);
            AppStateManager.setState({ scale });
            PDFRenderer.renderPage(AppStateManager.getState().currentPage);
        };
        document.getElementById('fit-width').onclick = async () => {
            const state = AppStateManager.getState();
            if (!state.pdfDoc) return;
            const container = document.getElementById('pdf-container');
            if (!container) return;
            const containerWidth = container.clientWidth - 40; // Account for padding
            try {
                const page = await state.pdfDoc.getPage(state.currentPage);
                const viewport = page.getViewport({ scale: 1.0 });
                const newScale = containerWidth / viewport.width;
                AppStateManager.setState({ scale: newScale });
                document.getElementById('zoom-level').value = newScale.toFixed(2); // Update dropdown
                await PDFRenderer.renderPage(state.currentPage);
            } catch (error) {
                console.error("Fit Width Error:", error);
                StatusManager.show("Could not fit PDF to width.", "error");
            }
        };
         // Drag and Drop for Upload Area
         const uploadArea = document.getElementById('upload-area');
         if (uploadArea) {
            uploadArea.onclick = () => document.getElementById('pdf-file-2').click(); // Make area clickable
            uploadArea.ondragover = (e) => { e.preventDefault(); uploadArea.style.background = '#e3f2fd'; };
            uploadArea.ondragleave = () => { uploadArea.style.background = ''; };
            uploadArea.ondrop = (e) => {
                e.preventDefault();
                uploadArea.style.background = '';
                const file = e.dataTransfer?.files[0];
                if (file && file.type === 'application/pdf') {
                    PDFLoader.loadPDF(file);
                } else {
                    StatusManager.show('Please drop a valid PDF file.', 'warning');
                }
            };
        }


         // Expose simplified ExportManager functions globally
         window.exportJSON = () => ExportManager.exportJSON();
         window.exportCSV = () => ExportManager.exportCSV();
         window.exportAudit = () => ExportManager.exportAudit();
         window.exportAnnotatedPDF = () => PDFAnnotationManager.exportAnnotatedPDF();

         // Expose Search Interface functions globally
         window.toggleSearchInterface = () => {
            document.getElementById('search-interface')?.classList.toggle('active');
        };
         
         /**
          * Full PDF text search with highlighting and navigation
          */
         window.searchInPDF = async () => {
            const query = document.getElementById('search-query').value.trim();
            if (!query) {
                StatusManager.show('Please enter text to search', 'warning');
                return;
            }
            const state = AppStateManager.getState();
            if (!state.pdfDoc) {
                StatusManager.show('Please load a PDF first', 'warning');
                return;
            }
            
            StatusManager.showLoading(true);
            StatusManager.show('Searching across all pages...', 'info');
            clearSearchMarkers();

            try {
                const searchResults = [];
                const normalizedQuery = normalizeText(query);
                
                // Search across all pages and get text coordinates
                for (let pageNum = 1; pageNum <= state.totalPages; pageNum++) {
                    const page = await state.pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const viewport = page.getViewport({ scale: state.scale });
                    
                    let fullText = '';
                    const itemsWithCoords = [];
                    
                    textContent.items.forEach(item => {
                        if (item.str) {
                            const startPos = fullText.length;
                            fullText += item.str + ' ';
                            
                            // Calculate item coordinates
                            const tx = window.pdfjsLib.Util.transform(viewport.transform, item.transform);
                            itemsWithCoords.push({
                                text: item.str,
                                startPos: startPos,
                                endPos: startPos + item.str.length,
                                x: tx[4],
                                y: tx[5],
                                width: item.width * tx[0],
                                height: Math.sqrt((tx[0] * tx[0]) + (tx[1] * tx[1]))
                            });
                        }
                    });
                    
                    const normalizedText = normalizeText(fullText);
                    
                    // Find all occurrences in this page
                    let startIndex = 0;
                    while ((startIndex = normalizedText.indexOf(normalizedQuery, startIndex)) !== -1) {
                        const endIndex = startIndex + normalizedQuery.length;
                        
                        // Get context (50 chars before and after)
                        const contextStart = Math.max(0, startIndex - 50);
                        const contextEnd = Math.min(normalizedText.length, endIndex + 50);
                        const context = fullText.substring(contextStart, contextEnd);
                        
                        // Find text items that overlap with this match
                        const matchingItems = itemsWithCoords.filter(item => {
                            return item.startPos < endIndex && item.endPos > startIndex;
                        });
                        
                        // Calculate bounding box for the match
                        let boundingBox = null;
                        if (matchingItems.length > 0) {
                            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                            matchingItems.forEach(item => {
                                minX = Math.min(minX, item.x);
                                minY = Math.min(minY, item.y);
                                maxX = Math.max(maxX, item.x + item.width);
                                maxY = Math.max(maxY, item.y + item.height);
                            });
                            boundingBox = {
                                x: Math.round(minX),
                                y: Math.round(minY),
                                width: Math.round(maxX - minX),
                                height: Math.round(maxY - minY)
                            };
                        }
                        
                        searchResults.push({
                            page: pageNum,
                            context: context,
                            position: startIndex,
                            boundingBox: boundingBox,
                            matchedText: fullText.substring(startIndex, endIndex)
                        });
                        
                        startIndex += normalizedQuery.length;
                    }
                }
                
                // Store search results globally for highlighting
                AppState.currentSearchResults = searchResults;
                
                // Display results
                const resultsContainer = document.getElementById('search-results');
                if (searchResults.length === 0) {
                    resultsContainer.innerHTML = '<div class="search-result-item">No matches found</div>';
                    StatusManager.show('No matches found', 'info');
                } else {
                    resultsContainer.innerHTML = '';
                    searchResults.forEach((result, index) => {
                        const resultDiv = document.createElement('div');
                        resultDiv.className = 'search-result-item';
                        resultDiv.innerHTML = `
                            <strong>Page ${result.page} - Match ${index + 1}</strong><br>
                            <span style="font-size: 10px;">...${SecurityUtils.escapeHtml(result.context)}...</span>
                        `;
                        resultDiv.onclick = async () => {
                            // Navigate to page if needed
                            if (state.currentPage !== result.page) {
                                await PDFRenderer.renderPage(result.page);
                            }
                            
                            // Wait for page to render
                            setTimeout(() => {
                                highlightSearchMatch(result);
                                StatusManager.show(`üìç Showing match ${index + 1} on page ${result.page}`, 'success', 3000);
                            }, state.currentPage !== result.page ? 500 : 100);
                        };
                        resultsContainer.appendChild(resultDiv);
                    });
                    StatusManager.show(`Found ${searchResults.length} match(es) in ${new Set(searchResults.map(r => r.page)).size} page(s)`, 'success');
                }
            } catch (error) {
                console.error("Search Error:", error);
                StatusManager.show(`Search failed: ${error.message}`, 'error');
            } finally {
                StatusManager.showLoading(false);
            }
        };
         
        /**
         * Highlight a specific search match on the PDF
         */
        window.highlightSearchMatch = function(searchResult) {
            const pageDiv = document.querySelector('.pdf-page');
            if (!pageDiv) return;
            
            // Clear existing search highlights
            document.querySelectorAll('.search-highlight-marker').forEach(el => el.remove());
            document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight'));
            
            if (!searchResult.boundingBox) {
                StatusManager.show('No coordinates available for this match', 'warning');
                return;
            }
            
            const bbox = searchResult.boundingBox;
            
            // Create highlight marker
            const marker = document.createElement('div');
            marker.className = 'search-marker search-highlight-marker';
            marker.style.left = bbox.x + 'px';
            marker.style.top = bbox.y + 'px';
            marker.style.width = bbox.width + 'px';
            marker.style.height = bbox.height + 'px';
            marker.style.animation = 'pulse 1.5s ease-in-out 3'; // Pulse 3 times
            
            pageDiv.appendChild(marker);
            AppState.searchMarkers.push(marker);
            
            // Scroll to the marker
            marker.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // PRECISE COORDINATE-BASED TEXT LAYER HIGHLIGHTING
            const textLayer = pageDiv.querySelector('.textLayer');
            if (textLayer) {
                const textLayerRect = textLayer.getBoundingClientRect();
                const spans = textLayer.querySelectorAll('span');
                
                spans.forEach(span => {
                    const spanRect = span.getBoundingClientRect();
                    
                    // Calculate span position relative to text layer
                    const spanX = spanRect.left - textLayerRect.left;
                    const spanY = spanRect.top - textLayerRect.top;
                    const spanRight = spanX + spanRect.width;
                    const spanBottom = spanY + spanRect.height;
                    
                    // Check if span overlaps with the match's bounding box
                    const overlapsX = spanX < bbox.x + bbox.width && spanRight > bbox.x;
                    const overlapsY = spanY < bbox.y + bbox.height && spanBottom > bbox.y;
                    
                    // Only highlight if span is within the match bounding box
                    if (overlapsX && overlapsY) {
                        span.classList.add('search-highlight');
                        // Remove highlight after 5 seconds
                        setTimeout(() => span.classList.remove('search-highlight'), 5000);
                    }
                });
            }
        };
         
         /**
          * Load and parse markdown file
          */
         document.getElementById('markdown-file').onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                AppStateManager.setState({ 
                    markdownContent: text, 
                    markdownLoaded: true 
                });
                document.getElementById('markdown-status').textContent = `‚úì Loaded: ${file.name} (${text.length} chars)`;
                StatusManager.show('Markdown file loaded. Use Search Text to find quotes in PDF.', 'success');
            } catch (error) {
                console.error("Markdown Load Error:", error);
                StatusManager.show(`Failed to load markdown: ${error.message}`, 'error');
            }
        };

        // ============================================================================
        // AI PROVIDER ABSTRACTION LAYER - Multi-provider support
        // ============================================================================
        
        const AIProviders = {
            /**
             * Gemini Provider (Google)
             */
            gemini: {
                name: 'Google Gemini',
                endpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent',
                
                formatRequest: function(systemPrompt, userPrompt, schema = null) {
                    const payload = {
                        contents: [{ parts: [{ text: userPrompt }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    };
                    
                    if (schema) {
                        payload.generationConfig = {
                            responseMimeType: "application/json",
                            responseSchema: schema
                        };
                    }
                    
                    return payload;
                },
                
                parseResponse: function(result) {
                    return result.candidates?.[0]?.content?.parts?.[0]?.text;
                }
            },
            
            /**
             * Anthropic Claude Provider
             */
            anthropic: {
                name: 'Anthropic Claude',
                endpoint: 'https://api.anthropic.com/v1/messages',
                
                formatRequest: function(systemPrompt, userPrompt, schema = null) {
                    const payload = {
                        model: 'claude-3-5-sonnet-20241022',
                        max_tokens: 4096,
                        system: systemPrompt,
                        messages: [
                            { role: 'user', content: userPrompt }
                        ]
                    };
                    
                    return payload;
                },
                
                parseResponse: function(result) {
                    return result.content?.[0]?.text;
                }
            },
            
            /**
             * OpenAI GPT-4 Provider
             */
            openai: {
                name: 'OpenAI GPT-4',
                endpoint: 'https://api.openai.com/v1/chat/completions',
                
                formatRequest: function(systemPrompt, userPrompt, schema = null) {
                    const payload = {
                        model: 'gpt-4-turbo-preview',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userPrompt }
                        ]
                    };
                    
                    if (schema) {
                        payload.response_format = { type: 'json_object' };
                    }
                    
                    return payload;
                },
                
                parseResponse: function(result) {
                    return result.choices?.[0]?.message?.content;
                }
            },
            
            /**
             * Universal AI call function that routes to the correct provider with enhanced error handling
             */
            async callAI(systemPrompt, userPrompt, schema = null) {
                const provider = AppState.aiProvider || 'gemini';
                const apiKey = CONFIG.AI_API_KEY; // Used for all providers
                
                if (!apiKey || apiKey === "PASTE_YOUR_AI_API_KEY_HERE") {
                    throw new Error(`Please configure your ${this[provider].name} API key in Settings`);
                }
                
                const providerConfig = this[provider];
                const endpoint = `${providerConfig.endpoint}${provider === 'gemini' ? '?key=' + apiKey : ''}`;
                const payload = providerConfig.formatRequest(systemPrompt, userPrompt, schema);
                
                // Set headers based on provider
                const headers = { 'Content-Type': 'application/json' };
                if (provider === 'anthropic') {
                    headers['x-api-key'] = apiKey;
                    headers['anthropic-version'] = '2023-06-01';
                } else if (provider === 'openai') {
                    headers['Authorization'] = `Bearer ${apiKey}`;
                }
                
                // Retry logic with exponential backoff
                let attempt = 0;
                const maxAttempts = 3;
                let delay = 1000;
                
                while (attempt < maxAttempts) {
                    try {
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: headers,
                            body: JSON.stringify(payload)
                        });
                        
                        if (!response.ok) {
                            const errorBody = await response.json().catch(() => ({}));
                            
                            // Provider-specific error handling
                            let errorMessage = '';
                            
                            if (provider === 'gemini') {
                                if (response.status === 400) {
                                    errorMessage = 'Invalid request. Check API key or request format.';
                                } else if (response.status === 403) {
                                    errorMessage = 'API key invalid or quota exceeded.';
                                } else if (response.status === 429) {
                                    errorMessage = 'Rate limit exceeded. Please wait and try again.';
                                } else if (response.status === 500) {
                                    errorMessage = 'Gemini server error. Try again later.';
                                } else {
                                    errorMessage = errorBody.error?.message || response.statusText;
                                }
                            } else if (provider === 'anthropic') {
                                if (response.status === 401) {
                                    errorMessage = 'Invalid Anthropic API key.';
                                } else if (response.status === 429) {
                                    errorMessage = 'Rate limit exceeded. Please wait and try again.';
                                } else if (response.status === 529) {
                                    errorMessage = 'Claude is overloaded. Try again in a moment.';
                                } else {
                                    errorMessage = errorBody.error?.message || response.statusText;
                                }
                            } else if (provider === 'openai') {
                                if (response.status === 401) {
                                    errorMessage = 'Invalid OpenAI API key.';
                                } else if (response.status === 429) {
                                    errorMessage = 'Rate limit or quota exceeded.';
                                } else if (response.status === 500) {
                                    errorMessage = 'OpenAI server error. Try again later.';
                                } else {
                                    errorMessage = errorBody.error?.message || response.statusText;
                                }
                            }
                            
                            throw new Error(`${providerConfig.name} Error (${response.status}): ${errorMessage}`);
                        }
                        
                        const result = await response.json();
                        const text = providerConfig.parseResponse(result);
                        
                        if (!text) {
                            throw new Error(`No response text from ${providerConfig.name}. Check console for details.`);
                        }
                        
                        return text;
                        
                    } catch (error) {
                        attempt++;
                        console.error(`${providerConfig.name} API attempt ${attempt}/${maxAttempts} failed:`, error);
                        
                        // Don't retry on authentication errors or bad requests
                        if (error.message.includes('401') || error.message.includes('403') || error.message.includes('400')) {
                            throw error;
                        }
                        
                        // Retry on rate limits and server errors
                        if (attempt < maxAttempts && (error.message.includes('429') || error.message.includes('500') || error.message.includes('529'))) {
                            console.log(`Retrying in ${delay}ms...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2; // Exponential backoff
                            continue;
                        }
                        
                        // Max attempts reached or non-retryable error
                        throw error;
                    }
                }
                
                throw new Error(`${providerConfig.name} failed after ${maxAttempts} attempts.`);
            }
        };

        // ============================================================================
        // SESSION MANAGER - Auto-save and restore user progress
        // ============================================================================

        const SessionManager = {
            STORAGE_KEY: 'clinical_extraction_session',
            saveTimeout: null,

            /**
             * Collect all form data from all 8 steps
             */
            collectFormData: function() {
                const formData = {};
                const form = document.getElementById('extraction-form');
                if (!form) return formData;

                // Get all inputs, textareas, and selects
                const fields = form.querySelectorAll('input, textarea, select');
                fields.forEach(field => {
                    if (field.id || field.name) {
                        const key = field.id || field.name;
                        if (field.type === 'checkbox') {
                            formData[key] = field.checked;
                        } else if (field.type === 'radio') {
                            if (field.checked) formData[key] = field.value;
                        } else {
                            formData[key] = field.value;
                        }
                    }
                });

                return formData;
            },

            /**
             * Save current session to localStorage
             */
            saveSession: function() {
                try {
                    const state = AppStateManager.getState();

                    const session = {
                        version: "1.0",
                        savedAt: new Date().toISOString(),
                        formData: this.collectFormData(),
                        appState: {
                            currentStep: state.currentStep,
                            currentPage: state.currentPage,
                            scale: state.scale,
                            documentName: state.documentName,
                            activeField: state.activeField
                        }
                    };

                    // Store in localStorage
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(session));

                    // Optional: Show subtle indicator
                    console.log('Session saved:', new Date().toISOString());

                } catch (error) {
                    console.error('Failed to save session:', error);
                    // Handle quota exceeded error
                    if (error.name === 'QuotaExceededError') {
                        StatusManager.show('‚ö†Ô∏è Storage full. Export data and clear old sessions.', 'warning', 5000);
                    }
                }
            },

            /**
             * Save session with debouncing to avoid excessive writes
             */
            debouncedSave: function() {
                clearTimeout(this.saveTimeout);
                this.saveTimeout = setTimeout(() => {
                    this.saveSession();
                }, 500); // Wait 500ms after last change
            },

            /**
             * Load and restore session from localStorage
             */
            loadSession: function() {
                try {
                    const saved = localStorage.getItem(this.STORAGE_KEY);
                    if (!saved) return null;

                    const session = JSON.parse(saved);

                    // Restore form data
                    if (session.formData) {
                        Object.keys(session.formData).forEach(key => {
                            const field = document.getElementById(key) || document.querySelector(`[name="${key}"]`);
                            if (field) {
                                if (field.type === 'checkbox') {
                                    field.checked = session.formData[key];
                                } else if (field.type === 'radio') {
                                    if (field.value === session.formData[key]) {
                                        field.checked = true;
                                    }
                                } else {
                                    field.value = session.formData[key];
                                }
                            }
                        });
                    }

                    // Restore app state
                    if (session.appState) {
                        if (session.appState.currentStep !== undefined) {
                            AppStateManager.setState({ currentStep: session.appState.currentStep });
                            if (FormManager && FormManager.showStep) {
                                FormManager.showStep(session.appState.currentStep);
                            }
                        }
                        if (session.appState.currentPage) {
                            AppStateManager.setState({ currentPage: session.appState.currentPage });
                        }
                        if (session.appState.scale) {
                            AppStateManager.setState({ scale: session.appState.scale });
                        }
                        if (session.appState.documentName) {
                            AppStateManager.setState({ documentName: session.appState.documentName });
                        }
                    }

                    // Show notification
                    const savedDate = new Date(session.savedAt);
                    const timeAgo = this.getTimeAgo(savedDate);
                    StatusManager.show(`‚úì Session restored (saved ${timeAgo})`, 'success', 4000);

                    console.log('Session restored from:', session.savedAt);
                    return session;

                } catch (error) {
                    console.error('Failed to load session:', error);
                    return null;
                }
            },

            /**
             * Clear session from localStorage
             */
            clearSession: function() {
                try {
                    localStorage.removeItem(this.STORAGE_KEY);
                    StatusManager.show('‚úì Session cleared', 'success');
                    console.log('Session cleared');
                } catch (error) {
                    console.error('Failed to clear session:', error);
                }
            },

            /**
             * Get session info for display
             */
            getSessionInfo: function() {
                try {
                    const saved = localStorage.getItem(this.STORAGE_KEY);
                    if (!saved) return null;

                    const session = JSON.parse(saved);
                    return {
                        savedAt: session.savedAt,
                        timeAgo: this.getTimeAgo(new Date(session.savedAt)),
                        hasData: Object.keys(session.formData || {}).length > 0,
                        currentStep: session.appState?.currentStep
                    };
                } catch (error) {
                    return null;
                }
            },

            /**
             * Helper to get human-readable time ago
             */
            getTimeAgo: function(date) {
                const seconds = Math.floor((new Date() - date) / 1000);

                if (seconds < 60) return 'just now';
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
                const hours = Math.floor(minutes / 60);
                if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
                const days = Math.floor(hours / 24);
                return `${days} day${days > 1 ? 's' : ''} ago`;
            },

            /**
             * Setup auto-save listeners
             */
            initializeAutoSave: function() {
                const form = document.getElementById('extraction-form');
                if (!form) return;

                // Save on input/change events (debounced)
                form.addEventListener('input', () => this.debouncedSave());
                form.addEventListener('change', () => this.debouncedSave());

                // Save on step navigation
                const nextBtn = document.getElementById('next-btn');
                const prevBtn = document.getElementById('prev-btn');
                if (nextBtn) nextBtn.addEventListener('click', () => this.saveSession());
                if (prevBtn) prevBtn.addEventListener('click', () => this.saveSession());

                // Save before page unload
                window.addEventListener('beforeunload', () => this.saveSession());

                console.log('Auto-save initialized');
            },

            /**
             * Export complete session to downloadable JSON file
             * @param {Object} options - Export options { includePDF: boolean, includeImages: boolean }
             */
            exportToFile: async function(options = {}) {
                try {
                    const state = AppStateManager.getState();
                    const extractions = ExtractionTracker.getExtractions();

                    // Build complete session data
                    const sessionExport = {
                        version: "2.0",
                        exportType: "complete_session",
                        exportedAt: new Date().toISOString(),
                        documentName: state.documentName || "untitled",
                        sessionData: {
                            formData: this.collectFormData(),
                            appState: {
                                currentStep: state.currentStep,
                                currentPage: state.currentPage,
                                scale: state.scale,
                                documentName: state.documentName
                            },
                            extractions: extractions,
                            pdfMetadata: {
                                name: state.documentName,
                                pages: state.totalPages,
                                currentPage: state.currentPage,
                                scale: state.scale
                            }
                        },
                        pdfIncluded: false
                    };

                    // Optionally include PDF blob
                    if (options.includePDF && state.pdfBlob) {
                        StatusManager.show('‚è≥ Converting PDF to Base64... This may take a moment.', 'info', 10000);
                        const base64 = await this.blobToBase64(state.pdfBlob);
                        sessionExport.pdfData = {
                            base64: base64,
                            size: state.pdfBlob.size,
                            type: state.pdfBlob.type
                        };
                        sessionExport.pdfIncluded = true;
                    }

                    // Generate filename
                    const docName = (state.documentName || 'session').replace(/[^a-z0-9]/gi, '-').toLowerCase();
                    const timestamp = new Date().toISOString().slice(0, 10);
                    const filename = `session_${docName}_${timestamp}.json`;

                    // Download file
                    const jsonStr = JSON.stringify(sessionExport, null, 2);
                    const blob = new Blob([jsonStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);

                    // Show success
                    const sizeKB = Math.round(blob.size / 1024);
                    StatusManager.show(`‚úì Session exported: ${filename} (${sizeKB} KB)`, 'success', 5000);
                    console.log('Session exported:', filename, sizeKB + ' KB');

                } catch (error) {
                    console.error('Failed to export session:', error);
                    StatusManager.show('‚ùå Failed to export session: ' + error.message, 'error', 5000);
                }
            },

            /**
             * Import session from uploaded JSON file
             * @param {File} file - The uploaded JSON file
             */
            importFromFile: async function(file) {
                try {
                    // Read file
                    const text = await file.text();
                    const sessionData = JSON.parse(text);

                    // Validate session data
                    if (!this.validateSessionFile(sessionData)) {
                        throw new Error('Invalid session file format');
                    }

                    // Show import preview
                    const shouldImport = await this.showImportPreview(sessionData);
                    if (!shouldImport) {
                        StatusManager.show('Import cancelled', 'info');
                        return;
                    }

                    // Clear current session
                    StatusManager.show('‚è≥ Restoring session...', 'info', 3000);

                    // Restore form data
                    if (sessionData.sessionData.formData) {
                        Object.keys(sessionData.sessionData.formData).forEach(key => {
                            const field = document.getElementById(key) || document.querySelector(`[name="${key}"]`);
                            if (field) {
                                if (field.type === 'checkbox') {
                                    field.checked = sessionData.sessionData.formData[key];
                                } else if (field.type === 'radio') {
                                    if (field.value === sessionData.sessionData.formData[key]) {
                                        field.checked = true;
                                    }
                                } else {
                                    field.value = sessionData.sessionData.formData[key];
                                }
                            }
                        });
                    }

                    // Restore extractions
                    if (sessionData.sessionData.extractions) {
                        // Clear current extractions
                        ExtractionTracker.extractions = sessionData.sessionData.extractions;
                        ExtractionTracker.save();
                        ExtractionTracker.render();
                    }

                    // Restore app state
                    if (sessionData.sessionData.appState) {
                        const appState = sessionData.sessionData.appState;
                        if (appState.currentStep !== undefined) {
                            AppStateManager.setState({ currentStep: appState.currentStep });
                            if (FormManager && FormManager.showStep) {
                                FormManager.showStep(appState.currentStep);
                            }
                        }
                        if (appState.documentName) {
                            AppStateManager.setState({ documentName: appState.documentName });
                        }
                    }

                    // Restore PDF if included
                    if (sessionData.pdfIncluded && sessionData.pdfData) {
                        StatusManager.show('‚è≥ Restoring PDF...', 'info', 3000);
                        const pdfBlob = await this.base64ToBlob(sessionData.pdfData.base64, sessionData.pdfData.type);
                        await this.loadPDFFromBlob(pdfBlob, sessionData.documentName);
                    } else if (sessionData.sessionData.pdfMetadata) {
                        // PDF not included - inform user
                        StatusManager.show(`‚ö†Ô∏è Please re-upload PDF: ${sessionData.sessionData.pdfMetadata.name}`, 'warning', 8000);
                    }

                    // Save to localStorage
                    this.saveSession();

                    // Show success
                    StatusManager.show(`‚úì Session restored: ${sessionData.documentName}`, 'success', 5000);
                    console.log('Session imported:', sessionData.documentName);

                } catch (error) {
                    console.error('Failed to import session:', error);
                    StatusManager.show('‚ùå Failed to import session: ' + error.message, 'error', 5000);
                }
            },

            /**
             * Validate session file structure
             */
            validateSessionFile: function(data) {
                if (!data || typeof data !== 'object') return false;
                if (!data.version || !data.sessionData) return false;
                if (!data.sessionData.formData || !data.sessionData.appState) return false;
                return true;
            },

            /**
             * Show import preview modal
             */
            showImportPreview: function(sessionData) {
                return new Promise((resolve) => {
                    const formFieldCount = Object.keys(sessionData.sessionData.formData || {}).length;
                    const extractionCount = (sessionData.sessionData.extractions || []).length;
                    const step = (sessionData.sessionData.appState?.currentStep || 0) + 1;
                    const pdfIncluded = sessionData.pdfIncluded ? 'YES - Included' : 'NO - You must re-upload';

                    const message = `
Restore Session: "${sessionData.documentName}"

‚úì Form data: ${formFieldCount} fields filled
‚úì Extractions: ${extractionCount} items
‚úì Current step: Step ${step} of 8
‚úì PDF: ${sessionData.sessionData.pdfMetadata?.name || 'Unknown'} (${pdfIncluded})

‚ö†Ô∏è This will replace your current session.

Continue with import?`;

                    if (confirm(message)) {
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                });
            },

            /**
             * Calculate session export size
             */
            getExportSize: function(includePDF = false) {
                const session = {
                    formData: this.collectFormData(),
                    extractions: ExtractionTracker.getExtractions(),
                    appState: AppStateManager.getState()
                };

                let sizeBytes = JSON.stringify(session).length;

                if (includePDF) {
                    const state = AppStateManager.getState();
                    if (state.pdfBlob) {
                        // Base64 encoding increases size by ~33%
                        sizeBytes += state.pdfBlob.size * 1.33;
                    }
                }

                // Convert to human-readable
                if (sizeBytes < 1024) return sizeBytes + ' B';
                if (sizeBytes < 1024 * 1024) return Math.round(sizeBytes / 1024) + ' KB';
                return (sizeBytes / (1024 * 1024)).toFixed(1) + ' MB';
            },

            /**
             * Helper: Convert Blob to Base64
             */
            blobToBase64: function(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]); // Remove data:..., prefix
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            },

            /**
             * Helper: Convert Base64 to Blob
             */
            base64ToBlob: function(base64, mimeType) {
                const byteCharacters = atob(base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], { type: mimeType });
            },

            /**
             * Helper: Load PDF from Blob
             */
            loadPDFFromBlob: async function(blob, filename) {
                try {
                    const arrayBuffer = await blob.arrayBuffer();
                    const loadingTask = window.pdfjsLib.getDocument({ data: arrayBuffer });
                    const pdfDoc = await loadingTask.promise;

                    // Update app state
                    AppStateManager.setState({
                        pdfDoc: pdfDoc,
                        pdfBlob: blob,
                        documentName: filename,
                        totalPages: pdfDoc.numPages,
                        currentPage: 1
                    });

                    // Render first page
                    if (window.PDFRenderer && window.PDFRenderer.renderPage) {
                        await window.PDFRenderer.renderPage(1);
                    }

                    document.getElementById('total-pages').textContent = pdfDoc.numPages.toString();

                } catch (error) {
                    console.error('Failed to load PDF from blob:', error);
                    throw error;
                }
            }
        };

        // ============================================================================
        // SETTINGS MANAGER - Frontend configuration without code editing
        // ============================================================================

        const SettingsManager = {
            STORAGE_KEY: 'clinical_extraction_settings',
            
            /**
             * Load settings from localStorage on startup
             */
            loadSettings: function() {
                try {
                    const encrypted = localStorage.getItem(this.STORAGE_KEY);
                    if (encrypted) {
                        const settings = JSON.parse(atob(encrypted));
                        
                        // Update CONFIG object
                        if (settings.aiProvider) AppState.aiProvider = settings.aiProvider;
                        if (settings.aiApiKey) CONFIG.AI_API_KEY = settings.aiApiKey;
                        if (settings.googleClientId) CONFIG.GOOGLE_CLIENT_ID = settings.googleClientId;
                        if (settings.googleSheetId) CONFIG.GOOGLE_SHEET_ID = settings.googleSheetId;
                        
                        this.updateStatusIndicators();
                        console.log('Settings loaded from localStorage');
                        return settings;
                    }
                } catch (error) {
                    console.error('Failed to load settings:', error);
                }
                return null;
            },
            
            /**
             * Update status badge indicators
             */
            updateStatusIndicators: function() {
                const aiConfigured = CONFIG.AI_API_KEY && CONFIG.AI_API_KEY !== "PASTE_YOUR_AI_API_KEY_HERE";
                const sheetsConfigured = CONFIG.GOOGLE_CLIENT_ID && CONFIG.GOOGLE_CLIENT_ID !== "PASTE_YOUR_CLIENT_ID_HERE.apps.googleusercontent.com" &&
                                        CONFIG.GOOGLE_SHEET_ID && CONFIG.GOOGLE_SHEET_ID !== "PASTE_YOUR_SHEET_ID_HERE";
                
                const aiStatus = document.getElementById('ai-status');
                const sheetsStatus = document.getElementById('sheets-status');
                
                if (aiStatus) {
                    aiStatus.textContent = aiConfigured ? '‚úì Configured' : 'Not Configured';
                    aiStatus.className = aiConfigured ? 'key-status configured' : 'key-status missing';
                }
                
                if (sheetsStatus) {
                    sheetsStatus.textContent = sheetsConfigured ? '‚úì Configured' : 'Not Configured';
                    sheetsStatus.className = sheetsConfigured ? 'key-status configured' : 'key-status missing';
                }
            }
        };
        
        /**
         * Open settings modal and load current values
         */
        window.openSettings = function() {
            const modal = document.getElementById('settings-modal');
            if (!modal) return;
            
            // Load current values (show masked if exists)
            const aiProvider = AppState.aiProvider || 'gemini';
            const aiKey = CONFIG.AI_API_KEY;
            const clientId = CONFIG.GOOGLE_CLIENT_ID;
            const sheetId = CONFIG.GOOGLE_SHEET_ID;
            
            document.getElementById('ai-provider').value = aiProvider;
            
            // Show masked values for security
            if (aiKey && aiKey !== "PASTE_YOUR_AI_API_KEY_HERE") {
                document.getElementById('ai-api-key').value = aiKey.substring(0, 8) + '...' + aiKey.slice(-4);
                document.getElementById('ai-api-key').dataset.fullKey = aiKey;
            }
            
            if (clientId && clientId !== "PASTE_YOUR_CLIENT_ID_HERE.apps.googleusercontent.com") {
                document.getElementById('google-client-id').value = clientId;
            }
            
            if (sheetId && sheetId !== "PASTE_YOUR_SHEET_ID_HERE") {
                document.getElementById('google-sheet-id').value = sheetId;
            }
            
            updateProviderFields();
            updateSessionInfo(); // Update session info display

            // Hook up export size estimate updates
            const includePdfCheckbox = document.getElementById('include-pdf-export');
            if (includePdfCheckbox) {
                includePdfCheckbox.onchange = updateExportSizeEstimate;
                updateExportSizeEstimate(); // Calculate initial size
            }

            modal.classList.add('active');
        };

        /**
         * Update session info in settings modal
         */
        window.updateSessionInfo = function() {
            const sessionInfo = SessionManager.getSessionInfo();
            const statusBadge = document.getElementById('session-status');
            const timestampSpan = document.getElementById('session-timestamp');
            const stepSpan = document.getElementById('session-step');

            if (sessionInfo && sessionInfo.hasData) {
                statusBadge.textContent = 'Active';
                statusBadge.className = 'key-status configured';
                timestampSpan.textContent = sessionInfo.timeAgo;
                stepSpan.textContent = `Step ${(sessionInfo.currentStep || 0) + 1} of 8`;
            } else {
                statusBadge.textContent = 'No Session';
                statusBadge.className = 'key-status missing';
                timestampSpan.textContent = 'Never';
                stepSpan.textContent = 'N/A';
            }
        };

        /**
         * Clear session data
         */
        window.clearSessionData = function() {
            if (confirm('Are you sure you want to clear your saved session? This will erase all form data and progress.')) {
                SessionManager.clearSession();
                updateSessionInfo();

                // Optionally reload page to show cleared state
                if (confirm('Session cleared. Reload page to see changes?')) {
                    location.reload();
                }
            }
        };

        /**
         * Export session to downloadable file
         */
        window.exportSessionToFile = async function() {
            const includePDF = document.getElementById('include-pdf-export').checked;
            await SessionManager.exportToFile({ includePDF: includePDF });
        };

        /**
         * Handle session import from file
         */
        window.handleSessionImport = async function(event) {
            const file = event.target.files[0];
            if (!file) return;

            await SessionManager.importFromFile(file);

            // Reset file input
            event.target.value = '';

            // Update UI
            updateSessionInfo();

            // Close settings modal
            closeSettings();
        };

        /**
         * Update export size estimate when checkbox changes
         */
        window.updateExportSizeEstimate = function() {
            const includePDF = document.getElementById('include-pdf-export').checked;
            const sizeEstimate = SessionManager.getExportSize(includePDF);
            document.getElementById('export-size-estimate').textContent = `Estimated size: ${sizeEstimate}`;
        };

        /**
         * Close settings modal without saving
         */
        window.closeSettings = function() {
            const modal = document.getElementById('settings-modal');
            if (modal) modal.classList.remove('active');
        };
        
        /**
         * Update help text based on selected provider
         */
        window.updateProviderFields = function() {
            const provider = document.getElementById('ai-provider').value;
            const helpText = document.getElementById('ai-help-text');
            
            const providerInfo = {
                gemini: 'Get Gemini key from: <a href="https://makersuite.google.com/app/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio</a>',
                anthropic: 'Get Claude key from: <a href="https://console.anthropic.com/settings/keys" target="_blank" rel="noopener noreferrer">Anthropic Console</a>',
                openai: 'Get OpenAI key from: <a href="https://platform.openai.com/api-keys" target="_blank" rel="noopener noreferrer">OpenAI Platform</a>'
            };
            
            helpText.innerHTML = providerInfo[provider] || providerInfo.gemini;
        };
        
        /**
         * Save settings to localStorage
         */
        window.saveSettings = function() {
            const provider = document.getElementById('ai-provider').value;
            let apiKey = document.getElementById('ai-api-key').value;
            const clientId = document.getElementById('google-client-id').value;
            const sheetId = document.getElementById('google-sheet-id').value;
            
            // If key was masked, use the full key from dataset
            if (apiKey.includes('...') && document.getElementById('ai-api-key').dataset.fullKey) {
                apiKey = document.getElementById('ai-api-key').dataset.fullKey;
            }
            
            // Validate inputs
            if (!apiKey || apiKey.length < 10) {
                StatusManager.show('Please enter a valid API key', 'warning');
                return;
            }
            
            // Save to localStorage (encrypted)
            const settings = {
                aiProvider: provider,
                aiApiKey: apiKey,
                googleClientId: clientId,
                googleSheetId: sheetId,
                savedAt: new Date().toISOString()
            };
            
            try {
                const encrypted = btoa(JSON.stringify(settings));
                localStorage.setItem(SettingsManager.STORAGE_KEY, encrypted);
                
                // Update CONFIG
                AppState.aiProvider = provider;
                CONFIG.AI_API_KEY = apiKey; // Used for all providers initially
                CONFIG.GOOGLE_CLIENT_ID = clientId;
                CONFIG.GOOGLE_SHEET_ID = sheetId;
                
                SettingsManager.updateStatusIndicators();
                closeSettings();
                StatusManager.show('‚úì Settings saved successfully!', 'success');
                
                // Reinitialize Google Auth if client ID changed
                if (clientId && window.gisLoaded) {
                    window.gisLoaded();
                }
            } catch (error) {
                console.error('Failed to save settings:', error);
                StatusManager.show('Failed to save settings', 'error');
            }
        };
        
        /**
         * Clear all settings
         */
        window.clearSettings = function() {
            if (!confirm('Clear all API keys and settings? This cannot be undone.')) {
                return;
            }
            
            localStorage.removeItem(SettingsManager.STORAGE_KEY);
            document.getElementById('ai-api-key').value = '';
            document.getElementById('google-client-id').value = '';
            document.getElementById('google-sheet-id').value = '';
            document.getElementById('ai-provider').value = 'gemini';
            
            // Reset CONFIG
            CONFIG.AI_API_KEY = "PASTE_YOUR_AI_API_KEY_HERE";
            CONFIG.GOOGLE_CLIENT_ID = "PASTE_YOUR_CLIENT_ID_HERE.apps.googleusercontent.com";
            CONFIG.GOOGLE_SHEET_ID = "PASTE_YOUR_SHEET_ID_HERE";
            AppState.aiProvider = 'gemini';
            
            SettingsManager.updateStatusIndicators();
            StatusManager.show('All settings cleared', 'info');
        };

        // ============================================================================
        // TABLE PARSER MODAL FUNCTIONS
        // ============================================================================

        /**
         * Close table parser modal
         */
        window.closeTableParser = function() {
            const modal = document.getElementById('table-parser-modal');
            modal.classList.remove('active');
        };

        /**
         * Toggle raw JSON visibility
         */
        window.toggleRawJSON = function() {
            const checkbox = document.getElementById('show-raw-json');
            const container = document.getElementById('table-json-container');
            container.style.display = checkbox.checked ? 'block' : 'none';
        };

        /**
         * Export table as JSON file
         */
        window.exportTableAsJSON = function() {
            if (!TableParserManager.currentTableData) {
                StatusManager.show('No table data to export', 'warning');
                return;
            }

            const data = TableParserManager.currentTableData.data;
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const filename = `table_p${TableParserManager.currentTableData.page}_${Date.now()}.json`;
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            StatusManager.show(`‚úì Table exported: ${filename}`, 'success');
        };

        /**
         * Export table as CSV file
         */
        window.exportTableAsCSV = function() {
            if (!TableParserManager.currentTableData) {
                StatusManager.show('No table data to export', 'warning');
                return;
            }

            const data = TableParserManager.currentTableData.data;
            let csv = '';

            // Add headers
            if (data.headers && data.headers.length > 0) {
                csv += data.headers.map(h => `"${String(h).replace(/"/g, '""')}"`).join(',') + '\n';
            }

            // Add rows
            if (data.rows && data.rows.length > 0) {
                data.rows.forEach(row => {
                    csv += row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',') + '\n';
                });
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);

            const filename = `table_p${TableParserManager.currentTableData.page}_${Date.now()}.csv`;
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            StatusManager.show(`‚úì Table exported: ${filename}`, 'success');
        };

        /**
         * Copy table to clipboard
         */
        window.copyTableToClipboard = function() {
            if (!TableParserManager.currentTableData) {
                StatusManager.show('No table data to copy', 'warning');
                return;
            }

            const data = TableParserManager.currentTableData.data;
            let text = '';

            // Add headers
            if (data.headers && data.headers.length > 0) {
                text += data.headers.join('\t') + '\n';
            }

            // Add rows
            if (data.rows && data.rows.length > 0) {
                data.rows.forEach(row => {
                    text += row.join('\t') + '\n';
                });
            }

            navigator.clipboard.writeText(text)
                .then(() => {
                    StatusManager.show('‚úì Table copied to clipboard (tab-separated)', 'success');
                })
                .catch(err => {
                    console.error('Clipboard copy failed:', err);
                    StatusManager.show('‚ùå Failed to copy to clipboard', 'error');
                });
        };

        // Load settings on startup
        SettingsManager.loadSettings();
        SettingsManager.updateStatusIndicators();

        // Load session and initialize auto-save
        setTimeout(() => {
            SessionManager.loadSession(); // Restore previous session if exists
            SessionManager.initializeAutoSave(); // Setup auto-save listeners
        }, 500); // Delay to ensure FormManager is initialized

        // ============================================================================
        // PDF ANNOTATIONS IMPORTER - Feature 2: Import PDF Annotations
        // ============================================================================
        
        const AnnotationImporter = {
            allAnnotations: [],
            
            async importAnnotations() {
                const state = AppStateManager.getState();
                if (!state.pdfDoc) {
                    StatusManager.show('Please load a PDF first', 'warning');
                    return;
                }
                
                if (state.isProcessing) {
                    StatusManager.show('Please wait for the current operation to finish', 'warning');
                    return;
                }
                
                AppStateManager.setState({ isProcessing: true });
                StatusManager.showLoading(true);
                StatusManager.show('üìù Scanning PDF for annotations...', 'info');
                
                try {
                    this.allAnnotations = [];
                    
                    // Scan all pages for annotations
                    for (let pageNum = 1; pageNum <= state.totalPages; pageNum++) {
                        const page = await state.pdfDoc.getPage(pageNum);
                        const annotations = await page.getAnnotations();
                        
                        annotations.forEach(anno => {
                            // Filter for useful annotation types
                            if (anno.subtype === 'Highlight' || anno.subtype === 'Text' || 
                                anno.subtype === 'FreeText' || anno.subtype === 'Underline') {
                                
                                this.allAnnotations.push({
                                    id: anno.id || `anno_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    page: pageNum,
                                    type: anno.subtype,
                                    content: anno.contents || '',
                                    title: anno.titleObj?.str || anno.title || '',
                                    rect: anno.rect || [0, 0, 0, 0],
                                    color: anno.color || [1, 1, 0],
                                    quadPoints: anno.quadPoints || []
                                });
                            }
                        });
                    }
                    
                    StatusManager.showLoading(false);
                    
                    if (this.allAnnotations.length === 0) {
                        StatusManager.show('No annotations found in this PDF', 'info');
                        AppStateManager.setState({ isProcessing: false });
                        return;
                    }
                    
                    StatusManager.show(`Found ${this.allAnnotations.length} annotation(s)`, 'success');
                    this.showAnnotationsPanel();
                    
                } catch (error) {
                    console.error('Annotation import error:', error);
                    StatusManager.show(`Failed to import annotations: ${error.message}`, 'error');
                } finally {
                    AppStateManager.setState({ isProcessing: false });
                    StatusManager.showLoading(false);
                }
            },
            
            showAnnotationsPanel() {
                // Create modal for annotations
                const existingModal = document.getElementById('annotations-modal');
                if (existingModal) existingModal.remove();
                
                const modal = document.createElement('div');
                modal.id = 'annotations-modal';
                modal.className = 'settings-modal active';
                
                let annotationsHTML = `
                    <div class="settings-content" style="max-width: 700px;">
                        <h2>üìù Import PDF Annotations (${this.allAnnotations.length})</h2>
                        <p class="subtitle" style="margin-bottom: 15px;">
                            Click on an annotation to extract its text, or use "Import All" to batch process.
                        </p>
                        <div style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
                `;
                
                this.allAnnotations.forEach((anno, index) => {
                    const colorRgb = this.colorArrayToRgb(anno.color);
                    annotationsHTML += `
                        <div class="annotation-item" style="
                            background: #f9f9f9;
                            border-left: 4px solid ${colorRgb};
                            padding: 12px;
                            margin-bottom: 10px;
                            border-radius: 4px;
                            cursor: pointer;
                            transition: all 0.2s;
                        " onmouseover="this.style.background='#e3f2fd'" 
                           onmouseout="this.style.background='#f9f9f9'"
                           onclick="importSingleAnnotation(${index})">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <strong style="color: #1976D2;">Page ${anno.page} - ${anno.type}</strong>
                                    ${anno.title ? `<div style="font-size: 12px; color: #666; margin-top: 4px;">üìå ${SecurityUtils.escapeHtml(anno.title)}</div>` : ''}
                                    ${anno.content ? `<div style="font-size: 11px; color: #333; margin-top: 6px; padding: 6px; background: white; border-radius: 3px;">"${SecurityUtils.escapeHtml(anno.content.substring(0, 150))}${anno.content.length > 150 ? '...' : ''}"</div>` : ''}
                                </div>
                                <button onclick="event.stopPropagation(); importSingleAnnotation(${index})" 
                                        style="padding: 6px 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    Import ‚Üí
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                annotationsHTML += `
                        </div>
                        <div class="settings-actions">
                            <button onclick="closeAnnotationsPanel()" style="background: #6c757d;">Close</button>
                            <button onclick="importAllAnnotations()" style="background: #4CAF50;">Import All (${this.allAnnotations.length})</button>
                        </div>
                    </div>
                `;
                
                modal.innerHTML = annotationsHTML;
                document.body.appendChild(modal);
            },
            
            async importSingle(index) {
                const anno = this.allAnnotations[index];
                if (!anno) return;
                
                const state = AppStateManager.getState();
                
                try {
                    // Navigate to annotation page if different
                    if (state.currentPage !== anno.page) {
                        await PDFRenderer.renderPage(anno.page);
                    }
                    
                    // Extract text from annotation area
                    const region = this.rectToRegion(anno.rect);
                    let extractedText = anno.content || anno.title || '';
                    
                    // If no content in annotation metadata, try extracting from coordinates
                    if (!extractedText && region.width > 0 && region.height > 0) {
                        extractedText = await RegionSelectionManager.extractTextFromRegion(region, anno.page);
                    }
                    
                    if (!extractedText) {
                        StatusManager.show('No text found in annotation', 'warning');
                        return;
                    }
                    
                    // Auto-suggest field mapping
                    const suggestedField = this.suggestFieldMapping(extractedText);
                    
                    if (suggestedField && state.activeField !== suggestedField) {
                        const fieldElement = document.getElementById(suggestedField) || 
                                           document.querySelector(`[name="${suggestedField}"]`);
                        if (fieldElement) {
                            fieldElement.focus(); // This will trigger field activation
                            StatusManager.show(`üí° Suggested field: ${suggestedField}`, 'info', 2000);
                            // Wait a bit for field to activate
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    }
                    
                    const currentState = AppStateManager.getState();
                    if (!currentState.activeField) {
                        StatusManager.show('Please select a field to import into', 'warning');
                        return;
                    }
                    
                    // Create extraction record
                    const sanitizedText = SecurityUtils.sanitizeText(extractedText);
                    const extraction = ExtractionTracker.addExtraction({
                        fieldName: currentState.activeField,
                        text: sanitizedText,
                        page: anno.page,
                        coordinates: region,
                        method: 'annotation',
                        documentName: currentState.documentName
                    });
                    
                    if (extraction && currentState.activeFieldElement) {
                        currentState.activeFieldElement.value = sanitizedText;
                        currentState.activeFieldElement.classList.add('has-extraction');
                    }
                    
                    if (extraction) {
                        addExtractionMarker(extraction);
                        StatusManager.show(`‚úì Imported annotation from page ${anno.page}`, 'success');
                        autoAdvanceField();
                    }
                    
                } catch (error) {
                    console.error('Single annotation import error:', error);
                    StatusManager.show(`Import failed: ${error.message}`, 'error');
                }
            },
            
            async importAll() {
                if (!confirm(`Import all ${this.allAnnotations.length} annotations? This will populate available fields.`)) {
                    return;
                }
                
                StatusManager.showLoading(true);
                let successCount = 0;
                
                for (let i = 0; i < this.allAnnotations.length; i++) {
                    try {
                        await this.importSingle(i);
                        successCount++;
                        // Small delay to prevent overwhelming the UI
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (error) {
                        console.error(`Failed to import annotation ${i}:`, error);
                    }
                }
                
                StatusManager.showLoading(false);
                StatusManager.show(`‚úì Imported ${successCount}/${this.allAnnotations.length} annotations`, 'success');
                this.closePanel();
            },
            
            suggestFieldMapping(text) {
                const lowerText = text.toLowerCase();
                
                // Keyword-based field mapping
                const mappings = [
                    { keywords: ['doi', '10.'], field: 'doi' },
                    { keywords: ['pmid', 'pubmed'], field: 'pmid' },
                    { keywords: ['population', 'patients', 'participants'], field: 'eligibility-population' },
                    { keywords: ['intervention', 'surgery', 'treatment'], field: 'eligibility-intervention' },
                    { keywords: ['control', 'comparator', 'comparison'], field: 'eligibility-comparator' },
                    { keywords: ['outcome', 'result', 'endpoint'], field: 'eligibility-outcomes' },
                    { keywords: ['funding', 'grant', 'supported by'], field: 'funding' },
                    { keywords: ['conflict', 'disclosure'], field: 'conflicts' },
                    { keywords: ['registration', 'nct', 'trial id'], field: 'registration' }
                ];
                
                for (const mapping of mappings) {
                    if (mapping.keywords.some(keyword => lowerText.includes(keyword))) {
                        return mapping.field;
                    }
                }
                
                return null; // No suggestion
            },
            
            rectToRegion(rect) {
                // PDF rect format: [x1, y1, x2, y2]
                const x = Math.min(rect[0], rect[2]);
                const y = Math.min(rect[1], rect[3]);
                const width = Math.abs(rect[2] - rect[0]);
                const height = Math.abs(rect[3] - rect[1]);
                
                return { x, y, width, height };
            },
            
            colorArrayToRgb(colorArray) {
                if (!colorArray || colorArray.length < 3) return '#FFFF00';
                const r = Math.round(colorArray[0] * 255);
                const g = Math.round(colorArray[1] * 255);
                const b = Math.round(colorArray[2] * 255);
                return `rgb(${r}, ${g}, ${b})`;
            },
            
            closePanel() {
                const modal = document.getElementById('annotations-modal');
                if (modal) modal.remove();
            }
        };
        
        /**
         * Import PDF annotations
         */
        window.importPDFAnnotations = function() {
            AnnotationImporter.importAnnotations();
        };
        
        /**
         * Import single annotation (called from panel)
         */
        window.importSingleAnnotation = function(index) {
            AnnotationImporter.importSingle(index);
        };
        
        /**
         * Import all annotations (called from panel)
         */
        window.importAllAnnotations = function() {
            AnnotationImporter.importAll();
        };
        
        /**
         * Close annotations panel
         */
        window.closeAnnotationsPanel = function() {
            AnnotationImporter.closePanel();
        };

        // Expose Gemini functions globally
        window.generatePICO = generatePICO;
        window.generateSummary = generateSummary;
        window.validateFieldWithAI = validateFieldWithAI;
        window.findMetadata = findMetadata; // <-- Expose the new function
         
        // Expose Save functions globally
        window.handleSubmitToGoogleSheets = async (e) => {
            e.preventDefault();
            if (!CONFIG.GOOGLE_API_KEY || !CONFIG.GOOGLE_CLIENT_ID || !CONFIG.GOOGLE_SHEET_ID) {
                StatusManager.show('Google Sheets config is missing.', 'error');
                return;
            }
            if (!gapiLoaded || !gapiTokenClient) {
                 StatusManager.show('Google API client is not loaded yet. Please wait.', 'warning');
                 return;
            }
             
            // --- VALIDATION LOGIC REMOVED ---
            /*
            if (!FormManager.validateAllSteps()) {
                 StatusManager.show('Please correct validation errors on all steps before saving.', 'error');
                 return;
            }
            */

            StatusManager.showLoading(true);
            StatusManager.show('Authenticating with Google...', 'info');
             
            try {
                // Get auth token
                gapiTokenClient.callback = async (tokenResponse) => {
                    if (tokenResponse.error) {
                         throw new Error(`Google Auth Error: ${tokenResponse.error}`);
                    }
                    await gapi.client.load('sheets', 'v4');
                    StatusManager.show('Saving to Google Sheets...', 'info');
                     
                    const state = AppStateManager.getState();
                    const formData = FormManager.collectFormData();
                    const extractions = ExtractionTracker.getExtractions();

                    // Generate persistent submission ID based on document name
                    // Same document = Same ID = Update row instead of creating new one
                    const documentKey = state.documentName.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
                    let submissionId = localStorage.getItem(`submissionId_${documentKey}`);

                    if (!submissionId) {
                        // First time for this document - create new ID
                        submissionId = `sub_${documentKey}_${Date.now()}`;
                        localStorage.setItem(`submissionId_${documentKey}`, submissionId);
                    }

                    const timestamp = new Date().toISOString();

                    // --- Define Sheet Headers (Must match your sheet) ---
                    const submissionHeaders = [
                        "Submission ID", "Timestamp", "Document",
                        // Step 1: Study ID
                        "Citation", "DOI", "PMID", "Journal", "Year", "Country", "Centers", "Funding", "Conflicts", "Registration",
                        // Step 2: PICO-T
                        "Population", "Intervention", "Comparator", "Outcomes", "Timing", "Study Type", "Inclusion Met",
                        // Step 3: Baseline
                        "Total N", "Surgical N", "Control N",
                        "Age Mean", "Age SD", "Age Median", "Age IQR Lower", "Age IQR Upper",
                        "Male N", "Female N",
                        "Pre-stroke mRS", "NIHSS Mean", "GCS Mean",
                        // Step 4: Imaging
                        "Vascular Territory", "Infarct Volume", "Stroke Volume Cerebellum",
                        "Edema Dynamics", "Peak Swelling Window",
                        "Brainstem Involvement", "Supratentorial Involvement", "Non-Cerebellar Stroke",
                        // Step 5-8: Dynamic Fields (stored as JSON)
                        "Indications (JSON)", "Interventions (JSON)", "Study Arms (JSON)",
                        "Mortality Data (JSON)", "mRS Data (JSON)",
                        "Complications (JSON)", "Predictors (JSON)", "Predictors Summary"
                    ];
                    const extractionHeaders = ["Submission ID", "Field Name", "Text", "Page", "Method", "X", "Y", "Width", "Height"];

                    // Helper function to collect dynamic fields
                    const collectDynamicFields = (prefix) => {
                        const fields = [];
                        Object.keys(formData).forEach(key => {
                            if (key.startsWith(prefix)) {
                                fields.push({ field: key, value: formData[key] });
                            }
                        });
                        return fields.length > 0 ? JSON.stringify(fields) : '';
                    };

                    // 1. Prepare Submission Row with ALL form fields
                    const submissionRow = [
                        submissionId,
                        timestamp,
                        state.documentName,
                        // Step 1: Study ID
                        formData.citation || '',
                        formData.doi || '',
                        formData.pmid || '',
                        formData.journal || '',
                        formData.year || '',
                        formData.country || '',
                        formData.centers || '',
                        formData.funding || '',
                        formData.conflicts || '',
                        formData.registration || '',
                        // Step 2: PICO-T
                        formData['eligibility-population'] || '',
                        formData['eligibility-intervention'] || '',
                        formData['eligibility-comparator'] || '',
                        formData['eligibility-outcomes'] || '',
                        formData['eligibility-timing'] || '',
                        formData['eligibility-type'] || '',
                        formData['inclusion-met'] || '',
                        // Step 3: Baseline
                        formData.totalN || '',
                        formData.surgicalN || '',
                        formData.controlN || '',
                        formData.ageMean || '',
                        formData.ageSD || '',
                        formData.ageMedian || '',
                        formData.ageIQR_lower || '',
                        formData.ageIQR_upper || '',
                        formData.maleN || '',
                        formData.femaleN || '',
                        formData.prestrokeMRS || '',
                        formData.nihssMean || '',
                        formData.gcsMean || '',
                        // Step 4: Imaging
                        formData.vascularTerritory || '',
                        formData.infarctVolume || '',
                        formData.strokeVolumeCerebellum || '',
                        formData.edemaDynamics || '',
                        formData.peakSwellingWindow || '',
                        formData.brainstemInvolvement || '',
                        formData.supratentorialInvolvement || '',
                        formData.nonCerebellarStroke || '',
                        // Step 5-8: Dynamic Fields (JSON arrays)
                        collectDynamicFields('indication_'),
                        collectDynamicFields('intervention_'),
                        collectDynamicFields('arm_'),
                        collectDynamicFields('mortality_'),
                        collectDynamicFields('mrs_'),
                        collectDynamicFields('comp_'),
                        collectDynamicFields('pred_'),
                        formData.predictorsPoorOutcomeSurgical || ''
                    ];

                    // 2. Prepare Extraction Rows
                    const extractionRows = extractions.map(ext => [
                        submissionId,
                        ext.fieldName,
                        ext.text,
                        ext.page,
                        ext.method,
                        ext.coordinates.x,
                        ext.coordinates.y,
                        ext.coordinates.width,
                        ext.coordinates.height
                    ]);

                    // 3. Check if this submission already exists (UPDATE or INSERT)
                    StatusManager.show('Checking for existing submission...', 'info');

                    // Search for existing row with this Submission ID
                    const existingData = await gapi.client.sheets.spreadsheets.values.get({
                        spreadsheetId: CONFIG.GOOGLE_SHEET_ID,
                        range: 'Submissions!A:A' // Get all Submission IDs
                    });

                    let existingRowIndex = -1;
                    if (existingData.result.values) {
                        existingRowIndex = existingData.result.values.findIndex((row, idx) =>
                            idx > 0 && row[0] === submissionId // Skip header row (idx > 0)
                        );
                    }

                    if (existingRowIndex >= 0) {
                        // Found existing row - UPDATE it
                        const actualRowNumber = existingRowIndex + 1; // +1 for header row
                        StatusManager.show(`Updating existing submission (Row ${actualRowNumber})...`, 'info');

                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: CONFIG.GOOGLE_SHEET_ID,
                            range: `Submissions!A${actualRowNumber}:AV${actualRowNumber}`, // 48 columns (A to AV)
                            valueInputOption: 'USER_ENTERED',
                            resource: { values: [submissionRow] }
                        });

                        StatusManager.show('‚úì Updated existing submission!', 'success');
                    } else {
                        // Not found - INSERT new row
                        StatusManager.show('Creating new submission...', 'info');

                        await gapi.client.sheets.spreadsheets.values.append({
                            spreadsheetId: CONFIG.GOOGLE_SHEET_ID,
                            range: 'Submissions!A:A',
                            valueInputOption: 'USER_ENTERED',
                            resource: { values: [submissionRow] }
                        });

                        StatusManager.show('‚úì Created new submission!', 'success');
                    }

                    // 4. Append to 'Extractions' Sheet (always append for trace log)
                    if (extractionRows.length > 0) {
                        StatusManager.show(`Adding ${extractionRows.length} extraction trace records...`, 'info');
                         await gapi.client.sheets.spreadsheets.values.append({
                            spreadsheetId: CONFIG.GOOGLE_SHEET_ID,
                            range: 'Extractions!A:A', // Assumes 'Extractions' tab
                            valueInputOption: 'USER_ENTERED',
                            resource: { values: extractionRows }
                        });
                    }

                    StatusManager.showLoading(false);
                    StatusManager.show(`‚úì Successfully saved! (ID: ${submissionId})`, 'success');
                };
                 
                // Check if we already have a token
                if (gapi.client.getToken() === null) {
                    // Prompt the user to select a Google Account and ask for consent
                    gapiTokenClient.requestAccessToken({prompt: 'consent'});
                } else {
                    // We already have a token, just run the callback
                    gapiTokenClient.callback(gapi.client.getToken());
                }

            } catch (error) {
                 console.error("Google Sheets Save Error:", error);
                 StatusManager.show(`Google Sheets save failed: ${error.message}`, 'error');
                 StatusManager.showLoading(false);
            }
        };


         // Initial status message
         StatusManager.show('Preview Ready. Load a PDF to begin.', 'info');

        // ============================================================================
        // AUTO-LOAD SAMPLE PDF FOR TESTING
        // ============================================================================
        (async function() {
            try {
                // Auto-load Kim2016.pdf for testing
                const response = await fetch('/Kim2016.pdf');
                if (response.ok) {
                    const blob = await response.blob();
                    const file = new File([blob], 'Kim2016.pdf', { type: 'application/pdf' });
                    StatusManager.show('Auto-loading Kim2016.pdf for testing...', 'info');
                    await PDFLoader.loadPDF(file);
                } else {
                    console.log('Kim2016.pdf not found - manual upload required');
                }
            } catch (error) {
                console.log('Could not auto-load PDF:', error.message);
                // Silent fail - user can still upload manually
            }
        })();

    </script>
</body>
</html>
