<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clinical Study Extraction System - Preview</title>
    <!-- Load PDF.js library from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Google API client is loaded dynamically in the main script -->
    <!-- ADD PDF-LIB LIBRARY for annotations -->
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <style>
        /* SCSS Variables */
        :root {
            --primary-blue: #007bff;
            --primary-blue-dark: #0056b3;
            --success-green: #4CAF50;
            --success-green-light: #8BC34A;
            --warning-orange: #FF9800;
            --warning-orange-dark: #F57C00;
            --error-red: #f44336;
            --error-red-dark: #c82333;
            --info-blue: #2196F3;

            --gray-100: #f8f9fa;
            --gray-200: #e9ecef;
            --gray-300: #dee2e6;
            --gray-400: #ccc;
            --gray-500: #666;
            --gray-600: #525252;
            --gray-700: #333;
            --gray-800: #2c3e50;
            --gray-900: #1976D2;

            --background-light: #f0f2f5;
            --background-white: #ffffff;

            --spacing-xs: 5px;
            --spacing-sm: 10px;
            --spacing-md: 15px;
            --spacing-lg: 20px;
            --spacing-xl: 30px;

            --border-radius-sm: 3px;
            --border-radius-md: 4px;
            --border-radius-lg: 6px;
            --border-radius-xl: 8px;

            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-md: 2px 0 5px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 4px 6px rgba(0, 0, 0, 0.3);
            --shadow-xl: 0 4px 12px rgba(0, 0, 0, 0.15);

            --transition-fast: 0.2s;
            --transition-normal: 0.3s;
            --transition-slow: 0.4s;
        }

        /* Layout Styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            background-color: var(--background-light);
        }

        .main-container {
            display: flex;
            height: 100vh;
        }

        .form-panel {
            width: 35%;
            background: var(--background-white);
            overflow-y: auto;
            padding: var(--spacing-lg) var(--spacing-xl);
            box-shadow: var(--shadow-md);
        }

        .pdf-panel {
            width: 45%;
            background: var(--gray-200);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .trace-panel {
            width: 20%;
            background: var(--background-white);
            border-left: 1px solid var(--gray-400);
            overflow-y: auto;
            padding: var(--spacing-lg);
        }

        h1 {
            color: var(--gray-700);
            font-size: 24px;
            margin-bottom: var(--spacing-sm);
        }

        h2 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--primary-blue);
            padding-bottom: var(--spacing-sm);
            margin-top: var(--spacing-lg);
        }

        h3 {
            color: #555;
            margin-top: var(--spacing-lg);
        }

        .subtitle {
            font-size: 14px;
            color: var(--gray-500);
            margin-bottom: var(--spacing-md);
        }

        .stats-container {
            background: #f5f5f5;
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-md);
            margin-bottom: var(--spacing-md);
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
        }

        .stats-row + .stats-row {
            margin-top: var(--spacing-xs);
        }

        /* Form Styles */
        .step {
            display: none;
        }

        .step.active {
            display: block;
        }

        .form-group {
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-xs);
            border-radius: var(--border-radius-md);
            transition: all var(--transition-normal);
            position: relative; /* Needed for has-extraction pseudo-element */
        }

        .form-group.active-extraction {
            background: #fff3e0 !important;
            padding: var(--spacing-sm) !important;
            margin: calc(-1 * var(--spacing-xs)) !important;
            margin-bottom: var(--spacing-md) !important;
            border-left: 4px solid var(--warning-orange) !important;
            animation: pulse 1.5s infinite;
        }
        
        .form-group .ai-field-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .form-group .ai-field-group textarea,
        .form-group .ai-field-group input {
            flex-grow: 1;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
            color: var(--gray-700);
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 8px 10px;
            box-sizing: border-box;
            border: 1px solid var(--gray-400);
            border-radius: var(--border-radius-md);
            font-size: 14px;
        }

        /* Validation */
        .validation-error {
            border-color: var(--error-red) !important;
            background-color: #fff5f5 !important;
        }

        .validation-message {
            color: var(--error-red);
            font-size: 12px;
            margin-top: 4px;
            display: none;
        }

        .validation-error + .validation-message {
            display: block;
        }

        /* Field States */
        .linked-input {
            background-color: #f0f8ff;
            border-color: #b3d7ff;
        }

        .linked-input.has-extraction {
            background-color: #e8f5e9;
            border-color: var(--success-green);
        }

        .linked-input.has-extraction::after {
            content: '‚úì';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--success-green);
            font-weight: bold;
            pointer-events: none; /* Ensure it doesn't interfere with input focus */
        }
        /* Adjustments for textarea */
        textarea.linked-input.has-extraction::after {
            top: 10px; /* Adjust vertical position for textarea */
            transform: none;
        }

        /* Dynamic Containers */
        .dynamic-container {
            border: 1px solid #ddd;
            padding: var(--spacing-md);
            margin-top: var(--spacing-md);
            border-radius: var(--border-radius-md);
            background-color: #f9f9f9;
        }

        /* Grids */
        .grid-2col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
        }

        .grid-3col {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: var(--spacing-md);
        }

        .grid-mrs {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: var(--spacing-xs);
        }

        /* Progress Bar */
        #progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: var(--border-radius-md);
            margin-bottom: var(--spacing-lg);
        }

        #progress-bar {
            width: 0%;
            height: 10px;
            background: linear-gradient(90deg, var(--success-green), var(--success-green-light));
            border-radius: var(--border-radius-md);
            transition: width var(--transition-slow) ease;
        }

        /* Navigation */
        .navigation {
            position: sticky;
            bottom: 0;
            background: var(--background-white);
            padding: var(--spacing-md) var(--spacing-lg);
            border-top: 2px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: var(--spacing-xl);
        }


        /* PDF Viewer Styles */
        .pdf-toolbar {
            background: var(--gray-800);
            color: white;
            padding: var(--spacing-sm);
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
            box-shadow: var(--shadow-sm);
            flex-wrap: wrap;
        }

        .pdf-toolbar button {
            background: #34495e;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: var(--border-radius-md);
            cursor: pointer;
            font-size: 14px;
        }

        .pdf-toolbar button:hover {
            background: #4a5f7f;
        }

        .pdf-toolbar input[type="number"] {
            width: 50px;
            text-align: center;
            padding: 4px;
            border-radius: var(--border-radius-sm); /* Ensure consistent rounding */
        }

        .pdf-toolbar select {
            padding: 4px 8px;
            border-radius: var(--border-radius-md);
        }


        #active-field-indicator {
            background: var(--warning-orange);
            color: black; /* Ensure readability */
            padding: 4px 12px;
            border-radius: var(--border-radius-md);
            margin-left: auto;
            white-space: nowrap; /* Prevent wrapping */
        }

        .pdf-container {
            flex: 1;
            overflow: auto;
            background: var(--gray-600);
            position: relative;
            padding: var(--spacing-lg) 0;
            text-align: center; /* Center the page */
        }

        .pdf-page {
            margin: var(--spacing-lg) auto;
            background: white;
            box-shadow: var(--shadow-lg);
            position: relative;
            display: inline-block; /* Ensure centering works */
            text-align: left; /* Reset text align for content */
        }

        .upload-area {
            border: 2px dashed var(--gray-400);
            border-radius: var(--border-radius-xl);
            padding: 50px;
            text-align: center;
            margin: 50px;
            background: white;
            cursor: pointer;
        }
        .upload-area h3 {
            margin-top: 0;
        }

        .upload-link {
            cursor: pointer;
            color: var(--primary-blue);
            text-decoration: underline;
        }

        .toolbar-text {
            color: white;
            white-space: nowrap; /* Prevent wrapping */
        }

        /* Region Selection Tool Styles */
        .region-selection-box {
            position: absolute;
            border: 2px dashed var(--primary-blue);
            background: rgba(0, 123, 255, 0.1);
            pointer-events: none;
            z-index: 1000;
        }

        .selection-mode-toggle {
            background: var(--primary-blue);
            color: white;
        }

        .selection-mode-toggle.active {
            background: var(--warning-orange);
            animation: pulse 1.5s infinite;
        }

        /* Text Layer */
        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 1; /* IMPROVED: Was 0.2 - now fully visible for better selection */
            line-height: 1;
            -webkit-user-select: text; /* Safari 3+ */
            user-select: text; /* Enable text selection */
        }

        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
            -webkit-user-select: text; /* Safari 3+ */
            user-select: text; /* Enable text selection on spans */
            pointer-events: all; /* Ensure spans respond to mouse events */
        }

        /* IMPROVED: More visible selection colors */
        .textLayer ::selection {
            background: rgba(255, 193, 7, 0.6); /* Changed from blue to amber, increased opacity */
        }
        
        .textLayer ::-moz-selection {
            background: rgba(255, 193, 7, 0.6); /* Firefox support */
        }

        .textLayer.active-selection ::selection {
            background: rgba(255, 193, 7, 0.4);
        }

        .textLayer .highlight {
            background: rgba(255, 193, 7, 0.4) !important;
        }

        .textLayer .extracted {
            background: rgba(76, 175, 80, 0.2) !important;
        }

        .textLayer .search-highlight {
            background: rgba(255, 87, 34, 0.5) !important;
            color: transparent !important;
        }

        /* Extraction Markers */
        .extraction-marker {
            position: absolute;
            border: 2px solid var(--success-green);
            background: rgba(76, 175, 80, 0.15);
            pointer-events: all;
            cursor: pointer;
            box-sizing: border-box; /* Include border in size */
        }

        .extraction-marker:hover {
            background: rgba(76, 175, 80, 0.3);
            z-index: 1000;
        }

        .extraction-marker::before {
            content: attr(data-field);
            position: absolute;
            top: -24px;
            left: 0;
            background: var(--success-green);
            color: white;
            padding: 2px 8px;
            font-size: 11px;
            border-radius: var(--border-radius-sm);
            white-space: nowrap;
            opacity: 0;
            transition: opacity var(--transition-normal);
            z-index: 1001;
            pointer-events: none;
        }
        .extraction-marker[data-method^="gemini"] {
            border-color: #9b61f9;
            background: rgba(155, 97, 249, 0.15);
        }
        .extraction-marker[data-method^="gemini"]::before {
            background: #9b61f9;
        }
        .extraction-marker[data-method^="gemini"]:hover {
             background: rgba(155, 97, 249, 0.3);
        }


        .extraction-marker:hover::before {
            opacity: 1;
        }

        /* Search Result Markers */
        .search-marker {
            position: absolute;
            border: 2px solid #FF5722;
            background: rgba(255, 87, 34, 0.2);
            pointer-events: all;
            cursor: pointer;
            z-index: 500;
            box-sizing: border-box; /* Include border in size */
        }

        .search-marker:hover {
            background: rgba(255, 87, 34, 0.4);
        }

        .search-marker::before {
            content: "Match";
            position: absolute;
            top: -24px;
            left: 0;
            background: #FF5722;
            color: white;
            padding: 2px 8px;
            font-size: 11px;
            border-radius: var(--border-radius-sm);
            white-space: nowrap;
            opacity: 0;
            transition: opacity var(--transition-normal);
            z-index: 1001;
        }

        .search-marker:hover::before {
            opacity: 1;
        }

        /* Image Selection Tool Styles */
        .image-selection-box {
            position: absolute;
            border: 3px dashed #2196F3;
            background: rgba(33, 150, 243, 0.15);
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(33, 150, 243, 0.3);
        }

        /* Image thumbnails in trace log */
        .trace-entry .image-thumbnail {
            width: 100%;
            max-width: 120px;
            height: auto;
            object-fit: cover;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 8px;
            border: 2px solid #2196F3;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .trace-entry .image-thumbnail:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }

        .trace-entry[data-method="image"] {
            border-left: 4px solid #2196F3;
            background: #e3f2fd;
        }


        /* Trace Panel Styles */
        .trace-entry {
            background: var(--gray-100);
            border: 1px solid var(--gray-300);
            border-radius: var(--border-radius-md);
            padding: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
            font-size: 12px;
        }
        
        .trace-entry[data-method^="gemini"] {
            border-left: 4px solid #9b61f9;
        }
        .trace-entry[data-method^="manual"] {
            border-left: 4px solid var(--success-green);
        }

        .trace-entry:hover {
            background: #e3f2fd;
            border-color: var(--info-blue);
            transform: translateX(3px);
        }

        .trace-entry .field-label {
            font-weight: bold;
            color: var(--gray-900);
            display: block;
            margin-bottom: 4px;
        }

        .trace-entry .extracted-text {
            color: var(--gray-700);
            font-size: 11px;
            margin: 6px 0;
            padding: 4px;
            background: white;
            border-left: 3px solid var(--gray-400);
            display: block;
            word-wrap: break-word;
        }
        
        .trace-entry[data-method^="manual"] .extracted-text {
             border-left-color: var(--success-green);
        }
        .trace-entry[data-method^="gemini"] .extracted-text {
             border-left-color: #9b61f9;
        }

        .trace-entry .metadata {
            font-size: 10px;
            color: var(--gray-500);
            text-transform: capitalize;
        }

        /* Export Section */
        .export-section {
            background: #f0f8ff;
            padding: 12px;
            border-radius: var(--border-radius-lg);
            margin-bottom: var(--spacing-md);
        }

        .export-section h4 {
            margin: 0 0 var(--spacing-sm) 0;
            font-size: 14px;
        }

        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .export-buttons button {
            padding: 6px;
            font-size: 11px;
        }

        /* Markdown Section */
        .markdown-section {
            background: #fff3e0;
            padding: 12px;
            border-radius: var(--border-radius-lg);
            margin-bottom: var(--spacing-md);
            border: 1px solid var(--warning-orange);
        }

        .markdown-section h4 {
            margin: 0 0 8px 0;
            color: var(--warning-orange);
            font-size: 14px;
        }

        .markdown-section button {
            padding: 6px 12px;
            font-size: 12px;
            background: var(--warning-orange);
            margin-right: var(--spacing-xs);
        }

        .markdown-section button:hover {
            background: var(--warning-orange-dark);
        }

        #markdown-status {
            font-size: 11px;
            margin-top: var(--spacing-xs);
            color: var(--gray-500);
        }

        .trace-title {
            font-size: 18px;
            margin-top: 0;
        }

        .export-json { background: var(--success-green); color: white; }
        .export-csv { background: var(--info-blue); color: white; }
        .export-audit { background: var(--warning-orange); color: white; }
        .export-pdf { background: #9C27B0; color: white; }

        .search-interface {
            margin-top: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: white;
            border-radius: var(--border-radius-md);
            display: none;
        }

        .search-interface.active {
            display: block;
        }

        .search-interface textarea {
            width: 100%;
            height: 80px;
            margin-bottom: 8px;
            font-size: 12px;
            box-sizing: border-box; /* Include padding/border */
        }

        .search-results {
            max-height: 200px;
            overflow-y: auto;
            margin-top: var(--spacing-sm);
        }

        .search-result-item {
            padding: 8px;
            background: #f5f5f5;
            margin-bottom: var(--spacing-xs);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: 11px;
        }

        .search-result-item:hover {
            background: #e0e0e0;
        }


        /* Button Styles */
        button {
            padding: var(--spacing-sm) var(--spacing-lg);
            cursor: pointer;
            border: none;
            border-radius: var(--border-radius-md);
            background-color: var(--primary-blue);
            color: white;
            font-size: 16px;
            transition: background-color var(--transition-normal);
        }

        button:hover {
            background-color: var(--primary-blue-dark);
        }

        button:disabled {
            background-color: var(--gray-400);
            cursor: not-allowed;
        }

        .add-btn {
            background-color: #28a745;
            font-size: 14px;
            padding: 6px 12px;
            margin-top: var(--spacing-sm);
        }

        .add-btn:hover {
            background-color: #218838;
        }

        .remove-btn {
            background-color: #dc3545;
            font-size: 14px;
            padding: 6px 12px;
            margin-top: var(--spacing-sm);
        }

        .remove-btn:hover {
            background-color: var(--error-red-dark);
        }
        
        .validate-btn {
            background-color: #6c757d;
            color: white;
            padding: 4px 8px;
            font-size: 12px;
            margin-left: 5px;
        }
        .validate-btn:hover {
            background-color: #5a6268;
        }

        .hidden,
        input[type="file"] {
            display: none;
        }

        .full-width {
            width: 100%;
        }
        
        #submit-btn-group {
            display: flex;
            gap: 10px;
        }

        /* Gemini Button Styles */
        .gemini-btn {
            background: linear-gradient(135deg, #4285F4, #9b61f9);
            color: white;
            padding: 8px 14px;
            font-size: 14px;
            margin: var(--spacing-sm) 0;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        .gemini-btn:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transform: translateY(-1px);
        }
        .gemini-loading {
            font-size: 13px;
            color: var(--primary-blue-dark);
            margin: var(--spacing-sm) 0;
        }


        /* Animations and UI Effects */
        @keyframes pulse {
            0% {
                background: #fff3e0;
            }
            50% {
                background: #ffe0b2;
            }
            100% {
                background: #fff3e0;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* Status Message */
        .extraction-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px 20px;
            border-radius: var(--border-radius-xl);
            box-shadow: var(--shadow-xl);
            display: none;
            z-index: 1000;
            max-width: 400px; /* For longer validation messages */
            word-wrap: break-word; /* Wrap long quotes */
        }

        .extraction-status.show {
            display: block;
            animation: slideUp var(--transition-normal);
        }

        /* Loading Spinner */
        .loading-spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            display: none;
            background-color: rgba(255, 255, 255, 0.7); /* Optional overlay */
            padding: 20px;
            border-radius: var(--border-radius-lg);
        }

        .loading-spinner.active {
            display: block;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Settings Modal */
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .settings-modal.active {
            display: flex;
        }

        .settings-content {
            background: white;
            padding: var(--spacing-xl);
            border-radius: var(--border-radius-xl);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow-xl);
        }

        .settings-content h2 {
            margin-top: 0;
            border-bottom: 2px solid var(--primary-blue);
            padding-bottom: var(--spacing-sm);
        }

        .settings-group {
            margin-bottom: var(--spacing-lg);
            padding: var(--spacing-md);
            background: var(--gray-100);
            border-radius: var(--border-radius-md);
        }

        .settings-group h3 {
            margin-top: 0;
            font-size: 16px;
            color: var(--gray-800);
        }

        .settings-group label {
            display: block;
            font-size: 13px;
            margin-bottom: var(--spacing-xs);
            color: var(--gray-600);
        }

        .settings-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--gray-400);
            border-radius: var(--border-radius-md);
            font-size: 13px;
            font-family: monospace;
            box-sizing: border-box;
        }

        .settings-group .help-text {
            font-size: 11px;
            color: var(--gray-500);
            margin-top: 4px;
            line-height: 1.4;
        }

        .settings-actions {
            display: flex;
            gap: var(--spacing-sm);
            justify-content: flex-end;
            margin-top: var(--spacing-lg);
        }

        .key-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: var(--border-radius-sm);
            font-size: 11px;
            margin-left: var(--spacing-xs);
        }

        .key-status.configured {
            background: var(--success-green);
            color: white;
        }

        .key-status.missing {
            background: var(--error-red);
            color: white;
        }

        .security-warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-left: 4px solid #ff9800;
            padding: var(--spacing-md);
            border-radius: var(--border-radius-md);
            margin: var(--spacing-lg) 0;
            font-size: 12px;
            line-height: 1.6;
        }

        .security-warning h4 {
            margin: 0 0 var(--spacing-xs) 0;
            color: #856404;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .security-warning p {
            margin: var(--spacing-xs) 0;
            color: #856404;
        }

        .security-warning ul {
            margin: var(--spacing-xs) 0;
            padding-left: 20px;
            color: #856404;
        }

        .security-warning li {
            margin: 3px 0;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Form Panel (Left) -->
        <div class="form-panel">
            <h1>Clinical Study Master Extraction</h1>
            <p class="subtitle">
                Click a field, then highlight text in the PDF to extract with full traceability.
            </p>

            <!-- Progress Bar -->
            <div id="progress-bar-container">
                <div id="progress-bar"></div>
            </div>

            <!-- Main Form -->
            <form id="extraction-form">
                <!-- Step 1: Study ID -->
                <div class="step active" id="step-1">
                    <h2>Step 1: Study ID</h2>
                    <div class="form-group">
                        <label for="citation">Full Citation (Required)</label>
                        <div class="ai-field-group">
                            <textarea id="citation" name="citation" class="linked-input" placeholder="Paste citation or title, then click ‚ú®" required></textarea>
                            <button type="button" class="gemini-btn" title="Find Metadata with AI Search" onclick="findMetadata()" style="padding: 8px 12px; margin: 0; font-size: 14px;">‚ú®</button>
                        </div>
                        <div id="metadata-loading" class="gemini-loading" style="display: none;">‚ú® Searching for metadata...</div>
                    </div>
                    <div class="grid-2col">
                        <div class="form-group">
                            <label for="doi">DOI</label>
                            <input type="text" id="doi" name="doi" class="linked-input" data-validation="doi">
                            <span class="validation-message">Invalid DOI format</span>
                        </div>
                        <div class="form-group">
                            <label for="pmid">PMID</label>
                            <input type="text" id="pmid" name="pmid" class="linked-input" data-validation="pmid">
                            <span class="validation-message">PMID must be numeric</span>
                        </div>
                    </div>
                    <div class="grid-3col">
                        <div class="form-group">
                            <label for="journal">Journal</label>
                            <input type="text" id="journal" name="journal" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="year">Year</label>
                            <input type="number" id="year" name="year" class="linked-input" data-validation="year">
                            <span class="validation-message">Invalid year (1900-2100)</span>
                        </div>
                        <div class="form-group">
                            <label for="country">Country</label>
                            <input type="text" id="country" name="country" class="linked-input">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="centers">Centers (e.g., Single, Multi)</label>
                        <input type="text" id="centers" name="centers" class="linked-input">
                    </div>
                    <div class="form-group">
                        <label for="funding">Funding Sources</label>
                        <textarea id="funding" name="funding" class="linked-input"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="conflicts">Conflicts of Interest</label>
                        <textarea id="conflicts" name="conflicts" class="linked-input"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="registration">Trial Registration ID</label>
                        <input type="text" id="registration" name="registration" class="linked-input">
                    </div>
                </div>

                <!-- Step 2: PICO-T -->
                <div class="step" id="step-2">
                    <h2>Step 2: PICO-T</h2>
                    <button type="button" class="gemini-btn" onclick="generatePICO()">‚ú® Generate PICO-T Summary</button>
                    <div id="pico-loading" class="gemini-loading" style="display: none;">‚ú® Generating PICO-T...</div>

                    <div class="form-group">
                        <label for="eligibility-population">Population</label>
                        <div class="ai-field-group">
                            <textarea id="eligibility-population" name="eligibility-population" class="linked-input"></textarea>
                            <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-population')">‚úì</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="eligibility-intervention">Intervention</label>
                        <div class="ai-field-group">
                            <textarea id="eligibility-intervention" name="eligibility-intervention" class="linked-input"></textarea>
                            <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-intervention')">‚úì</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="eligibility-comparator">Comparator</label>
                        <div class="ai-field-group">
                        <textarea id="eligibility-comparator" name="eligibility-comparator" class="linked-input"></textarea>
                            <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-comparator')">‚úì</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="eligibility-outcomes">Outcomes Measured</label>
                        <div class="ai-field-group">
                            <textarea id="eligibility-outcomes" name="eligibility-outcomes" class="linked-input"></textarea>
                            <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-outcomes')">‚úì</button>
                        </div>
                    </div>
                    <div class="grid-2col">
                        <div class="form-group">
                            <label for="eligibility-timing">Timing/Follow-up</label>
                            <div class="ai-field-group">
                                <input type="text" id="eligibility-timing" name="eligibility-timing" class="linked-input">
                                <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-timing')">‚úì</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="eligibility-type">Study Type (e.g., RCT, Cohort)</label>
                             <div class="ai-field-group">
                                <input type="text" id="eligibility-type" name="eligibility-type" class="linked-input">
                                <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('eligibility-type')">‚úì</button>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="inclusion-met">Inclusion Criteria Met?</label>
                        <select id="inclusion-met" name="inclusion-met" required>
                            <option value="">Select...</option>
                            <option value="true">Yes</option>
                            <option value="false">No (Stop Extraction)</option>
                        </select>
                    </div>
                </div>

                <!-- Step 3: Baseline -->
                <div class="step" id="step-3">
                    <h2>Step 3: Baseline</h2>
                    <h3>Sample Size</h3>
                    <div class="grid-3col">
                        <div class="form-group">
                            <label for="totalN">Total N (Required)</label>
                            <input type="number" id="totalN" name="totalN" class="linked-input" required>
                        </div>
                        <div class="form-group">
                            <label for="surgicalN">Surgical N</label>
                            <input type="number" id="surgicalN" name="surgicalN" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="controlN">Control N</label>
                            <input type="number" id="controlN" name="controlN" class="linked-input">
                        </div>
                    </div>
                    <h3>Age Demographics</h3>
                    <div class="dynamic-container">
                        <div class="grid-2col">
                            <div class="form-group">
                                <label for="ageMean">Age Mean</label>
                                <input type="number" step="0.1" id="ageMean" name="ageMean" class="linked-input">
                            </div>
                            <div class="form-group">
                                <label for="ageSD">Age SD</label>
                                <input type="number" step="0.1" id="ageSD" name="ageSD" class="linked-input">
                            </div>
                        </div>
                        <div class="grid-3col">
                            <div class="form-group">
                                <label for="ageMedian">Age Median</label>
                                <input type="number" step="0.1" id="ageMedian" name="ageMedian" class="linked-input">
                            </div>
                            <div class="form-group">
                                <label for="ageIQR_lower">Age IQR (Lower/Q1)</label>
                                <input type="number" step="0.1" id="ageIQR_lower" name="ageIQR_lower" class="linked-input">
                            </div>
                            <div class="form-group">
                                <label for="ageIQR_upper">Age IQR (Upper/Q3)</label>
                                <input type="number" step="0.1" id="ageIQR_upper" name="ageIQR_upper" class="linked-input">
                            </div>
                        </div>
                    </div>
                    <h3>Gender</h3>
                    <div class="grid-2col">
                        <div class="form-group">
                            <label for="maleN">Male N</label>
                            <input type="number" id="maleN" name="maleN" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="femaleN">Female N</label>
                            <input type="number" id="femaleN" name="femaleN" class="linked-input">
                        </div>
                    </div>
                    <h3>Baseline Clinical Scores</h3>
                    <div class="grid-3col">
                        <div class="form-group">
                            <label for="prestrokeMRS">Pre-stroke mRS</label>
                            <input type="number" step="0.1" id="prestrokeMRS" name="prestrokeMRS" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="nihssMean">NIHSS Mean/Median</label>
                            <input type="number" step="0.1" id="nihssMean" name="nihssMean" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="gcsMean">GCS Mean/Median</label>
                            <input type="number" step="0.1" id="gcsMean" name="gcsMean" class="linked-input">
                        </div>
                    </div>
                </div>

                <!-- Step 4: Imaging -->
                <div class="step" id="step-4">
                    <h2>Step 4: Imaging</h2>
                    <div class="form-group">
                        <label for="vascularTerritory">Vascular Territory</label>
                        <input type="text" id="vascularTerritory" name="vascularTerritory" class="linked-input">
                    </div>
                    <div class="grid-2col">
                        <div class="form-group">
                            <label for="infarctVolume">Infarct Volume</label>
                            <input type="number" step="0.1" id="infarctVolume" name="infarctVolume" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="strokeVolumeCerebellum">Stroke Volume (Cerebellum)</label>
                            <input type="text" id="strokeVolumeCerebellum" name="strokeVolumeCerebellum" class="linked-input">
                        </div>
                    </div>
                    <h3>Edema Dynamics</h3>
                    <div class="form-group">
                        <label for="edemaDynamics">Edema Description</label>
                        <textarea id="edemaDynamics" name="edemaDynamics" class="linked-input"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="peakSwellingWindow">Peak Swelling Window</label>
                        <input type="text" id="peakSwellingWindow" name="peakSwellingWindow" class="linked-input">
                    </div>
                    <h3>Involvement Areas</h3>
                    <div class="grid-3col">
                        <div class="form-group">
                            <label for="brainstemInvolvement">Brainstem Involvement?</label>
                            <select id="brainstemInvolvement" name="brainstemInvolvement">
                                <option value="null">Unknown</option>
                                <option value="true">Yes</option>
                                <option value="false">No</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="supratentorialInvolvement">Supratentorial?</label>
                            <select id="supratentorialInvolvement" name="supratentorialInvolvement">
                                <option value="null">Unknown</option>
                                <option value="true">Yes</option>
                                <option value="false">No</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="nonCerebellarStroke">Non-cerebellar?</label>
                            <select id="nonCerebellarStroke" name="nonCerebellarStroke">
                                <option value="null">Unknown</option>
                                <option value="true">Yes</option>
                                <option value="false">No</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Step 5: Interventions -->
                <div class="step" id="step-5">
                    <h2>Step 5: Interventions</h2>
                    <h3>Surgical Indications</h3>
                    <div id="indications-container"></div>
                    <button type="button" class="add-btn" onclick="addIndication()">+ Add Indication</button>
                    <h3>Interventions</h3>
                    <div id="interventions-container"></div>
                    <button type="button" class="add-btn" onclick="addIntervention()">+ Add Intervention Type</button>
                </div>

                <!-- Step 6: Study Arms -->
                <div class="step" id="step-6">
                    <h2>Step 6: Study Arms</h2>
                    <p class="subtitle">Define the distinct groups for comparison.</p>
                    <div id="arms-container"></div>
                    <button type="button" class="add-btn" onclick="addArm()">+ Add Study Arm</button>
                </div>

                <!-- Step 7: Outcomes -->
                <div class="step" id="step-7">
                    <h2>Step 7: Outcomes</h2>
                    <h3>Mortality Data</h3>
                    <div id="mortality-global-container"></div>
                    <button type="button" class="add-btn" onclick="addMortality()">+ Add Mortality Data</button>
                    <h3>Modified Rankin Scale (mRS)</h3>
                    <div id="mrs-global-container"></div>
                    <button type="button" class="add-btn" onclick="addMRS()">+ Add mRS Data</button>
                </div>

                <!-- Step 8: Complications -->
                <div class="step" id="step-8">
                    <h2>Step 8: Complications</h2>
                    <h3>Complications</h3>
                    <div id="complications-container"></div>
                    <button type="button" class="add-btn" onclick="addComplication()">+ Add Complication</button>
                    
                    <h3>Predictors of Outcome</h3>
                    <div class="form-group">
                        <label for="predictorsPoorOutcomeSurgical">Summary of Key Findings / Predictors</label>
                        <button type="button" class="gemini-btn" onclick="generateSummary()">‚ú® Summarize Key Findings</button>
                        <div id="summary-loading" class="gemini-loading" style="display: none;">‚ú® Generating Summary...</div>
                        <div class="ai-field-group">
                            <textarea id="predictorsPoorOutcomeSurgical" name="predictorsPoorOutcomeSurgical" class="linked-input" rows="6"></textarea>
                            <button type="button" class="validate-btn" title="Validate with AI" onclick="validateFieldWithAI('predictorsPoorOutcomeSurgical')">‚úì</button>
                        </div>
                    </div>
                    <h4>Predictor Analysis</h4>
                    <div id="predictors-container"></div>
                    <button type="button" class="add-btn" onclick="addPredictor()">+ Add Predictor</button>
                </div>
            </form>

            <!-- Navigation -->
            <div class="navigation">
                <div id="step-indicator">Step 1 of 8</div>
                <div>
                    <button id="prev-btn" disabled>Previous</button>
                    <button id="next-btn">Next</button>
                    <div id="submit-btn-group" class="hidden">
                        <button id="submit-gsheets-btn" onclick="handleSubmitToGoogleSheets(event)">Save to Google Sheets</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- PDF Panel (Center) -->
        <div class="pdf-panel">
            <div class="pdf-toolbar">
                <button id="pdf-upload-btn">üìÑ Load PDF</button>
                <input type="file" id="pdf-file" accept=".pdf" aria-label="Upload PDF file">
                <button id="pdf-prev-page" aria-label="Previous Page">‚óÑ</button>
                <span class="toolbar-text">
                    Page <input type="number" id="page-num" value="1" min="1" aria-label="Page number">
                    of <span id="total-pages">0</span>
                </span>
                <button id="pdf-next-page" aria-label="Next Page">‚ñ∫</button>
                <select id="zoom-level" aria-label="Zoom level">
                    <option value="0.75">75%</option>
                    <option value="1" selected>100%</option>
                    <option value="1.25">125%</option>
                    <option value="1.5">150%</option>
                </select>
                <button id="fit-width">Fit Width</button>
                <button id="region-mode-btn" class="selection-mode-toggle" onclick="toggleRegionMode()" title="Toggle Region Selection Mode">üî≤ Region</button>
                <button id="image-mode-btn" class="selection-mode-toggle" onclick="toggleImageMode()" title="Toggle Image Capture Mode">üì∑ Image</button>
                <button id="import-annotations-btn" onclick="importPDFAnnotations()" title="Import PDF Annotations">üìù Annotations</button>
                <button id="settings-btn" onclick="openSettings()" title="Configure API Keys">‚öôÔ∏è Settings</button>
                <span id="active-field-indicator">No field selected</span>
            </div>
            <div id="pdf-container" class="pdf-container">
                <div id="upload-area" class="upload-area" role="button" tabindex="0" aria-label="Upload PDF Area">
                    <h3>üìÑ Drop PDF file here or click to browse</h3>
                    <label for="pdf-file-2" class="upload-link">
                        Select PDF File
                    </label>
                    <input type="file" id="pdf-file-2" accept=".pdf" aria-label="Upload PDF file (alternative)">
                </div>
                <div id="pdf-pages" style="display: none;" aria-live="polite">
                    <!-- PDF pages will be rendered here -->
                </div>
            </div>
        </div>

        <!-- Trace Panel (Right) -->
        <div class="trace-panel">
            <h2 class="trace-title">Extraction Trace Log</h2>
            <div class="markdown-section">
                <h4>üìù Markdown Assistant</h4>
                <button onclick="document.getElementById('markdown-file').click()">Load Markdown</button>
                <button onclick="toggleSearchInterface()">Search Text</button>
                <input type="file" id="markdown-file" accept=".md,.txt" aria-label="Upload markdown file">
                <div id="markdown-status">No markdown file loaded.</div>
                <div id="search-interface" class="search-interface">
                    <label for="search-query" class="hidden">Search Query</label>
                    <textarea id="search-query" placeholder="Paste or type text to search in PDF..."></textarea>
                    <button onclick="searchInPDF()" class="full-width">üîç Find in PDF</button>
                    <div id="search-results" class="search-results" aria-live="polite">
                        <!-- Search results will appear here -->
                    </div>
                </div>
            </div>
            <div class="export-section">
                <h4>Export Options</h4>
                <div class="export-buttons">
                    <button onclick="exportJSON()" class="export-json">üìÑ JSON</button>
                    <button onclick="exportCSV()" class="export-csv">üìä CSV</button>
                    <button onclick="exportAudit()" class="export-audit">üìã Audit</button>
                    <button onclick="exportAnnotatedPDF()" class="export-pdf">üìë PDF</button>
                </div>
            </div>
            <div class="stats-container">
                <div class="stats-row">
                    <span>Total Extractions:</span>
                    <strong id="extraction-count">0</strong>
                </div>
                <div class="stats-row">
                    <span>Pages with Data:</span>
                    <strong id="pages-with-data">0</strong>
                </div>
            </div>
            <div id="trace-log" aria-live="polite">
                <!-- Trace log entries will appear here -->
            </div>
        </div>
    </div>

    <!-- Status Message -->
    <div id="extraction-status" class="extraction-status" role="alert" aria-live="assertive">
        <span id="status-message"></span>
    </div>

    <!-- Loading Spinner -->
    <div class="loading-spinner" id="loading-spinner" role="status" aria-label="Loading">
        <div class="spinner"></div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="settings-modal" role="dialog" aria-labelledby="settings-title">
        <div class="settings-content">
            <h2 id="settings-title">‚öôÔ∏è Application Settings</h2>
            
            <div class="settings-group">
                <h3>ü§ñ AI Provider <span id="ai-status" class="key-status missing">Not Configured</span></h3>
                <label for="ai-provider">AI Provider</label>
                <select id="ai-provider" onchange="updateProviderFields()">
                    <option value="gemini">Google Gemini (Recommended)</option>
                    <option value="anthropic">Anthropic Claude</option>
                    <option value="openai">OpenAI GPT-4</option>
                </select>
                <p class="help-text">Select the AI provider for PICO-T generation, summaries, and validation.</p>
                
                <label for="ai-api-key" style="margin-top: 15px;">API Key</label>
                <input type="password" id="ai-api-key" placeholder="Enter your AI API key">
                <p class="help-text" id="ai-help-text">
                    Get Gemini key from: <a href="https://makersuite.google.com/app/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio</a>
                </p>
            </div>

            <div class="settings-group">
                <h3>üìä Google Sheets Integration <span id="sheets-status" class="key-status missing">Not Configured</span></h3>
                <label for="google-client-id">OAuth Client ID</label>
                <input type="text" id="google-client-id" placeholder="123456789-abc.apps.googleusercontent.com">
                <p class="help-text">Get from: <a href="https://console.cloud.google.com/apis/credentials" target="_blank" rel="noopener">Google Cloud Console</a> ‚Üí OAuth 2.0 Client ID</p>
                
                <label for="google-sheet-id" style="margin-top: 15px;">Google Sheet ID</label>
                <input type="text" id="google-sheet-id" placeholder="1BxiMVs0XRA5nFMdKv...">
                <p class="help-text">From your sheet URL: docs.google.com/spreadsheets/d/<strong>[SHEET_ID]</strong>/edit</p>
            </div>

            <!-- Security Notice -->
            <div class="security-warning">
                <h4>üîê Security & Privacy Notice</h4>
                <p><strong>API Key Storage:</strong> Your API keys are stored in browser localStorage using Base64 encoding. This is <strong>NOT encryption</strong> - it only obfuscates the data.</p>
                <p><strong>What this means:</strong></p>
                <ul>
                    <li>Keys can be accessed via browser DevTools (F12 ‚Üí Application ‚Üí localStorage)</li>
                    <li>Browser extensions may be able to read localStorage</li>
                    <li>Keys persist until you clear browser data or click "Clear All"</li>
                </ul>
                <p><strong>Best Practices:</strong></p>
                <ul>
                    <li>Don't use this on shared or public computers</li>
                    <li>Use API keys with usage limits and monitoring</li>
                    <li>Clear settings when done: Click "Clear All" button</li>
                    <li>For better security, clear browser data after each session</li>
                </ul>
                <p><strong>Data Privacy:</strong> All PDF processing happens locally in your browser. No data is sent to external servers except when using AI features (PDF text sent to selected AI provider) or Google Sheets export.</p>
            </div>

            <!-- Session Management -->
            <div class="settings-group">
                <h3>üíæ Session Management <span id="session-status" class="key-status missing">No Session</span></h3>
                <p class="help-text">Your work is automatically saved as you type. Sessions persist across browser refreshes.</p>

                <div id="session-info" style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px; font-size: 12px;">
                    <p style="margin: 0;">
                        <strong>Last saved:</strong> <span id="session-timestamp">Never</span>
                    </p>
                    <p style="margin: 5px 0 0 0;">
                        <strong>Current step:</strong> <span id="session-step">N/A</span>
                    </p>
                </div>

                <button onclick="clearSessionData()" style="margin-top: 10px; padding: 8px 15px; background: var(--error-red); color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">
                    üóëÔ∏è Clear Session Data
                </button>
                <p class="help-text" style="margin-top: 5px;">This will clear your saved form data and progress. API keys and extraction history are not affected.</p>
            </div>

            <div class="settings-actions">
                <button onclick="closeSettings()" style="background: var(--gray-500);">Cancel</button>
                <button onclick="clearSettings()" style="background: var(--error-red);">Clear All</button>
                <button onclick="saveSettings()" style="background: var(--success-green);">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Main Application Logic (Bundled/Simplified) -->
    <script type="module">
        // ============================================================================
        // CONFIGURATION SECTION
        // ============================================================================
        // Configure your API keys and Google Sheets integration below
        // All features work without API keys except:
        //   - AI-powered PICO-T generation
        //   - AI summary generation
        //   - AI field validation
        //   - Metadata search (uses Google Search grounding)
        //   - Google Sheets export
        // ============================================================================
        
        const CONFIG = {
            // ============================================================================
            // STEP 1: ADD YOUR API KEYS HERE
            // ============================================================================
            
            // GEMINI API KEY - Required for AI features
            // Get from: https://makersuite.google.com/app/apikey
            // Features: PICO-T generation, summaries, validation, metadata search
            // Example: "AIzaSyD7qwertyuiop_1234567890abcdefghijk"
            GEMINI_API_KEY: "PASTE_YOUR_GEMINI_API_KEY_HERE",
            
            // GOOGLE CLOUD API KEY - Currently unused (reserved for future features)
            // Get from: https://console.cloud.google.com
            // Go to: APIs & Services > Credentials > Create Credentials > API Key
            // Example: "AIzaSyA9876543210zyxwvutsrqponmlkjihgfedcba"
            GOOGLE_API_KEY: "PASTE_YOUR_GOOGLE_API_KEY_HERE",
            
            // GOOGLE OAUTH CLIENT ID - Required for Google Sheets export
            // Get from: https://console.cloud.google.com
            // Go to: APIs & Services > Credentials > Create Credentials > OAuth 2.0 Client ID
            // Application type: Web application
            // Authorized JavaScript origins: http://localhost:8000
            // Example: "123456789-abcdefghijklmnop.apps.googleusercontent.com"
            GOOGLE_CLIENT_ID: "PASTE_YOUR_CLIENT_ID_HERE.apps.googleusercontent.com",
            
            // GOOGLE SHEET ID - Your destination Google Sheet
            // From your Google Sheet URL: docs.google.com/spreadsheets/d/{SHEET_ID}/edit
            // Required tabs: "Submissions" and "Extractions"
            // Example: "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms"
            GOOGLE_SHEET_ID: "PASTE_YOUR_SHEET_ID_HERE",
            
            // Google Sheets API scope (do not modify)
            GOOGLE_SCOPES: "https://www.googleapis.com/auth/spreadsheets"
            
            // ============================================================================
            // SETUP INSTRUCTIONS:
            // 1. Fill in the API keys above
            // 2. Save this file
            // 3. Run a local server: python -m http.server 8000
            // 4. Open in browser: http://localhost:8000/Clinical_Study_Extraction.html
            // 5. Load a PDF and start extracting!
            // ============================================================================
        };
        
        const PDFConfig = {
            workerSrc: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js',
            documentOptions: {
                cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/cmaps/',
                cMapPacked: true,
                password: ''
            }
        };


        // ============================================================================
        // PDF ANNOTATION MANAGER (Using pdf-lib)
        // ============================================================================
        
        const PDFAnnotationManager = {
            annotations: [],
            
            async addHighlight(params) {
                const annotation = {
                    id: `anno_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: 'highlight',
                    pageNum: params.pageNum,
                    x: params.x,
                    y: params.y,
                    width: params.width,
                    height: params.height,
                    color: params.color || '#FFFF00',
                    fieldName: params.fieldName,
                    text: params.text,
                    timestamp: new Date().toISOString()
                };
                
                this.annotations.push(annotation);
                this.renderAnnotationOverlay(annotation);
                return annotation;
            },
            
            renderAnnotationOverlay(annotation) {
                const state = AppStateManager.getState();
                if (state.currentPage !== annotation.pageNum) return;
                
                const highlightLayer = document.getElementById('highlight-layer');
                if (!highlightLayer) return;
                
                const highlight = document.createElement('div');
                highlight.className = 'pdf-highlight';
                highlight.id = annotation.id;
                Object.assign(highlight.style, {
                    position: 'absolute',
                    left: `${annotation.x}px`,
                    top: `${annotation.y}px`,
                    width: `${annotation.width}px`,
                    height: `${annotation.height}px`,
                    backgroundColor: this.hexToRgba(annotation.color, 0.3),
                    border: `2px solid ${annotation.color}`,
                    pointerEvents: 'auto',
                    cursor: 'pointer'
                });
                highlight.title = `${annotation.fieldName}: ${annotation.text.substring(0, 50)}...`;
                highlight.onclick = () => {
                    if (confirm('Remove this highlight?')) {
                        this.removeAnnotation(annotation.id);
                    }
                };
                highlightLayer.appendChild(highlight);
            },
            
            renderCurrentPageAnnotations() {
                const state = AppStateManager.getState();
                const highlightLayer = document.getElementById('highlight-layer');
                if (!highlightLayer) return;
                highlightLayer.innerHTML = '';
                this.annotations
                    .filter(anno => anno.pageNum === state.currentPage)
                    .forEach(anno => this.renderAnnotationOverlay(anno));
            },
            
            removeAnnotation(annotationId) {
                this.annotations = this.annotations.filter(a => a.id !== annotationId);
                const element = document.getElementById(annotationId);
                if (element) element.remove();
                StatusManager.show('Highlight removed', 'info', 2000);
            },
            
            async exportAnnotatedPDF() {
                const state = AppStateManager.getState();
                if (!state.pdfBlob) {
                    StatusManager.show('No PDF loaded to annotate', 'warning');
                    return;
                }
                StatusManager.showLoading(true);
                StatusManager.show('Creating annotated PDF...', 'info');
                try {
                    const arrayBuffer = await state.pdfBlob.arrayBuffer();
                    const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                    const annotationsByPage = {};
                    this.annotations.forEach(anno => {
                        if (!annotationsByPage[anno.pageNum]) annotationsByPage[anno.pageNum] = [];
                        annotationsByPage[anno.pageNum].push(anno);
                    });
                    for (const [pageNum, annos] of Object.entries(annotationsByPage)) {
                        const pageIndex = parseInt(pageNum) - 1;
                        const page = pdfDoc.getPage(pageIndex);
                        const { height } = page.getSize();
                        annos.forEach(anno => {
                            const pdfY = height - anno.y - anno.height;
                            const color = this.hexToRgb(anno.color);
                            page.drawRectangle({
                                x: anno.x,
                                y: pdfY,
                                width: anno.width,
                                height: anno.height,
                                borderColor: PDFLib.rgb(color.r, color.g, color.b),
                                borderWidth: 2,
                                color: PDFLib.rgb(color.r, color.g, color.b),
                                opacity: 0.3
                            });
                            page.drawText(anno.fieldName, {
                                x: anno.x,
                                y: pdfY + anno.height + 5,
                                size: 8,
                                color: PDFLib.rgb(1, 0, 0)
                            });
                        });
                    }
                    const pdfBytes = await pdfDoc.save();
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `annotated_${state.documentName}`;
                    a.click();
                    URL.revokeObjectURL(url);
                    StatusManager.showLoading(false);
                    StatusManager.show('‚úì Annotated PDF exported', 'success');
                } catch (error) {
                    console.error('PDF Annotation Export Error:', error);
                    StatusManager.showLoading(false);
                    StatusManager.show(`Export failed: ${error.message}`, 'error');
                }
            },
            
            async createExtractionWithHighlight(fieldName, text, pageNum, coords) {
                const extraction = ExtractionTracker.addExtraction({
                    fieldName: fieldName,
                    text: text,
                    page: pageNum,
                    method: 'manual',
                    coordinates: coords
                });
                await this.addHighlight({
                    pageNum: pageNum,
                    x: coords.x,
                    y: coords.y,
                    width: coords.width,
                    height: coords.height,
                    color: this.getColorForField(fieldName),
                    fieldName: fieldName,
                    text: text
                });
                return extraction;
            },
            
            getColorForField(fieldName) {
                const colorMap = {
                    citation: '#FFD700', doi: '#87CEEB', pmid: '#90EE90',
                    population: '#FFB6C1', intervention: '#DDA0DD', comparator: '#F0E68C',
                    outcome: '#FFA07A', default: '#FFFF00'
                };
                for (const [key, color] of Object.entries(colorMap)) {
                    if (fieldName.toLowerCase().includes(key)) return color;
                }
                return colorMap.default;
            },
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16) / 255,
                    g: parseInt(result[2], 16) / 255,
                    b: parseInt(result[3], 16) / 255
                } : { r: 1, g: 1, b: 0 };
            },
            
            hexToRgba(hex, alpha) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                if (!result) return `rgba(255, 255, 0, ${alpha})`;
                const r = parseInt(result[1], 16);
                const g = parseInt(result[2], 16);
                const b = parseInt(result[3], 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            },
            
            getAllAnnotations() {
                return this.annotations;
            },
            
            clearAllAnnotations() {
                this.annotations = [];
                const highlightLayer = document.getElementById('highlight-layer');
                if (highlightLayer) highlightLayer.innerHTML = '';
                StatusManager.show('All highlights cleared', 'info');
            }
        };
        
        window.PDFAnnotationManager = PDFAnnotationManager;

        // ============================================================================
        // REGION SELECTION MANAGER - Feature 1: Region-based Text Selection
        // ============================================================================
        
        const RegionSelectionManager = {
            mode: false,
            startPoint: null,
            currentBox: null,
            listeners: [],
            
            enable() {
                this.mode = true;
                const btn = document.getElementById('region-mode-btn');
                btn?.classList.add('active');
                
                // Add event listeners to PDF page
                const pdfContainer = document.getElementById('pdf-container');
                if (!pdfContainer) return;
                
                const mouseDownHandler = (e) => this.handleMouseDown(e);
                const mouseMoveHandler = (e) => this.handleMouseMove(e);
                const mouseUpHandler = (e) => this.handleMouseUp(e);
                
                pdfContainer.addEventListener('mousedown', mouseDownHandler);
                pdfContainer.addEventListener('mousemove', mouseMoveHandler);
                pdfContainer.addEventListener('mouseup', mouseUpHandler);
                
                // Store listeners for cleanup
                this.listeners = [
                    { element: pdfContainer, type: 'mousedown', handler: mouseDownHandler },
                    { element: pdfContainer, type: 'mousemove', handler: mouseMoveHandler },
                    { element: pdfContainer, type: 'mouseup', handler: mouseUpHandler }
                ];
                
                // Change cursor
                pdfContainer.style.cursor = 'crosshair';
            },
            
            disable() {
                this.mode = false;
                const btn = document.getElementById('region-mode-btn');
                btn?.classList.remove('active');
                
                // Remove event listeners
                this.listeners.forEach(({ element, type, handler }) => {
                    element.removeEventListener(type, handler);
                });
                this.listeners = [];
                
                // Reset cursor
                const pdfContainer = document.getElementById('pdf-container');
                if (pdfContainer) pdfContainer.style.cursor = '';
                
                // Remove any active box
                this.removeCurrentBox();
            },
            
            handleMouseDown(e) {
                if (!this.mode) return;
                
                // Check if clicking on the PDF page itself
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const containerBounds = e.currentTarget.getBoundingClientRect();
                
                // Calculate position relative to page
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                // Only start if clicking within page bounds
                if (x >= 0 && x <= pageBounds.width && y >= 0 && y <= pageBounds.height) {
                    this.startPoint = { x, y };
                    this.createBox(x, y);
                }
            },
            
            handleMouseMove(e) {
                if (!this.mode || !this.startPoint || !this.currentBox) return;
                
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                // Update box dimensions
                const width = Math.abs(x - this.startPoint.x);
                const height = Math.abs(y - this.startPoint.y);
                const left = Math.min(x, this.startPoint.x);
                const top = Math.min(y, this.startPoint.y);
                
                this.currentBox.style.left = left + 'px';
                this.currentBox.style.top = top + 'px';
                this.currentBox.style.width = width + 'px';
                this.currentBox.style.height = height + 'px';
            },
            
            async handleMouseUp(e) {
                if (!this.mode || !this.startPoint || !this.currentBox) return;
                
                const state = AppStateManager.getState();
                if (!state.activeField) {
                    StatusManager.show('Please select a form field first', 'warning');
                    this.removeCurrentBox();
                    this.startPoint = null;
                    return;
                }
                
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                // Calculate final rectangle
                const width = Math.abs(x - this.startPoint.x);
                const height = Math.abs(y - this.startPoint.y);
                const left = Math.min(x, this.startPoint.x);
                const top = Math.min(y, this.startPoint.y);
                
                // Minimum size check (prevent accidental clicks)
                if (width < 10 || height < 10) {
                    this.removeCurrentBox();
                    this.startPoint = null;
                    return;
                }
                
                const region = { x: left, y: top, width, height };
                
                // Extract text from region
                StatusManager.showLoading(true);
                try {
                    const extractedText = await this.extractTextFromRegion(region, state.currentPage);
                    
                    if (!extractedText || extractedText.trim().length === 0) {
                        StatusManager.show('No text found in selected region', 'warning');
                        this.removeCurrentBox();
                        this.startPoint = null;
                        return;
                    }
                    
                    // Create extraction record
                    const sanitizedText = SecurityUtils.sanitizeText(extractedText);
                    const extraction = ExtractionTracker.addExtraction({
                        fieldName: state.activeField,
                        text: sanitizedText,
                        page: state.currentPage,
                        coordinates: region,
                        method: 'region',
                        documentName: state.documentName
                    });
                    
                    if (extraction && state.activeFieldElement) {
                        const element = state.activeFieldElement;
                        if (element.type === 'number') {
                            const match = sanitizedText.match(/-?\d+(\.\d+)?/);
                            element.value = match ? match[0] : '';
                        } else {
                            element.value = sanitizedText;
                        }
                        element.classList.add('has-extraction');
                    }
                    
                    if (extraction) {
                        addExtractionMarker(extraction);
                        StatusManager.show(`‚úì Extracted ${extractedText.length} chars from region`, 'success');
                        autoAdvanceField();
                    }
                    
                } catch (error) {
                    console.error('Region extraction error:', error);
                    StatusManager.show(`Region extraction failed: ${error.message}`, 'error');
                } finally {
                    StatusManager.showLoading(false);
                    this.removeCurrentBox();
                    this.startPoint = null;
                }
            },
            
            createBox(x, y) {
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                // Remove any existing box
                this.removeCurrentBox();
                
                // Create new selection box
                const box = document.createElement('div');
                box.className = 'region-selection-box';
                box.style.left = x + 'px';
                box.style.top = y + 'px';
                box.style.width = '0px';
                box.style.height = '0px';
                
                pageDiv.appendChild(box);
                this.currentBox = box;
            },
            
            removeCurrentBox() {
                if (this.currentBox) {
                    this.currentBox.remove();
                    this.currentBox = null;
                }
            },
            
            async extractTextFromRegion(region, pageNum) {
                const state = AppStateManager.getState();
                if (!state.pdfDoc) return '';
                
                try {
                    const page = await state.pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const viewport = page.getViewport({ scale: state.scale });
                    
                    // Filter text items within region bounds
                    const itemsInRegion = [];
                    
                    textContent.items.forEach(item => {
                        if (!item.str || !item.transform) return;
                        
                        // Get item position and dimensions
                        const tx = window.pdfjsLib.Util.transform(viewport.transform, item.transform);
                        const itemX = tx[4];
                        const itemY = tx[5];
                        const fontSize = Math.sqrt((tx[0] * tx[0]) + (tx[1] * tx[1]));
                        const itemWidth = item.width * tx[0];
                        const itemHeight = fontSize;
                        
                        // Check if item overlaps with region
                        const overlapsX = itemX < region.x + region.width && itemX + itemWidth > region.x;
                        const overlapsY = itemY < region.y + region.height && itemY + itemHeight > region.y;
                        
                        if (overlapsX && overlapsY) {
                            itemsInRegion.push({
                                text: item.str,
                                x: itemX,
                                y: itemY,
                                width: itemWidth,
                                height: itemHeight
                            });
                        }
                    });
                    
                    if (itemsInRegion.length === 0) return '';
                    
                    // Sort items for proper reading order (top to bottom, left to right)
                    itemsInRegion.sort((a, b) => {
                        // Group by rows (Y proximity within 5px)
                        const rowDiff = Math.abs(a.y - b.y);
                        if (rowDiff < 5) {
                            return a.x - b.x; // Same row, sort by X
                        }
                        return a.y - b.y; // Different rows, sort by Y
                    });
                    
                    // Detect if this is a table (multiple columns)
                    const isTable = this.detectTableStructure(itemsInRegion);
                    
                    if (isTable) {
                        return this.extractTableText(itemsInRegion);
                    } else {
                        // Simple concatenation with spaces
                        return itemsInRegion.map(item => item.text).join(' ');
                    }
                    
                } catch (error) {
                    console.error('Text extraction error:', error);
                    throw error;
                }
            },
            
            detectTableStructure(items) {
                if (items.length < 4) return false; // Too few items for a table
                
                // Group items by Y coordinate (rows)
                const rows = [];
                let currentRow = [items[0]];
                
                for (let i = 1; i < items.length; i++) {
                    const prevItem = items[i - 1];
                    const currItem = items[i];
                    
                    // Same row if Y difference < 5px
                    if (Math.abs(currItem.y - prevItem.y) < 5) {
                        currentRow.push(currItem);
                    } else {
                        rows.push(currentRow);
                        currentRow = [currItem];
                    }
                }
                rows.push(currentRow);
                
                // Table detected if:
                // 1. Multiple rows (at least 2)
                // 2. Consistent column count across rows
                if (rows.length < 2) return false;
                
                const colCounts = rows.map(row => row.length);
                const avgCols = colCounts.reduce((a, b) => a + b, 0) / colCounts.length;
                
                // Consider it a table if most rows have similar column counts
                return avgCols >= 2;
            },
            
            extractTableText(items) {
                // Group items by rows
                const rows = [];
                let currentRow = [items[0]];
                
                for (let i = 1; i < items.length; i++) {
                    const prevItem = items[i - 1];
                    const currItem = items[i];
                    
                    if (Math.abs(currItem.y - prevItem.y) < 5) {
                        currentRow.push(currItem);
                    } else {
                        rows.push(currentRow);
                        currentRow = [currItem];
                    }
                }
                rows.push(currentRow);
                
                // Format as tab-separated values (preserves structure)
                const formattedRows = rows.map(row => {
                    return row.map(item => item.text).join('\t');
                });
                
                return formattedRows.join('\n');
            }
        };
        
        /**
         * Toggle region selection mode
         */
        window.toggleRegionMode = function() {
            if (RegionSelectionManager.mode) {
                RegionSelectionManager.disable();
                StatusManager.show('Region selection mode disabled', 'info');
            } else {
                RegionSelectionManager.enable();
                StatusManager.show('üî≤ Region mode: Draw a box to extract text', 'info', 5000);
            }
        };

        // ============================================================================
        // IMAGE EXTRACTION MANAGER - Feature 4: Image Capture from PDF
        // ============================================================================
        
        const ImageExtractionManager = {
            mode: false,
            startPoint: null,
            currentBox: null,
            listeners: [],
            capturedCanvas: null,
            
            enable() {
                // Disable region mode if active
                if (RegionSelectionManager.mode) {
                    RegionSelectionManager.disable();
                }
                
                this.mode = true;
                const btn = document.getElementById('image-mode-btn');
                btn?.classList.add('active');
                
                const pdfContainer = document.getElementById('pdf-container');
                if (!pdfContainer) return;
                
                const mouseDownHandler = (e) => this.handleMouseDown(e);
                const mouseMoveHandler = (e) => this.handleMouseMove(e);
                const mouseUpHandler = (e) => this.handleMouseUp(e);
                
                pdfContainer.addEventListener('mousedown', mouseDownHandler);
                pdfContainer.addEventListener('mousemove', mouseMoveHandler);
                pdfContainer.addEventListener('mouseup', mouseUpHandler);
                
                this.listeners = [
                    { element: pdfContainer, type: 'mousedown', handler: mouseDownHandler },
                    { element: pdfContainer, type: 'mousemove', handler: mouseMoveHandler },
                    { element: pdfContainer, type: 'mouseup', handler: mouseUpHandler }
                ];
                
                pdfContainer.style.cursor = 'crosshair';
            },
            
            disable() {
                this.mode = false;
                const btn = document.getElementById('image-mode-btn');
                btn?.classList.remove('active');
                
                this.listeners.forEach(({ element, type, handler }) => {
                    element.removeEventListener(type, handler);
                });
                this.listeners = [];
                
                const pdfContainer = document.getElementById('pdf-container');
                if (pdfContainer) pdfContainer.style.cursor = '';
                
                this.removeCurrentBox();
            },
            
            handleMouseDown(e) {
                if (!this.mode) return;
                
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                if (x >= 0 && x <= pageBounds.width && y >= 0 && y <= pageBounds.height) {
                    this.startPoint = { x, y };
                    this.createBox(x, y);
                }
            },
            
            handleMouseMove(e) {
                if (!this.mode || !this.startPoint || !this.currentBox) return;
                
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                const width = Math.abs(x - this.startPoint.x);
                const height = Math.abs(y - this.startPoint.y);
                const left = Math.min(x, this.startPoint.x);
                const top = Math.min(y, this.startPoint.y);
                
                this.currentBox.style.left = left + 'px';
                this.currentBox.style.top = top + 'px';
                this.currentBox.style.width = width + 'px';
                this.currentBox.style.height = height + 'px';
            },
            
            async handleMouseUp(e) {
                if (!this.mode || !this.startPoint || !this.currentBox) return;
                
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                const pageBounds = pageDiv.getBoundingClientRect();
                const x = e.clientX - pageBounds.left;
                const y = e.clientY - pageBounds.top;
                
                const width = Math.abs(x - this.startPoint.x);
                const height = Math.abs(y - this.startPoint.y);
                const left = Math.min(x, this.startPoint.x);
                const top = Math.min(y, this.startPoint.y);
                
                // Minimum size check
                if (width < 50 || height < 50) {
                    StatusManager.show('Selection too small (minimum 50x50px)', 'warning');
                    this.removeCurrentBox();
                    this.startPoint = null;
                    return;
                }
                
                const region = { x: left, y: top, width, height };
                
                try {
                    StatusManager.showLoading(true);
                    StatusManager.show('üì∑ Capturing image...', 'info');
                    
                    const canvas = await this.captureRegion(region);
                    this.capturedCanvas = canvas;
                    
                    // Auto-download as PNG (high quality)
                    const dataUrl = canvas.toDataURL('image/png', 1.0);
                    const filename = `figure_p${AppStateManager.getState().currentPage}_${Date.now()}.png`;
                    
                    // Download image
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = filename;
                    a.click();
                    
                    // Create extraction record with thumbnail
                    const state = AppStateManager.getState();
                    const extraction = ExtractionTracker.addExtraction({
                        fieldName: state.activeField || 'Image Capture',
                        text: `[Image: ${filename}]`,
                        page: state.currentPage,
                        coordinates: region,
                        method: 'image',
                        imageData: dataUrl,
                        documentName: state.documentName
                    });
                    
                    if (extraction) {
                        StatusManager.show(`‚úì Image saved: ${filename}`, 'success');
                    }
                    
                } catch (error) {
                    console.error('Image capture error:', error);
                    StatusManager.show(`Image capture failed: ${error.message}`, 'error');
                } finally {
                    StatusManager.showLoading(false);
                    this.removeCurrentBox();
                    this.startPoint = null;
                }
            },
            
            createBox(x, y) {
                const pageDiv = document.querySelector('.pdf-page');
                if (!pageDiv) return;
                
                this.removeCurrentBox();
                
                const box = document.createElement('div');
                box.className = 'image-selection-box';
                box.style.left = x + 'px';
                box.style.top = y + 'px';
                box.style.width = '0px';
                box.style.height = '0px';
                
                pageDiv.appendChild(box);
                this.currentBox = box;
            },
            
            removeCurrentBox() {
                if (this.currentBox) {
                    this.currentBox.remove();
                    this.currentBox = null;
                }
            },
            
            async captureRegion(region) {
                const state = AppStateManager.getState();
                if (!state.pdfDoc) throw new Error('No PDF loaded');
                
                const page = await state.pdfDoc.getPage(state.currentPage);
                const viewport = page.getViewport({ scale: state.scale });
                
                // Create canvas for the selected region with high-DPI support
                const dpr = window.devicePixelRatio || 1;
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = Math.floor(region.width * dpr);
                canvas.height = Math.floor(region.height * dpr);
                canvas.style.width = region.width + 'px';
                canvas.style.height = region.height + 'px';
                
                // Render full page to temporary canvas
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = Math.floor(viewport.width * dpr);
                tempCanvas.height = Math.floor(viewport.height * dpr);
                
                const transform = [dpr, 0, 0, dpr, 0, 0];
                
                await page.render({
                    canvasContext: tempCtx,
                    viewport: viewport,
                    transform: transform
                }).promise;
                
                // Crop to selected region
                ctx.drawImage(
                    tempCanvas,
                    region.x * dpr,
                    region.y * dpr,
                    region.width * dpr,
                    region.height * dpr,
                    0,
                    0,
                    region.width * dpr,
                    region.height * dpr
                );
                
                return canvas;
            }
        };
        
        /**
         * Toggle image capture mode
         */
        window.toggleImageMode = function() {
            if (ImageExtractionManager.mode) {
                ImageExtractionManager.disable();
                StatusManager.show('Image capture mode disabled', 'info');
            } else {
                ImageExtractionManager.enable();
                StatusManager.show('üì∑ Image mode: Draw a box to capture a figure/image', 'info', 5000);
            }
        };


        // --- CLIENTS ---
        let gapiLoaded = false;
        let gapiTokenClient;
        window.gapiLoaded = () => { gapiLoaded = true; console.log("Google API client loaded."); };
        window.gisLoaded = () => {
            if (CONFIG.GOOGLE_CLIENT_ID) {
                gapiTokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CONFIG.GOOGLE_CLIENT_ID,
                    scope: CONFIG.GOOGLE_SCOPES,
                    callback: '', // Callback is set dynamically on click
                });
                console.log("Google Auth client initialized.");
            } else {
                console.warn("Google Client ID missing. 'Save to Google Sheets' will not work.");
            }
        };
        // Load Google scripts dynamically
        (function() {
            const gapiScript = document.createElement('script');
            gapiScript.src = 'https://apis.google.com/js/api.js?onload=gapiLoaded';
            gapiScript.async = true;
            gapiScript.defer = true;
            document.head.appendChild(gapiScript);

            const gisScript = document.createElement('script');
            gisScript.src = 'https://accounts.google.com/gsi/client?onload=gisLoaded';
            gisScript.async = true;
            gisScript.defer = true;
            document.head.appendChild(gisScript);
        })();


        // --- Core Modules (Simplified Implementations) ---

        // AppState (Observer Pattern Approximation)
        let AppState = {
            pdfDoc: null,
            pdfBlob: null, // Original file for export
            currentPage: 1,
            totalPages: 0,
            scale: 1.0,
            activeField: null,
            activeFieldElement: null,
            documentName: '',
            extractions: [],
            currentStep: 0,
            totalSteps: 8,
            markdownContent: '',
            markdownLoaded: false,
            pdfTextCache: new Map(),
            searchMarkers: [],
            maxCacheSize: 50,
            isProcessing: false,
            lastSubmissionId: null
        };
        const subscribers = new Set();
        const AppStateManager = {
            getState: () => ({ ...AppState }), // Return a copy
            setState: (updates) => {
                AppState = { ...AppState, ...updates };
                subscribers.forEach(cb => cb(AppState));
            },
            subscribe: (cb) => {
                subscribers.add(cb);
                return () => subscribers.delete(cb);
            }
        };

        // StatusManager
        const StatusManager = {
             statusDiv: document.getElementById('extraction-status'),
             messageSpan: document.getElementById('status-message'),
             spinnerDiv: document.getElementById('loading-spinner'),
             timeoutId: null, // Store timeout ID
             show: function(message, type = 'info', duration = 3000) {
                if (!this.statusDiv || !this.messageSpan) return;
                // Clear existing timeout if any
                if (this.timeoutId) clearTimeout(this.timeoutId);

                this.messageSpan.textContent = message;
                this.statusDiv.className = 'extraction-status show';
                const colors = { success: '#4CAF50', warning: '#FF9800', error: '#f44336', info: '#2196F3' };
                this.statusDiv.style.background = colors[type] || colors.info;
                this.statusDiv.style.color = 'white';

                this.timeoutId = setTimeout(() => {
                    this.statusDiv?.classList.remove('show');
                    this.timeoutId = null; // Clear the stored ID
                }, duration);
             },
            showLoading: function(show) {
                this.spinnerDiv?.classList.toggle('active', show);
            }
        };

        // SecurityUtils
        const SecurityUtils = {
            sanitizeText: (text) => {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                 // Basic sanitization: remove tags, trim, limit length
                return div.innerHTML.replace(/<[^>]*>?/gm, '').trim().substring(0, 10000);
            },
             validateExtraction: (extraction) => {
                // Simplified validation
                return extraction && extraction.fieldName && extraction.text && extraction.coordinates && extraction.page >= 0; // Page 0 for AI
            },
            escapeHtml: (text) => {
                if (typeof text !== 'string') return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },
            validateInput: (input) => {
                const validationType = input.dataset.validation;
                const value = input.value.trim();

                if (input.required && !value) {
                    return { valid: false, message: 'This field is required' };
                }

                if (validationType === 'doi' && value) {
                    const doiRegex = /^10\.\d{4,}\/-?[A-Za-z0-9._;()/:]+$/; // Accepts some special characters
                    if (!doiRegex.test(value)) return { valid: false, message: 'Invalid DOI format' };
                }
                if (validationType === 'pmid' && value) {
                    if (!/^\d+$/.test(value)) return { valid: false, message: 'PMID must be numeric' };
                }
                 if (validationType === 'year' && value) {
                    const year = parseInt(value);
                    if (isNaN(year) || year < 1900 || year > 2100) return { valid: false, message: 'Invalid year (1900-2100)' };
                }

                return { valid: true };
            },
             // Encode/Decode for localStorage (simplified for preview - no actual encryption)
            encodeData: (data) => btoa(JSON.stringify(data)),
            decodeData: (encodedData) => JSON.parse(atob(encodedData))
        };

         // MemoryManager (Simplified - just basic cleanup)
        const MemoryManager = {
            listeners: [],
            timeouts: [],
            registerEventListener: function(el, type, handler) {
                el.addEventListener(type, handler);
                this.listeners.push({ el, type, handler });
            },
            registerTimeout: function(id) {
                this.timeouts.push(id);
            },
            cleanup: function() {
                this.listeners.forEach(({ el, type, handler }) => el.removeEventListener(type, handler));
                this.timeouts.forEach(id => clearTimeout(id));
                this.listeners = [];
                this.timeouts = [];
                console.log("Cleanup performed (simplified)");
            }
        };
        window.addEventListener('beforeunload', () => MemoryManager.cleanup());


        // --- PDF Modules ---
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = PDFConfig.workerSrc;

        /**
         * PDFLoader - Handles loading and initializing PDF documents
         * Validates API keys, loads PDF with PDF.js, and initializes the viewer
         */
        const PDFLoader = {
            loadPDF: async (file) => {
                // Validate file input
                if (!file) {
                    StatusManager.show('No file selected', 'error');
                    return;
                }
                
                if (file.type !== 'application/pdf') {
                    StatusManager.show('Please select a valid PDF file', 'error');
                    return;
                }
                
                // Check file size (warn if > 50MB)
                const maxSize = 50 * 1024 * 1024; // 50MB
                if (file.size > maxSize) {
                    if (!confirm(`Large file (${Math.round(file.size / 1024 / 1024)}MB). This may take a while. Continue?`)) {
                        return;
                    }
                }
                
                AppStateManager.setState({ isProcessing: true });
                StatusManager.showLoading(true);
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // Validate Gemini API key for AI features (non-blocking)
                    const geminiApiKey = CONFIG.GEMINI_API_KEY; 
                    if (!geminiApiKey || geminiApiKey === "PASTE_YOUR_GEMINI_API_KEY_HERE") {
                        console.warn("Gemini API Key not configured. AI features will be disabled.");
                        StatusManager.show("Note: AI features require Gemini API key configuration", "warning", 5000);
                    }
                    
                    // Load PDF with PDF.js
                    StatusManager.show('Loading PDF...', 'info');
                    const pdfDoc = await window.pdfjsLib.getDocument({
                        data: arrayBuffer,
                        ...PDFConfig.documentOptions
                    }).promise;
                    
                    const sanitizedName = SecurityUtils.sanitizeText(file.name);

                    AppStateManager.setState({
                        pdfDoc,
                        pdfBlob: file, // Store original file for export
                        totalPages: pdfDoc.numPages,
                        documentName: sanitizedName,
                        isProcessing: false,
                        pdfTextCache: new Map() // Clear cache on new load
                    });

                    document.getElementById('total-pages').textContent = pdfDoc.numPages.toString();
                    document.getElementById('upload-area').style.display = 'none';
                    document.getElementById('pdf-pages').style.display = 'block';

                    StatusManager.showLoading(false);
                    StatusManager.show(`‚úì PDF loaded: ${sanitizedName} (${pdfDoc.numPages} pages)`, 'success');
                    await PDFRenderer.renderPage(1); // Render first page after load
                    return pdfDoc;
                } catch (error) {
                    console.error("PDF Load Error:", error);
                    StatusManager.showLoading(false);
                    
                    // Provide user-friendly error messages
                    let errorMessage = 'Failed to load PDF';
                    if (error.message?.includes('password')) {
                        errorMessage = 'PDF is password-protected. Please unlock it first.';
                    } else if (error.message?.includes('Invalid PDF')) {
                        errorMessage = 'Invalid or corrupted PDF file.';
                    } else if (error.name === 'AbortError') {
                        errorMessage = 'PDF loading was cancelled.';
                    } else {
                        errorMessage += `: ${error.message || 'Unknown error'}`;
                    }
                    
                    StatusManager.show(errorMessage, 'error');
                    AppStateManager.setState({ isProcessing: false });
                    throw error;
                }
            }
        };

        const TextSelection = {
            // ============================================================================
            // PHASE 4: NATIVE BROWSER SELECTION API
            // ============================================================================
            enableNativeSelection: (textLayer, pageNum) => {
                // Use native browser selection for better UX
                textLayer.addEventListener('mouseup', (e) => {
                    const state = AppStateManager.getState();
                    
                    // Check if a field is active
                    if (!state.activeField) {
                        StatusManager.show('Please select a form field first', 'warning');
                        window.getSelection().removeAllRanges(); // Clear selection
                        return;
                    }

                    // Get native browser selection
                    const selection = window.getSelection();
                    if (!selection || selection.rangeCount === 0) return;

                    const selectedText = selection.toString().trim();
                    if (!selectedText) return;

                    try {
                        // Get selection boundaries
                        const range = selection.getRangeAt(0);
                        const rects = range.getClientRects();
                        
                        if (rects.length === 0) return;

                        // Get text layer bounding box
                        const textLayerRect = textLayer.getBoundingClientRect();
                        
                        // Calculate bounding box for all selection rectangles
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        
                        for (let i = 0; i < rects.length; i++) {
                            const rect = rects[i];
                            minX = Math.min(minX, rect.left - textLayerRect.left);
                            minY = Math.min(minY, rect.top - textLayerRect.top);
                            maxX = Math.max(maxX, rect.right - textLayerRect.left);
                            maxY = Math.max(maxY, rect.bottom - textLayerRect.top);
                        }

                        const coordinates = {
                            x: Math.round(minX),
                            y: Math.round(minY),
                            width: Math.round(maxX - minX),
                            height: Math.round(maxY - minY)
                        };

                        // Sanitize and extract
                        const sanitizedText = SecurityUtils.sanitizeText(selectedText);
                        
                        const extraction = ExtractionTracker.addExtraction({
                            fieldName: state.activeField,
                            text: sanitizedText,
                            page: pageNum,
                            coordinates: coordinates,
                            method: 'manual',
                            documentName: state.documentName
                        });

                        if (extraction && state.activeFieldElement) {
                            const element = state.activeFieldElement;
                            if (element.type === 'number') {
                                const match = sanitizedText.match(/-?\d+(\.\d+)?/);
                                element.value = match ? match[0] : '';
                            } else {
                                element.value = sanitizedText;
                            }
                            element.classList.add('has-extraction');
                        }

                        if (extraction) {
                            addExtractionMarker(extraction);
                            StatusManager.show(`‚úì Extracted to ${state.activeField}`, 'success');
                            autoAdvanceField();
                            
                            // Visual feedback: mark extracted text
                            const selectedNodes = [];
                            const iterator = document.createNodeIterator(
                                range.commonAncestorContainer,
                                NodeFilter.SHOW_ELEMENT,
                                null
                            );
                            
                            let node;
                            while ((node = iterator.nextNode())) {
                                if (node.classList && node.classList.contains('textLayer') && node.tagName === 'SPAN') {
                                    selectedNodes.push(node);
                                }
                            }
                            
                            selectedNodes.forEach(node => {
                                node.classList.add('extracted');
                            });
                        } else {
                            StatusManager.show(`Extraction failed validation for ${state.activeField}`, 'error');
                        }

                        // Clear selection after extraction
                        selection.removeAllRanges();

                    } catch (error) {
                        console.error('Selection Error:', error);
                        StatusManager.show('Failed to process selection', 'error');
                    }
                });

                // Optional: Double-click to select word
                textLayer.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    // Browser handles word selection automatically
                });
            },
            
            // Keep old method for backwards compatibility (not used anymore)
            enable: (textLayer, textItems, pageNum) => {
                console.warn('TextSelection.enable() is deprecated. Use enableNativeSelection() instead.');
                TextSelection.enableNativeSelection(textLayer, pageNum);
            }
        };

        const PDFRenderer = {
            renderPage: async (pageNum) => {
                 const state = AppStateManager.getState();
                if (!state.pdfDoc || state.isProcessing) return;

                AppStateManager.setState({ isProcessing: true });
                StatusManager.showLoading(true);

                 try {
                    const page = await state.pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: state.scale });
                    const container = document.getElementById('pdf-pages');
                    if (!container) return;
                    container.innerHTML = ''; // Clear previous page

                    const pageDiv = document.createElement('div');
                    pageDiv.className = 'pdf-page';
                    pageDiv.style.width = viewport.width + 'px';
                    pageDiv.style.height = viewport.height + 'px';

                    // ============================================================================
                    // PHASE 2: HIGH-DPI CANVAS RENDERING
                    // ============================================================================
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    
                    // Support high-DPI displays (Retina, 4K, etc.)
                    const outputScale = window.devicePixelRatio || 1;
                    canvas.width = Math.floor(viewport.width * outputScale);
                    canvas.height = Math.floor(viewport.height * outputScale);
                    canvas.style.width = Math.floor(viewport.width) + 'px';
                    canvas.style.height = Math.floor(viewport.height) + 'px';

                    // Apply transform for high-DPI rendering
                    const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;

                    await page.render({
                        canvasContext: context,
                        viewport: viewport,
                        transform: transform
                    }).promise;
                    pageDiv.appendChild(canvas);

                    // Create highlight layer for annotations
                    const highlightLayer = document.createElement('div');
                    highlightLayer.id = 'highlight-layer';
                    highlightLayer.className = 'highlight-layer';
                    highlightLayer.style.position = 'absolute';
                    highlightLayer.style.left = '0';
                    highlightLayer.style.top = '0';
                    highlightLayer.style.width = viewport.width + 'px';
                    highlightLayer.style.height = viewport.height + 'px';
                    highlightLayer.style.pointerEvents = 'none';
                    pageDiv.appendChild(highlightLayer);

                    // ============================================================================
                    // PHASE 3 & 4: USE PDF.JS TEXT LAYER + NATIVE SELECTION API
                    // ============================================================================
                    const textContent = await page.getTextContent();
                    const textLayerDiv = document.createElement('div');
                    textLayerDiv.className = 'textLayer';
                    textLayerDiv.style.width = viewport.width + 'px';
                    textLayerDiv.style.height = viewport.height + 'px';

                    // Use PDF.js built-in renderTextLayer for perfect alignment
                    await window.pdfjsLib.renderTextLayer({
                        textContentSource: textContent,
                        container: textLayerDiv,
                        viewport: viewport,
                        textDivs: []
                    }).promise;

                    pageDiv.appendChild(textLayerDiv);

                    // Enable native browser selection with extraction on mouseup
                    TextSelection.enableNativeSelection(textLayerDiv, pageNum);
                    
                    addExtractionMarkersForPage(pageNum); // Use global helper
                    container.appendChild(pageDiv);

                    AppStateManager.setState({ currentPage: pageNum });
                    document.getElementById('page-num').value = pageNum.toString();
                    clearSearchMarkers(); // Use global helper

                 } catch (error) {
                    console.error("PDF Render Error:", error);
                    StatusManager.show(`Failed to render page ${pageNum}: ${error.message || 'Unknown error'}`, 'error');
                } finally {
                    // Render annotations for this page
                    PDFAnnotationManager.renderCurrentPageAnnotations();
                    
                    AppStateManager.setState({ isProcessing: false });
                    StatusManager.showLoading(false);
                }
            }
        };

        // --- Extraction Tracker ---
        const ExtractionTracker = {
            extractions: [],
            fieldMap: new Map(),
            init: function() {
                this.loadFromStorage();
            },
            addExtraction: function(data) {
                 const sanitizedData = {
                    ...data,
                    text: SecurityUtils.sanitizeText(data.text),
                    fieldName: SecurityUtils.sanitizeText(data.fieldName),
                    documentName: SecurityUtils.sanitizeText(data.documentName)
                };
                 const validationData = { ...sanitizedData, id: 'temp', timestamp: new Date().toISOString() };

                 if (!SecurityUtils.validateExtraction(validationData)) {
                    console.error('Invalid extraction data:', validationData);
                    return null;
                }


                const extraction = {
                    id: `ext_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    timestamp: new Date().toISOString(),
                    ...sanitizedData
                };
                this.extractions.push(extraction);
                this.fieldMap.set(data.fieldName, extraction);
                this.updateTraceLog(extraction);
                this.updateStats();
                this.saveToStorage();
                AppStateManager.setState({ extractions: this.extractions }); // Update global state
                return extraction;
            },
            updateTraceLog: function(extraction) {
                 const logContainer = document.getElementById('trace-log');
                 if (!logContainer) return;
                const entry = document.createElement('div');
                entry.className = 'trace-entry';
                entry.dataset.extractionId = extraction.id;
                entry.dataset.method = extraction.method; // For styling
                
                // Check if this is an image extraction
                if (extraction.method === 'image' && extraction.imageData) {
                    entry.innerHTML = `
                        <span class="field-label">üì∑ ${SecurityUtils.escapeHtml(extraction.fieldName)}</span>
                        <span class="extracted-text">"${SecurityUtils.escapeHtml(extraction.text)}"</span>
                        <img src="${extraction.imageData}" class="image-thumbnail" alt="Extracted image" 
                             onclick="event.stopPropagation(); window.open(this.src, '_blank')" 
                             title="Click to view full size">
                        <div class="metadata">
                            Page ${extraction.page} | ${extraction.method} | ${new Date(extraction.timestamp).toLocaleTimeString()}
                        </div>`;
                } else {
                    // Regular text extraction
                    const truncatedText = extraction.text.length > 80 ? extraction.text.substring(0, 80) + '...' : extraction.text;
                    entry.innerHTML = `
                        <span class="field-label">${SecurityUtils.escapeHtml(extraction.fieldName)}</span>
                        <span class="extracted-text">"${SecurityUtils.escapeHtml(truncatedText)}"</span>
                        <div class="metadata">
                            Page ${extraction.page} | ${extraction.method} | ${new Date(extraction.timestamp).toLocaleTimeString()}
                        </div>`;
                }
                
                 entry.onclick = () => this.navigateToExtraction(extraction);
                logContainer.insertBefore(entry, logContainer.firstChild);
            },
             navigateToExtraction: function(extraction) {
                // AI extractions don't have coordinates, just show text
                if (extraction.method !== 'manual') {
                    StatusManager.show(`AI Extraction: ${extraction.text}`, 'info', 5000);
                    return;
                }
                const state = AppStateManager.getState();
                if (extraction.page !== state.currentPage) {
                    PDFRenderer.renderPage(extraction.page);
                }
                // Add highlight effect after delay
                setTimeout(() => {
                    const marker = document.querySelector(`.extraction-marker[data-extraction-id="${extraction.id}"]`);
                    if (marker) {
                        marker.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        marker.style.background = 'rgba(255, 193, 7, 0.5)';
                        setTimeout(() => { marker.style.background = ''; }, 1000);
                    }
                }, 500);
            },
            updateStats: function() {
                document.getElementById('extraction-count').textContent = this.extractions.length;
                const uniquePages = new Set(this.extractions.map(e => e.page));
                document.getElementById('pages-with-data').textContent = uniquePages.size;
            },
            saveToStorage: function() {
                try {
                    localStorage.setItem('clinical_extractions_simple', JSON.stringify(this.extractions));
                } catch (e) { console.error("Save failed", e); }
            },
            loadFromStorage: function() {
                try {
                    const saved = localStorage.getItem('clinical_extractions_simple');
                    if (saved) {
                        this.extractions = JSON.parse(saved);
                        this.extractions.forEach(ext => {
                            this.fieldMap.set(ext.fieldName, ext);
                            this.updateTraceLog(ext); // Populate log on load
                        });
                        this.updateStats();
                        AppStateManager.setState({ extractions: this.extractions }); // Update global state
                    }
                } catch (e) { console.error("Load failed", e); this.extractions = []; }
            },
             getExtractions: function() { return this.extractions; } // Add getter
        };
        ExtractionTracker.init(); // Load saved data


        // --- Form Management ---
        const FormManager = {
            validator: SecurityUtils, // Use SecurityUtils directly for validation
            initialize: function() {
                this.initializeFormFields();
                this.initializeNavigation();
                DynamicFields.initialize(); // Initialize dynamic fields
                this.showStep(0);
            },
             initializeFormFields: function() {
                const inputs = document.querySelectorAll('.linked-input');
                inputs.forEach(input => {
                    // Use MemoryManager if available, otherwise basic listeners
                    const manager = window.MemoryManager || MemoryManager;
                    manager.registerEventListener(input, 'focus', () => {
                        document.querySelectorAll('.form-group').forEach(g => g.classList.remove('active-extraction'));
                        const fieldName = input.name || input.id;
                        AppStateManager.setState({ activeField: fieldName, activeFieldElement: input });
                        input.closest('.form-group')?.classList.add('active-extraction');
                        document.getElementById('active-field-indicator').textContent = `Extracting: ${fieldName}`;
                        document.getElementById('active-field-indicator').style.background = '#4CAF50';
                    });
                     manager.registerEventListener(input, 'blur', () => {
                        this.validateFieldUIUpdate(input);
                    });
                });
            },
            validateFieldUIUpdate: function(input) {
                const result = this.validator.validateInput(input);
                input.classList.toggle('validation-error', !result.valid);
                const messageEl = input.nextElementSibling;
                if (messageEl && messageEl.classList.contains('validation-message')) {
                    messageEl.textContent = result.valid ? '' : result.message;
                    messageEl.style.display = result.valid ? 'none' : 'block';
                }
                return result.valid;
            },
            initializeNavigation: function() {
                 document.getElementById('prev-btn').onclick = () => this.previousStep();
                 document.getElementById('next-btn').onclick = () => this.nextStep();
                 document.getElementById('submit-gsheets-btn').onclick = (e) => handleSubmitToGoogleSheets(e);
            },
            showStep: function(stepIndex) {
                 const steps = document.querySelectorAll('.step');
                 const state = AppStateManager.getState();
                 steps.forEach((step, index) => step.classList.toggle('active', index === stepIndex));
                 document.getElementById('prev-btn').disabled = (stepIndex === 0);
                 document.getElementById('step-indicator').textContent = `Step ${stepIndex + 1} of ${state.totalSteps}`;
                 const isLastStep = stepIndex === state.totalSteps - 1;
                 document.getElementById('next-btn').style.display = isLastStep ? 'none' : 'inline-block';
                 document.getElementById('submit-btn-group').style.display = isLastStep ? 'flex' : 'none';
                 document.querySelector('.form-panel').scrollTop = 0;
                 // Update progress bar
                 const progressBar = document.getElementById('progress-bar');
                 if (progressBar) {
                    const progress = ((stepIndex + 1) / state.totalSteps) * 100;
                    progressBar.style.width = progress + '%';
                 }
                 // Re-initialize fields in case dynamic ones were added
                 this.initializeFormFields();
                  // Update arm selectors if on relevant steps
                  if (stepIndex >= 6 && window.updateArmSelectors) {
                    window.updateArmSelectors();
                  }
            },
            nextStep: function() {
                 const state = AppStateManager.getState();
                
                 // --- VALIDATION LOGIC REMOVED ---
                 /*
                 const currentStepElement = document.getElementById(`step-${state.currentStep + 1}`);
                 let isValid = true;
                 currentStepElement.querySelectorAll('[required]').forEach(input => {
                    if (!input.value) {
                        isValid = false;
                        input.style.borderColor = 'red';
                    } else {
                        input.style.borderColor = ''; // Reset border color
                    }
                 });
                  // Also validate fields with data-validation
                  currentStepElement.querySelectorAll('[data-validation]').forEach(input => {
                      if (!this.validateFieldUIUpdate(input)) {
                          isValid = false;
                      }
                  });


                 if (!isValid) {
                    StatusManager.show('Please fill required fields and correct errors.', 'warning');
                    return;
                 }
                 */
                // --- END OF VALIDATION LOGIC ---


                // Check inclusion criteria on step 2 (this is a soft check, so it's fine to keep)
                if (state.currentStep === 1) {
                    const inclusionMet = document.getElementById('inclusion-met').value;
                    if (inclusionMet === 'false') {
                         // Use a simple confirm for preview, replace with modal in full app
                        if (!confirm('Study does not meet inclusion criteria according to your selection. Continue extraction anyway?')) {
                            return; // Stop navigation
                        }
                    }
                }

                if (state.currentStep < state.totalSteps - 1) {
                    const newStep = state.currentStep + 1;
                    AppStateManager.setState({ currentStep: newStep });
                    this.showStep(newStep);
                }
            },
            previousStep: function() {
                const state = AppStateManager.getState();
                if (state.currentStep > 0) {
                     const newStep = state.currentStep - 1;
                    AppStateManager.setState({ currentStep: newStep });
                    this.showStep(newStep);
                }
            },
             validateAllSteps: function() {
                let allValid = true;
                const steps = document.querySelectorAll('.step');
                steps.forEach((step, index) => {
                    step.querySelectorAll('[required], [data-validation]').forEach(input => {
                        if (!this.validateFieldUIUpdate(input)) {
                            allValid = false;
                        }
                    });
                });
                if (!allValid) {
                     StatusManager.show('Please correct errors on all steps before submitting.', 'warning');
                }
                return allValid;
             },
            collectFormData: function() {
                const formData = {};
                document.querySelectorAll('#extraction-form input, #extraction-form textarea, #extraction-form select').forEach(input => {
                    if (input.value) formData[input.name || input.id] = input.value;
                });
                return formData;
            }
        };

        // --- Dynamic Fields ---
        // Simplified dynamic fields logic for preview
        const DynamicFields = {
            counters: { indication: 0, intervention: 0, arm: 0, mortality: 0, mrs: 0, complication: 0, predictor: 0 },
            initialize: function() {
                 // Expose functions globally for HTML onclick
                 window.addIndication = () => this.addIndication();
                 window.addIntervention = () => this.addIntervention();
                 window.addArm = () => this.addArm();
                 window.addMortality = () => this.addMortality();
                 window.addMRS = () => this.addMRS();
                 window.addComplication = () => this.addComplication();
                 window.addPredictor = () => this.addPredictor();
                 window.removeElement = (btn) => this.removeElement(btn);
                 window.updateArmSelectors = () => this.updateArmSelectors(); // Ensure this is also global
            },
            addField: function(type, containerId) {
                 const container = document.getElementById(containerId);
                 if (!container) return;
                 const count = this.counters[type]++;
                 const div = document.createElement('div');
                 div.className = 'dynamic-container';
                 let htmlContent = '';

                 switch (type) {
                    case 'indication':
                        htmlContent = `
                            <h4>Indication ${count + 1}</h4>
                            <div class="grid-2col">
                                <div class="form-group">
                                    <label>Sign/Symptom</label>
                                    <select name="indication_sign_${count}" class="linked-input">
                                        <option value="">Select...</option>
                                        <option value="Drowsiness">Drowsiness</option>
                                        <option value="GCS_Drop">Drop in GCS</option>
                                        <option value="Imaging_Mass_Effect">Imaging signs of mass effect</option>
                                        <option value="Other">Other</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Count (N)</label>
                                    <input type="number" name="indication_count_${count}" class="linked-input">
                                </div>
                            </div>`;
                        break;
                    case 'intervention':
                        htmlContent = `
                            <h4>Intervention Type ${count + 1}</h4>
                            <div class="form-group"><label>Surgical Type</label><select name="intervention_type_${count}" class="linked-input"><option value="">Select...</option><option value="SDC_EVD">SDC + EVD</option><option value="SDC_ALONE">SDC Alone</option><option value="EVD_ALONE">EVD Alone</option></select></div>
                            <div class="form-group"><label>Time To Surgery (Hours)</label><input type="number" step="0.1" name="intervention_time_${count}" class="linked-input"></div>
                            <div class="form-group"><label>Duraplasty?</label><select name="intervention_duraplasty_${count}" class="linked-input"><option value="null">Unknown</option><option value="true">Yes</option><option value="false">No</option></select></div>`;
                        break;
                    case 'arm':
                        htmlContent = `
                            <h3>Study Arm ${count + 1}</h3>
                            <div class="grid-2col">
                                <div class="form-group"><label>Label</label><input type="text" name="arm_label_${count}" class="linked-input arm-label-input" oninput="updateArmSelectors()"></div>
                                <div class="form-group"><label>Sample Size (N)</label><input type="number" name="arm_n_${count}" class="linked-input"></div>
                            </div>`;
                        break;
                    case 'mortality':
                        htmlContent = `
                            <h4>Mortality Data Point ${count + 1}</h4>
                            <div class="grid-2col">
                                <div class="form-group"><label>Arm</label><select name="mortality_arm_${count}" class="arm-selector linked-input"></select></div>
                                <div class="form-group"><label>Timepoint</label><input type="text" name="mortality_tp_${count}" class="linked-input"></div>
                            </div>
                            <div class="grid-2col">
                                <div class="form-group"><label>Deaths (N)</label><input type="number" name="mortality_deaths_${count}" class="linked-input"></div>
                                <div class="form-group"><label>Total (N)</label><input type="number" name="mortality_total_${count}" class="linked-input"></div>
                            </div>`;
                        break;
                    case 'mrs':
                        htmlContent = `
                            <h4>mRS Data Point ${count + 1}</h4>
                            <div class="grid-2col">
                                <div class="form-group"><label>Arm</label><select name="mrs_arm_${count}" class="arm-selector linked-input"></select></div>
                                <div class="form-group"><label>Timepoint</label><input type="text" name="mrs_tp_${count}" class="linked-input"></div>
                            </div>
                            <h5>Distribution (Counts)</h5>
                            <div class="grid-mrs">
                                ${[0,1,2,3,4,5,6].map(i => `<div class="form-group"><label>${i}</label><input type="number" name="mrs_${i}_${count}" class="linked-input"></div>`).join('')}
                            </div>`;
                        break;
                    case 'complication':
                         htmlContent = `
                            <h4>Complication ${count + 1}</h4>
                            <div class="grid-2col">
                                <div class="form-group"><label>Description</label><input type="text" name="comp_desc_${count}" class="linked-input"></div>
                                <div class="form-group"><label>Arm</label><select name="comp_arm_${count}" class="arm-selector linked-input"></select></div>
                            </div>
                            <div class="form-group"><label>Count (N)</label><input type="number" name="comp_count_${count}" class="linked-input"></div>`;
                        break;
                    case 'predictor':
                         htmlContent = `
                            <h4>Predictor Analysis ${count + 1}</h4>
                            <div class="form-group"><label>Predictor Variable</label><input type="text" name="pred_var_${count}" class="linked-input"></div>
                            <div class="grid-3col">
                                <div class="form-group"><label>Effect Size (OR/HR)</label><input type="number" step="0.01" name="pred_effect_${count}" class="linked-input"></div>
                                <div class="form-group"><label>95% CI (Lower)</label><input type="number" step="0.01" name="pred_ci_lower_${count}" class="linked-input"></div>
                                <div class="form-group"><label>95% CI (Upper)</label><input type="number" step="0.01" name="pred_ci_upper_${count}" class="linked-input"></div>
                            </div>
                            <div class="form-group"><label>p-Value</label><input type="number" step="0.001" name="pred_pvalue_${count}" class="linked-input"></div>`;
                        break;
                }

                htmlContent += `<button type="button" class="remove-btn" onclick="removeElement(this)">Remove</button>`;
                div.innerHTML = htmlContent;

                 container.appendChild(div);
                 FormManager.initializeFormFields(); // Re-bind listeners for new fields
                 if (type === 'arm') this.updateArmSelectors(); // Update selectors if an arm was added
                 if (type === 'mortality' || type === 'mrs' || type === 'complication') this.updateArmSelectors(); // Update selectors for fields that use arms
            },
             addIndication: function() { this.addField('indication', 'indications-container'); },
             addIntervention: function() { this.addField('intervention', 'interventions-container'); },
             addArm: function() { this.addField('arm', 'arms-container'); },
             addMortality: function() { this.addField('mortality', 'mortality-global-container'); },
             addMRS: function() { this.addField('mrs', 'mrs-global-container'); },
             addComplication: function() { this.addField('complication', 'complications-container'); },
             addPredictor: function() { this.addField('predictor', 'predictors-container'); },
             removeElement: function(button) {
                button.closest('.dynamic-container')?.remove();
                this.updateArmSelectors();
            },
             updateArmSelectors: function() {
                const armLabels = Array.from(document.querySelectorAll('.arm-label-input'))
                    .map(input => input.value.trim())
                    .filter(Boolean);

                document.querySelectorAll('.arm-selector').forEach(select => {
                    const currentValue = select.value;
                    select.innerHTML = '<option value="">Select Arm...</option>'; // Clear existing options
                    armLabels.forEach(label => {
                        const option = new Option(label, label);
                        select.add(option);
                    });
                    // Try to reselect the previous value if it still exists
                    if (armLabels.includes(currentValue)) {
                        select.value = currentValue;
                    }
                });
            }
        };

        // --- Export Manager ---
        const ExportManager = {
            exportJSON: function() {
                const state = AppStateManager.getState();
                const formData = FormManager.collectFormData();
                const data = { document: state.documentName, exportDate: new Date().toISOString(), formData, extractions: ExtractionTracker.getExtractions() };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                this.downloadFile(blob, `extraction_${Date.now()}.json`);
                StatusManager.show('JSON export successful (Preview)', 'success');
            },
            exportCSV: function() {
                let csv = 'Field,Text,Page,X,Y,Width,Height,Timestamp\n';
                ExtractionTracker.getExtractions().forEach(ext => {
                     csv += `"${ext.fieldName}","${ext.text.replace(/"/g, '""')}",${ext.page},${ext.coordinates.x},${ext.coordinates.y},${ext.coordinates.width},${ext.coordinates.height},"${ext.timestamp}"\n`;
                });
                const blob = new Blob([csv], { type: 'text/csv' });
                this.downloadFile(blob, `extraction_${Date.now()}.csv`);
                StatusManager.show('CSV export successful (Preview)', 'success');
            },
            exportAudit: function() {
                 const formData = FormManager.collectFormData();
                 // Generate simplified HTML locally for preview
                 const state = AppStateManager.getState();
                 const extractions = ExtractionTracker.getExtractions();
                 let html = `<h1>Audit Report</h1><h2>Document: ${state.documentName}</h2><h3>Form Data</h3><ul>`;
                 Object.entries(formData).forEach(([key, value]) => html += `<li><b>${key}:</b> ${value}</li>`);
                 html += `</ul><h3>Extractions</h3>`;
                 extractions.forEach(ext => html += `<p><b>${ext.fieldName} (Page ${ext.page}):</b> "${ext.text}" <i>@ ${ext.timestamp}</i></p>`);
                 const blob = new Blob([html], { type: 'text/html' });
                 const url = URL.createObjectURL(blob);
                 window.open(url, '_blank');
                 setTimeout(() => URL.revokeObjectURL(url), 1000); // Clean up blob URL
                 StatusManager.show('Audit report generated (Preview)', 'success');
            },
             downloadFile: function(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a); // Required for Firefox
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(url), 1000); // Clean up blob URL
            }
        };

        // --- GEMINI API FUNCTIONS ---

        /**
         * Normalizes text for processing.
         * @param {string} text - The input text.
         * @returns {string} - The normalized text.
         */
        function normalizeText(text) {
            if (!text) return '';
            return text
                .replace(/\s+/g, ' ')
                .replace(/[\n\r]/g, ' ')
                .replace(/["\"]+/g, '"')
                .replace(/[\''\']+/g, "'")
                .trim()
                .toLowerCase();
        }

        /**
         * Gets text content from a specific PDF page, using cache if available.
         * @param {number} pageNum - The page number.
         * @returns {Promise<{fullText: string, items: Array<any>}>}
         */
        async function getPageText(pageNum) {
            const state = AppStateManager.getState();
            if (state.pdfTextCache.has(pageNum)) {
                return state.pdfTextCache.get(pageNum);
            }
            if (!state.pdfDoc) {
                throw new Error('No PDF loaded');
            }
            try {
                const page = await state.pdfDoc.getPage(pageNum);
                const textContent = await page.getTextContent();
                let fullText = '';
                const items = [];
                textContent.items.forEach(item => {
                    if (item.str) {
                        fullText += item.str + ' ';
                        items.push({ text: item.str, transform: item.transform });
                    }
                });
                const pageData = { fullText, items };
                // Simple cache management
                if (state.pdfTextCache.size >= state.maxCacheSize) {
                    const firstKey = state.pdfTextCache.keys().next().value;
                    if (firstKey) state.pdfTextCache.delete(firstKey);
                }
                state.pdfTextCache.set(pageNum, pageData);
                return pageData;
            } catch (error) {
                console.error(`Error getting text from page ${pageNum}:`, error);
                return { fullText: '', items: [] };
            }
        }
         
        /**
         * Calls the Gemini API with Google Search grounding.
         * @param {string} systemPrompt - The system instruction.
         * @param {string} userPrompt - The user query.
         * @param {object} jsonSchema - The JSON schema for the response.
         * @returns {Promise<string>} - The text content from the API response.
         */
        async function callGeminiWithSearch(systemPrompt, userPrompt, jsonSchema) {
            const apiKey = CONFIG.GEMINI_API_KEY; // API key is now from CONFIG
            if (!apiKey) {
                throw new Error("Gemini API Key is missing in CONFIG.GEMINI_API_KEY");
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
             
            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
                tools: [{ "google_search": {} }], // <-- ENABLE GOOGLE SEARCH
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: jsonSchema
                }
            };

            let attempt = 0;
            const maxAttempts = 5;
            let delay = 1000;

            while (attempt < maxAttempts) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorBody = await response.json();
                        throw new Error(`API Error ${response.status}: ${errorBody.error?.message || response.statusText}`);
                    }

                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                     
                    if (text) {
                        return text;
                    } else {
                        // Check for grounding metadata if text is missing (might contain valuable info)
                        const metadata = result.candidates?.[0]?.groundingMetadata;
                        console.log("Gemini response metadata:", metadata);
                        throw new Error("No text returned from Gemini API, but check console for metadata.");
                    }
                } catch (error) {
                    console.warn(`Gemini Search API call attempt ${attempt + 1} failed:`, error);
                    attempt++;
                    if (attempt >= maxAttempts) {
                        throw error; // Rethrow after last attempt
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                }
            }
            throw new Error("Gemini Search API call failed after all attempts.");
        }


        /**
         * ‚ú® Generates PICO-T summary using multi-provider AI support with PDF text.
         */
        async function generatePICO() {
            const state = AppStateManager.getState();
            if (!state.pdfDoc) {
                StatusManager.show('Please load a PDF first.', 'warning');
                return;
            }
            if (state.isProcessing) {
                StatusManager.show('Please wait for the current operation to finish.', 'warning');
                return;
            }

            AppStateManager.setState({ isProcessing: true });
            document.getElementById('pico-loading').style.display = 'block';
            
            const provider = AppState.aiProvider || 'gemini';
            StatusManager.show(`‚ú® Extracting PDF text and generating PICO-T with ${AIProviders[provider].name}...`, 'info');

            try {
                // Extract text from first 5 pages (usually contains methods/intro)
                let pdfText = '';
                const pagesToExtract = Math.min(5, state.totalPages);
                
                for (let i = 1; i <= pagesToExtract; i++) {
                    const pageData = await getPageText(i);
                    pdfText += pageData.fullText + '\n';
                }

                const systemPrompt = "You are an expert clinical research assistant. Extract PICO-T information from the provided clinical study text and return it as a JSON object. Be concise and accurate. If information is not found, return an empty string for that field.";
                const userPrompt = `From the following clinical study text, extract PICO-T information:\n\n${pdfText.substring(0, 30000)}\n\nRespond with JSON containing: population, intervention, comparator, outcomes, timing, studyType`;
                
                const picoSchema = {
                    type: "OBJECT",
                    properties: {
                        "population": { "type": "STRING", "description": "The study population" },
                        "intervention": { "type": "STRING", "description": "The intervention performed" },
                        "comparator": { "type": "STRING", "description": "The comparison group" },
                        "outcomes": { "type": "STRING", "description": "The primary outcomes measured" },
                        "timing": { "type": "STRING", "description": "The follow-up timing" },
                        "studyType": { "type": "STRING", "description": "The type of study" }
                    }
                };

                // Use multi-provider AI call
                const responseText = await AIProviders.callAI(systemPrompt, userPrompt, picoSchema);
                const data = JSON.parse(responseText);

                // Populate fields
                document.getElementById('eligibility-population').value = data.population || '';
                document.getElementById('eligibility-intervention').value = data.intervention || '';
                document.getElementById('eligibility-comparator').value = data.comparator || '';
                document.getElementById('eligibility-outcomes').value = data.outcomes || '';
                document.getElementById('eligibility-timing').value = data.timing || '';
                document.getElementById('eligibility-type').value = data.studyType || '';
                 
                // Add to trace log
                const coords = { x: 0, y: 0, width: 0, height: 0 };
                const method = `${provider}-pico`;
                if (data.population) ExtractionTracker.addExtraction({ fieldName: 'population (AI)', text: data.population, page: 0, coordinates: coords, method, documentName: state.documentName });
                if (data.intervention) ExtractionTracker.addExtraction({ fieldName: 'intervention (AI)', text: data.intervention, page: 0, coordinates: coords, method, documentName: state.documentName });
                if (data.comparator) ExtractionTracker.addExtraction({ fieldName: 'comparator (AI)', text: data.comparator, page: 0, coordinates: coords, method, documentName: state.documentName });
                if (data.outcomes) ExtractionTracker.addExtraction({ fieldName: 'outcomes (AI)', text: data.outcomes, page: 0, coordinates: coords, method, documentName: state.documentName });
                if (data.timing) ExtractionTracker.addExtraction({ fieldName: 'timing (AI)', text: data.timing, page: 0, coordinates: coords, method, documentName: state.documentName });
                if (data.studyType) ExtractionTracker.addExtraction({ fieldName: 'studyType (AI)', text: data.studyType, page: 0, coordinates: coords, method, documentName: state.documentName });

                StatusManager.show(`‚ú® PICO-T fields auto-populated by ${AIProviders[provider].name}!`, 'success');

            } catch (error) {
                console.error("AI PICO-T Error:", error);
                StatusManager.show(`AI extraction failed: ${error.message}`, 'error');
            } finally {
                AppStateManager.setState({ isProcessing: false });
                document.getElementById('pico-loading').style.display = 'none';
            }
        }
         
        /**
         * ‚ú® Generates a summary of key findings using multi-provider AI support with PDF text.
         */
        async function generateSummary() {
            const state = AppStateManager.getState();
            if (!state.pdfDoc) {
                StatusManager.show('Please load a PDF first.', 'warning');
                return;
            }
            if (state.isProcessing) {
                StatusManager.show('Please wait for the current operation to finish.', 'warning');
                return;
            }

            AppStateManager.setState({ isProcessing: true });
            document.getElementById('summary-loading').style.display = 'block';
            
            const provider = AppState.aiProvider || 'gemini';
            StatusManager.show(`‚ú® Extracting PDF text and generating summary with ${AIProviders[provider].name}...`, 'info');

            try {
                // Extract text from all pages
                let pdfText = '';
                
                for (let i = 1; i <= state.totalPages; i++) {
                    const pageData = await getPageText(i);
                    pdfText += pageData.fullText + '\n';
                }

                const systemPrompt = "You are an expert clinical research assistant. Your task is to write a concise summary (2-3 paragraphs) focusing on the key findings, outcomes, and any identified predictors of those outcomes from the provided clinical study text.";
                const userPrompt = `Summarize the key findings, outcomes, and predictors from this clinical study:\n\n${pdfText.substring(0, 50000)}`; // Limit text length
                
                // Use multi-provider AI call
                const summaryText = await AIProviders.callAI(systemPrompt, userPrompt);
                 
                if (!summaryText) {
                    throw new Error("No response from AI provider");
                }
                 
                document.getElementById('predictorsPoorOutcomeSurgical').value = summaryText;
                 
                // Add to trace log with provider-specific method
                const method = `${provider}-summary`;
                ExtractionTracker.addExtraction({ 
                    fieldName: 'summary (AI)', 
                    text: summaryText, 
                    page: 0, 
                    coordinates: {x:0, y:0, width:0, height:0}, 
                    method: method, 
                    documentName: state.documentName 
                });
                 
                StatusManager.show(`‚ú® Key findings summary generated by ${AIProviders[provider].name}!`, 'success');

            } catch (error) {
                console.error("AI Summary Error:", error);
                StatusManager.show(`AI summary failed: ${error.message}`, 'error');
            } finally {
                AppStateManager.setState({ isProcessing: false });
                document.getElementById('summary-loading').style.display = 'none';
            }
        }

        /**
         * ‚ú® Validates a field's content against the PDF text using multi-provider AI support.
         */
        async function validateFieldWithAI(fieldId) {
            const state = AppStateManager.getState();
            const field = document.getElementById(fieldId);
            if (!field) {
                StatusManager.show(`Field ${fieldId} not found.`, 'error');
                return;
            }
             
            const claim = field.value;
            if (!claim) {
                StatusManager.show('Field is empty, nothing to validate.', 'warning');
                return;
            }

            if (!state.pdfDoc) {
                StatusManager.show('Please load a PDF first.', 'warning');
                return;
            }
            if (state.isProcessing) {
                StatusManager.show('Please wait for the current operation to finish.', 'warning');
                return;
            }
             
            AppStateManager.setState({ isProcessing: true });
            StatusManager.showLoading(true);
            
            const provider = AppState.aiProvider || 'gemini';
            StatusManager.show(`‚ú® Validating claim with ${AIProviders[provider].name}: "${claim.substring(0, 30)}..."`, 'info');

            try {
                // Extract text from all pages
                let pdfText = '';
                
                for (let i = 1; i <= state.totalPages; i++) {
                    const pageData = await getPageText(i);
                    pdfText += pageData.fullText + '\n';
                }

                const systemPrompt = "You are an expert fact-checker for clinical research. Validate if a claim is supported by the provided text. Return a JSON response indicating if the claim is supported, the confidence level, and a direct supporting quote if found.";
                const userPrompt = `Clinical study text:\n${pdfText.substring(0, 50000)}\n\nClaim to validate: "${claim}"\n\nIs this claim supported by the text above? Provide a supporting quote if yes.`;
                
                const validationSchema = {
                    type: "OBJECT",
                    properties: {
                        "is_supported": { "type": "BOOLEAN", "description": "Whether the claim is supported by the text" },
                        "confidence_score": { "type": "NUMBER", "description": "Confidence level from 0.0 to 1.0" },
                        "supporting_quote": { "type": "STRING", "description": "Direct quote from text that supports the claim, or empty string if not supported" },
                        "explanation": { "type": "STRING", "description": "Brief explanation of the validation result" }
                    }
                };

                // Use multi-provider AI call
                const responseText = await AIProviders.callAI(systemPrompt, userPrompt, validationSchema);
                const validation = JSON.parse(responseText);

                if (validation.is_supported) {
                    const quote = validation.supporting_quote.substring(0, 100);
                    StatusManager.show(`‚úì VALIDATED by ${AIProviders[provider].name} (${Math.round(validation.confidence_score * 100)}%): "${quote}..."`, 'success', 10000);
                    field.style.borderColor = 'var(--success-green)';
                } else {
                    StatusManager.show(`‚úó NOT SUPPORTED (${Math.round(validation.confidence_score * 100)}%): ${validation.explanation}`, 'warning', 10000);
                    field.style.borderColor = 'var(--warning-orange)';
                }

            } catch (error) {
                console.error("AI Validation Error:", error);
                StatusManager.show(`AI validation failed: ${error.message}`, 'error');
            } finally {
                AppStateManager.setState({ isProcessing: false });
                StatusManager.showLoading(false);
            }
        }
         
        /**
         * ‚ú® Finds study metadata using Gemini with Google Search.
         */
        async function findMetadata() {
            const state = AppStateManager.getState();
            if (state.isProcessing) {
                StatusManager.show('Please wait for the current operation to finish.', 'warning');
                return;
            }
            const citationText = document.getElementById('citation').value;
            if (!citationText) {
                StatusManager.show('Please enter a citation or title first.', 'warning');
                return;
            }
             
            AppStateManager.setState({ isProcessing: true });
            document.getElementById('metadata-loading').style.display = 'block';
            StatusManager.show('‚ú® Searching Google for metadata...', 'info');

            try {
                const systemPrompt = "You are a research assistant. Find the metadata for the given study. Use Google Search to find the information. If a value isn't found, return an empty string for it. Provide only the JSON response.";
                const userPrompt = `Find the DOI, PMID, journal name, and publication year for the following study: "${citationText}"`;
                 
                const metadataSchema = {
                    type: "OBJECT",
                    properties: {
                        "doi": { "type": "STRING", "description": "The DOI of the paper" },
                        "pmid": { "type": "STRING", "description": "The PubMed ID (PMID) of the paper" },
                        "journal": { "type": "STRING", "description": "The name of the journal" },
                        "year": { "type": "STRING", "description": "The 4-digit publication year" }
                    }
                };

                const responseJson = await callGeminiWithSearch(systemPrompt, userPrompt, metadataSchema);
                const data = JSON.parse(responseJson);
                 
                if (data.doi) document.getElementById('doi').value = data.doi;
                if (data.pmid) document.getElementById('pmid').value = data.pmid;
                if (data.journal) document.getElementById('journal').value = data.journal;
                if (data.year) document.getElementById('year').value = data.year;

                StatusManager.show('‚ú® Metadata auto-populated!', 'success');

            } catch (error) {
                console.error("Gemini Metadata Error:", error);
                StatusManager.show(`AI metadata search failed: ${error.message}`, 'error');
            } finally {
                AppStateManager.setState({ isProcessing: false });
                document.getElementById('metadata-loading').style.display = 'none';
            }
        }


        // --- Helper Functions (made global for HTML access) ---
        window.calculateBoundingBox = (items) => {
             let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
             items.forEach(item => {
                if (!item) return; // Skip if item is null/undefined
                const x = item.x ?? parseFloat(item.element?.dataset.x || '0');
                const y = item.y ?? parseFloat(item.element?.dataset.y || '0');
                const width = item.width ?? parseFloat(item.element?.dataset.width || '0');
                const height = item.height ?? parseFloat(item.element?.dataset.height || '0');
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + width);
                maxY = Math.max(maxY, y + height);
            });
            if (!isFinite(minX)) return { x: 0, y: 0, width: 0, height: 0 }; // Handle case with no valid items
            return { x: Math.round(minX), y: Math.round(minY), width: Math.round(maxX - minX), height: Math.round(maxY - minY) };
        };

        window.addExtractionMarker = (extraction) => {
             const pageDiv = document.querySelector('.pdf-page');
            if (!pageDiv || !extraction || !extraction.coordinates) return;
            const marker = document.createElement('div');
            marker.className = 'extraction-marker';
            marker.dataset.extractionId = extraction.id;
            marker.dataset.field = extraction.fieldName;
            marker.dataset.method = extraction.method; // For styling
            marker.style.left = extraction.coordinates.x + 'px';
            marker.style.top = extraction.coordinates.y + 'px';
            marker.style.width = extraction.coordinates.width + 'px';
            marker.style.height = extraction.coordinates.height + 'px';
            pageDiv.appendChild(marker);
        };

        window.addExtractionMarkersForPage = (pageNum) => {
            const pageDiv = document.querySelector('.pdf-page');
            if (!pageDiv) return;
             // Clear existing markers for the page first
             pageDiv.querySelectorAll('.extraction-marker').forEach(m => m.remove());
            // Add markers
            ExtractionTracker.getExtractions()
                .filter(ext => ext.page === pageNum)
                .forEach(ext => addExtractionMarker(ext));
        };

        window.autoAdvanceField = () => {
             const state = AppStateManager.getState();
             const currentStepElement = document.getElementById(`step-${state.currentStep + 1}`);
             if (!currentStepElement || !state.activeFieldElement) return;
             const inputs = Array.from(currentStepElement.querySelectorAll('.linked-input:not([disabled])'));
             const currentIndex = inputs.indexOf(state.activeFieldElement);
             if (currentIndex >= 0 && currentIndex < inputs.length - 1) {
                inputs[currentIndex + 1].focus();
             }
        };

        window.clearSearchMarkers = () => {
            AppState.searchMarkers.forEach(marker => marker.remove());
            AppState.searchMarkers = [];
            document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight'));
        };


        // --- Initialization ---
        FormManager.initialize();

        // Setup PDF Controls
        document.getElementById('pdf-upload-btn').onclick = () => document.getElementById('pdf-file').click();
        document.getElementById('pdf-file').onchange = (e) => PDFLoader.loadPDF(e.target.files[0]);
        document.getElementById('pdf-file-2').onchange = (e) => PDFLoader.loadPDF(e.target.files[0]); // For label click
        document.getElementById('pdf-prev-page').onclick = () => {
            const state = AppStateManager.getState();
            if (state.currentPage > 1) PDFRenderer.renderPage(state.currentPage - 1);
        };
        document.getElementById('pdf-next-page').onclick = () => {
            const state = AppStateManager.getState();
            if (state.currentPage < state.totalPages) PDFRenderer.renderPage(state.currentPage + 1);
        };
         document.getElementById('page-num').onchange = (e) => {
            const pageNum = parseInt(e.target.value);
            const state = AppStateManager.getState();
            if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= state.totalPages) {
                PDFRenderer.renderPage(pageNum);
            } else {
                // Reset input to current page if invalid
                e.target.value = state.currentPage.toString();
            }
        };
        document.getElementById('zoom-level').onchange = (e) => {
            const scale = parseFloat(e.target.value);
            AppStateManager.setState({ scale });
            PDFRenderer.renderPage(AppStateManager.getState().currentPage);
        };
        document.getElementById('fit-width').onclick = async () => {
            const state = AppStateManager.getState();
            if (!state.pdfDoc) return;
            const container = document.getElementById('pdf-container');
            if (!container) return;
            const containerWidth = container.clientWidth - 40; // Account for padding
            try {
                const page = await state.pdfDoc.getPage(state.currentPage);
                const viewport = page.getViewport({ scale: 1.0 });
                const newScale = containerWidth / viewport.width;
                AppStateManager.setState({ scale: newScale });
                document.getElementById('zoom-level').value = newScale.toFixed(2); // Update dropdown
                await PDFRenderer.renderPage(state.currentPage);
            } catch (error) {
                console.error("Fit Width Error:", error);
                StatusManager.show("Could not fit PDF to width.", "error");
            }
        };
         // Drag and Drop for Upload Area
         const uploadArea = document.getElementById('upload-area');
         if (uploadArea) {
            uploadArea.onclick = () => document.getElementById('pdf-file-2').click(); // Make area clickable
            uploadArea.ondragover = (e) => { e.preventDefault(); uploadArea.style.background = '#e3f2fd'; };
            uploadArea.ondragleave = () => { uploadArea.style.background = ''; };
            uploadArea.ondrop = (e) => {
                e.preventDefault();
                uploadArea.style.background = '';
                const file = e.dataTransfer?.files[0];
                if (file && file.type === 'application/pdf') {
                    PDFLoader.loadPDF(file);
                } else {
                    StatusManager.show('Please drop a valid PDF file.', 'warning');
                }
            };
        }


         // Expose simplified ExportManager functions globally
         window.exportJSON = () => ExportManager.exportJSON();
         window.exportCSV = () => ExportManager.exportCSV();
         window.exportAudit = () => ExportManager.exportAudit();
         window.exportAnnotatedPDF = () => PDFAnnotationManager.exportAnnotatedPDF();

         // Expose Search Interface functions globally
         window.toggleSearchInterface = () => {
            document.getElementById('search-interface')?.classList.toggle('active');
        };
         
         /**
          * Full PDF text search with highlighting and navigation
          */
         window.searchInPDF = async () => {
            const query = document.getElementById('search-query').value.trim();
            if (!query) {
                StatusManager.show('Please enter text to search', 'warning');
                return;
            }
            const state = AppStateManager.getState();
            if (!state.pdfDoc) {
                StatusManager.show('Please load a PDF first', 'warning');
                return;
            }
            
            StatusManager.showLoading(true);
            StatusManager.show('Searching across all pages...', 'info');
            clearSearchMarkers();

            try {
                const searchResults = [];
                const normalizedQuery = normalizeText(query);
                
                // Search across all pages and get text coordinates
                for (let pageNum = 1; pageNum <= state.totalPages; pageNum++) {
                    const page = await state.pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const viewport = page.getViewport({ scale: state.scale });
                    
                    let fullText = '';
                    const itemsWithCoords = [];
                    
                    textContent.items.forEach(item => {
                        if (item.str) {
                            const startPos = fullText.length;
                            fullText += item.str + ' ';
                            
                            // Calculate item coordinates
                            const tx = window.pdfjsLib.Util.transform(viewport.transform, item.transform);
                            itemsWithCoords.push({
                                text: item.str,
                                startPos: startPos,
                                endPos: startPos + item.str.length,
                                x: tx[4],
                                y: tx[5],
                                width: item.width * tx[0],
                                height: Math.sqrt((tx[0] * tx[0]) + (tx[1] * tx[1]))
                            });
                        }
                    });
                    
                    const normalizedText = normalizeText(fullText);
                    
                    // Find all occurrences in this page
                    let startIndex = 0;
                    while ((startIndex = normalizedText.indexOf(normalizedQuery, startIndex)) !== -1) {
                        const endIndex = startIndex + normalizedQuery.length;
                        
                        // Get context (50 chars before and after)
                        const contextStart = Math.max(0, startIndex - 50);
                        const contextEnd = Math.min(normalizedText.length, endIndex + 50);
                        const context = fullText.substring(contextStart, contextEnd);
                        
                        // Find text items that overlap with this match
                        const matchingItems = itemsWithCoords.filter(item => {
                            return item.startPos < endIndex && item.endPos > startIndex;
                        });
                        
                        // Calculate bounding box for the match
                        let boundingBox = null;
                        if (matchingItems.length > 0) {
                            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                            matchingItems.forEach(item => {
                                minX = Math.min(minX, item.x);
                                minY = Math.min(minY, item.y);
                                maxX = Math.max(maxX, item.x + item.width);
                                maxY = Math.max(maxY, item.y + item.height);
                            });
                            boundingBox = {
                                x: Math.round(minX),
                                y: Math.round(minY),
                                width: Math.round(maxX - minX),
                                height: Math.round(maxY - minY)
                            };
                        }
                        
                        searchResults.push({
                            page: pageNum,
                            context: context,
                            position: startIndex,
                            boundingBox: boundingBox,
                            matchedText: fullText.substring(startIndex, endIndex)
                        });
                        
                        startIndex += normalizedQuery.length;
                    }
                }
                
                // Store search results globally for highlighting
                AppState.currentSearchResults = searchResults;
                
                // Display results
                const resultsContainer = document.getElementById('search-results');
                if (searchResults.length === 0) {
                    resultsContainer.innerHTML = '<div class="search-result-item">No matches found</div>';
                    StatusManager.show('No matches found', 'info');
                } else {
                    resultsContainer.innerHTML = '';
                    searchResults.forEach((result, index) => {
                        const resultDiv = document.createElement('div');
                        resultDiv.className = 'search-result-item';
                        resultDiv.innerHTML = `
                            <strong>Page ${result.page} - Match ${index + 1}</strong><br>
                            <span style="font-size: 10px;">...${SecurityUtils.escapeHtml(result.context)}...</span>
                        `;
                        resultDiv.onclick = async () => {
                            // Navigate to page if needed
                            if (state.currentPage !== result.page) {
                                await PDFRenderer.renderPage(result.page);
                            }
                            
                            // Wait for page to render
                            setTimeout(() => {
                                highlightSearchMatch(result);
                                StatusManager.show(`üìç Showing match ${index + 1} on page ${result.page}`, 'success', 3000);
                            }, state.currentPage !== result.page ? 500 : 100);
                        };
                        resultsContainer.appendChild(resultDiv);
                    });
                    StatusManager.show(`Found ${searchResults.length} match(es) in ${new Set(searchResults.map(r => r.page)).size} page(s)`, 'success');
                }
            } catch (error) {
                console.error("Search Error:", error);
                StatusManager.show(`Search failed: ${error.message}`, 'error');
            } finally {
                StatusManager.showLoading(false);
            }
        };
         
        /**
         * Highlight a specific search match on the PDF
         */
        window.highlightSearchMatch = function(searchResult) {
            const pageDiv = document.querySelector('.pdf-page');
            if (!pageDiv) return;
            
            // Clear existing search highlights
            document.querySelectorAll('.search-highlight-marker').forEach(el => el.remove());
            document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight'));
            
            if (!searchResult.boundingBox) {
                StatusManager.show('No coordinates available for this match', 'warning');
                return;
            }
            
            const bbox = searchResult.boundingBox;
            
            // Create highlight marker
            const marker = document.createElement('div');
            marker.className = 'search-marker search-highlight-marker';
            marker.style.left = bbox.x + 'px';
            marker.style.top = bbox.y + 'px';
            marker.style.width = bbox.width + 'px';
            marker.style.height = bbox.height + 'px';
            marker.style.animation = 'pulse 1.5s ease-in-out 3'; // Pulse 3 times
            
            pageDiv.appendChild(marker);
            AppState.searchMarkers.push(marker);
            
            // Scroll to the marker
            marker.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // PRECISE COORDINATE-BASED TEXT LAYER HIGHLIGHTING
            const textLayer = pageDiv.querySelector('.textLayer');
            if (textLayer) {
                const textLayerRect = textLayer.getBoundingClientRect();
                const spans = textLayer.querySelectorAll('span');
                
                spans.forEach(span => {
                    const spanRect = span.getBoundingClientRect();
                    
                    // Calculate span position relative to text layer
                    const spanX = spanRect.left - textLayerRect.left;
                    const spanY = spanRect.top - textLayerRect.top;
                    const spanRight = spanX + spanRect.width;
                    const spanBottom = spanY + spanRect.height;
                    
                    // Check if span overlaps with the match's bounding box
                    const overlapsX = spanX < bbox.x + bbox.width && spanRight > bbox.x;
                    const overlapsY = spanY < bbox.y + bbox.height && spanBottom > bbox.y;
                    
                    // Only highlight if span is within the match bounding box
                    if (overlapsX && overlapsY) {
                        span.classList.add('search-highlight');
                        // Remove highlight after 5 seconds
                        setTimeout(() => span.classList.remove('search-highlight'), 5000);
                    }
                });
            }
        };
         
         /**
          * Load and parse markdown file
          */
         document.getElementById('markdown-file').onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                AppStateManager.setState({ 
                    markdownContent: text, 
                    markdownLoaded: true 
                });
                document.getElementById('markdown-status').textContent = `‚úì Loaded: ${file.name} (${text.length} chars)`;
                StatusManager.show('Markdown file loaded. Use Search Text to find quotes in PDF.', 'success');
            } catch (error) {
                console.error("Markdown Load Error:", error);
                StatusManager.show(`Failed to load markdown: ${error.message}`, 'error');
            }
        };

        // ============================================================================
        // AI PROVIDER ABSTRACTION LAYER - Multi-provider support
        // ============================================================================
        
        const AIProviders = {
            /**
             * Gemini Provider (Google)
             */
            gemini: {
                name: 'Google Gemini',
                endpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent',
                
                formatRequest: function(systemPrompt, userPrompt, schema = null) {
                    const payload = {
                        contents: [{ parts: [{ text: userPrompt }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    };
                    
                    if (schema) {
                        payload.generationConfig = {
                            responseMimeType: "application/json",
                            responseSchema: schema
                        };
                    }
                    
                    return payload;
                },
                
                parseResponse: function(result) {
                    return result.candidates?.[0]?.content?.parts?.[0]?.text;
                }
            },
            
            /**
             * Anthropic Claude Provider
             */
            anthropic: {
                name: 'Anthropic Claude',
                endpoint: 'https://api.anthropic.com/v1/messages',
                
                formatRequest: function(systemPrompt, userPrompt, schema = null) {
                    const payload = {
                        model: 'claude-3-5-sonnet-20241022',
                        max_tokens: 4096,
                        system: systemPrompt,
                        messages: [
                            { role: 'user', content: userPrompt }
                        ]
                    };
                    
                    return payload;
                },
                
                parseResponse: function(result) {
                    return result.content?.[0]?.text;
                }
            },
            
            /**
             * OpenAI GPT-4 Provider
             */
            openai: {
                name: 'OpenAI GPT-4',
                endpoint: 'https://api.openai.com/v1/chat/completions',
                
                formatRequest: function(systemPrompt, userPrompt, schema = null) {
                    const payload = {
                        model: 'gpt-4-turbo-preview',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userPrompt }
                        ]
                    };
                    
                    if (schema) {
                        payload.response_format = { type: 'json_object' };
                    }
                    
                    return payload;
                },
                
                parseResponse: function(result) {
                    return result.choices?.[0]?.message?.content;
                }
            },
            
            /**
             * Universal AI call function that routes to the correct provider with enhanced error handling
             */
            async callAI(systemPrompt, userPrompt, schema = null) {
                const provider = AppState.aiProvider || 'gemini';
                const apiKey = CONFIG.GEMINI_API_KEY; // Used for all providers
                
                if (!apiKey || apiKey === "PASTE_YOUR_GEMINI_API_KEY_HERE") {
                    throw new Error(`Please configure your ${this[provider].name} API key in Settings`);
                }
                
                const providerConfig = this[provider];
                const endpoint = `${providerConfig.endpoint}${provider === 'gemini' ? '?key=' + apiKey : ''}`;
                const payload = providerConfig.formatRequest(systemPrompt, userPrompt, schema);
                
                // Set headers based on provider
                const headers = { 'Content-Type': 'application/json' };
                if (provider === 'anthropic') {
                    headers['x-api-key'] = apiKey;
                    headers['anthropic-version'] = '2023-06-01';
                } else if (provider === 'openai') {
                    headers['Authorization'] = `Bearer ${apiKey}`;
                }
                
                // Retry logic with exponential backoff
                let attempt = 0;
                const maxAttempts = 3;
                let delay = 1000;
                
                while (attempt < maxAttempts) {
                    try {
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: headers,
                            body: JSON.stringify(payload)
                        });
                        
                        if (!response.ok) {
                            const errorBody = await response.json().catch(() => ({}));
                            
                            // Provider-specific error handling
                            let errorMessage = '';
                            
                            if (provider === 'gemini') {
                                if (response.status === 400) {
                                    errorMessage = 'Invalid request. Check API key or request format.';
                                } else if (response.status === 403) {
                                    errorMessage = 'API key invalid or quota exceeded.';
                                } else if (response.status === 429) {
                                    errorMessage = 'Rate limit exceeded. Please wait and try again.';
                                } else if (response.status === 500) {
                                    errorMessage = 'Gemini server error. Try again later.';
                                } else {
                                    errorMessage = errorBody.error?.message || response.statusText;
                                }
                            } else if (provider === 'anthropic') {
                                if (response.status === 401) {
                                    errorMessage = 'Invalid Anthropic API key.';
                                } else if (response.status === 429) {
                                    errorMessage = 'Rate limit exceeded. Please wait and try again.';
                                } else if (response.status === 529) {
                                    errorMessage = 'Claude is overloaded. Try again in a moment.';
                                } else {
                                    errorMessage = errorBody.error?.message || response.statusText;
                                }
                            } else if (provider === 'openai') {
                                if (response.status === 401) {
                                    errorMessage = 'Invalid OpenAI API key.';
                                } else if (response.status === 429) {
                                    errorMessage = 'Rate limit or quota exceeded.';
                                } else if (response.status === 500) {
                                    errorMessage = 'OpenAI server error. Try again later.';
                                } else {
                                    errorMessage = errorBody.error?.message || response.statusText;
                                }
                            }
                            
                            throw new Error(`${providerConfig.name} Error (${response.status}): ${errorMessage}`);
                        }
                        
                        const result = await response.json();
                        const text = providerConfig.parseResponse(result);
                        
                        if (!text) {
                            throw new Error(`No response text from ${providerConfig.name}. Check console for details.`);
                        }
                        
                        return text;
                        
                    } catch (error) {
                        attempt++;
                        console.error(`${providerConfig.name} API attempt ${attempt}/${maxAttempts} failed:`, error);
                        
                        // Don't retry on authentication errors or bad requests
                        if (error.message.includes('401') || error.message.includes('403') || error.message.includes('400')) {
                            throw error;
                        }
                        
                        // Retry on rate limits and server errors
                        if (attempt < maxAttempts && (error.message.includes('429') || error.message.includes('500') || error.message.includes('529'))) {
                            console.log(`Retrying in ${delay}ms...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2; // Exponential backoff
                            continue;
                        }
                        
                        // Max attempts reached or non-retryable error
                        throw error;
                    }
                }
                
                throw new Error(`${providerConfig.name} failed after ${maxAttempts} attempts.`);
            }
        };

        // ============================================================================
        // SESSION MANAGER - Auto-save and restore user progress
        // ============================================================================

        const SessionManager = {
            STORAGE_KEY: 'clinical_extraction_session',
            saveTimeout: null,

            /**
             * Collect all form data from all 8 steps
             */
            collectFormData: function() {
                const formData = {};
                const form = document.getElementById('extraction-form');
                if (!form) return formData;

                // Get all inputs, textareas, and selects
                const fields = form.querySelectorAll('input, textarea, select');
                fields.forEach(field => {
                    if (field.id || field.name) {
                        const key = field.id || field.name;
                        if (field.type === 'checkbox') {
                            formData[key] = field.checked;
                        } else if (field.type === 'radio') {
                            if (field.checked) formData[key] = field.value;
                        } else {
                            formData[key] = field.value;
                        }
                    }
                });

                return formData;
            },

            /**
             * Save current session to localStorage
             */
            saveSession: function() {
                try {
                    const state = AppStateManager.getState();

                    const session = {
                        version: "1.0",
                        savedAt: new Date().toISOString(),
                        formData: this.collectFormData(),
                        appState: {
                            currentStep: state.currentStep,
                            currentPage: state.currentPage,
                            scale: state.scale,
                            documentName: state.documentName,
                            activeField: state.activeField
                        }
                    };

                    // Store in localStorage
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(session));

                    // Optional: Show subtle indicator
                    console.log('Session saved:', new Date().toISOString());

                } catch (error) {
                    console.error('Failed to save session:', error);
                    // Handle quota exceeded error
                    if (error.name === 'QuotaExceededError') {
                        StatusManager.show('‚ö†Ô∏è Storage full. Export data and clear old sessions.', 'warning', 5000);
                    }
                }
            },

            /**
             * Save session with debouncing to avoid excessive writes
             */
            debouncedSave: function() {
                clearTimeout(this.saveTimeout);
                this.saveTimeout = setTimeout(() => {
                    this.saveSession();
                }, 500); // Wait 500ms after last change
            },

            /**
             * Load and restore session from localStorage
             */
            loadSession: function() {
                try {
                    const saved = localStorage.getItem(this.STORAGE_KEY);
                    if (!saved) return null;

                    const session = JSON.parse(saved);

                    // Restore form data
                    if (session.formData) {
                        Object.keys(session.formData).forEach(key => {
                            const field = document.getElementById(key) || document.querySelector(`[name="${key}"]`);
                            if (field) {
                                if (field.type === 'checkbox') {
                                    field.checked = session.formData[key];
                                } else if (field.type === 'radio') {
                                    if (field.value === session.formData[key]) {
                                        field.checked = true;
                                    }
                                } else {
                                    field.value = session.formData[key];
                                }
                            }
                        });
                    }

                    // Restore app state
                    if (session.appState) {
                        if (session.appState.currentStep !== undefined) {
                            AppStateManager.setState({ currentStep: session.appState.currentStep });
                            if (FormManager && FormManager.showStep) {
                                FormManager.showStep(session.appState.currentStep);
                            }
                        }
                        if (session.appState.currentPage) {
                            AppStateManager.setState({ currentPage: session.appState.currentPage });
                        }
                        if (session.appState.scale) {
                            AppStateManager.setState({ scale: session.appState.scale });
                        }
                        if (session.appState.documentName) {
                            AppStateManager.setState({ documentName: session.appState.documentName });
                        }
                    }

                    // Show notification
                    const savedDate = new Date(session.savedAt);
                    const timeAgo = this.getTimeAgo(savedDate);
                    StatusManager.show(`‚úì Session restored (saved ${timeAgo})`, 'success', 4000);

                    console.log('Session restored from:', session.savedAt);
                    return session;

                } catch (error) {
                    console.error('Failed to load session:', error);
                    return null;
                }
            },

            /**
             * Clear session from localStorage
             */
            clearSession: function() {
                try {
                    localStorage.removeItem(this.STORAGE_KEY);
                    StatusManager.show('‚úì Session cleared', 'success');
                    console.log('Session cleared');
                } catch (error) {
                    console.error('Failed to clear session:', error);
                }
            },

            /**
             * Get session info for display
             */
            getSessionInfo: function() {
                try {
                    const saved = localStorage.getItem(this.STORAGE_KEY);
                    if (!saved) return null;

                    const session = JSON.parse(saved);
                    return {
                        savedAt: session.savedAt,
                        timeAgo: this.getTimeAgo(new Date(session.savedAt)),
                        hasData: Object.keys(session.formData || {}).length > 0,
                        currentStep: session.appState?.currentStep
                    };
                } catch (error) {
                    return null;
                }
            },

            /**
             * Helper to get human-readable time ago
             */
            getTimeAgo: function(date) {
                const seconds = Math.floor((new Date() - date) / 1000);

                if (seconds < 60) return 'just now';
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
                const hours = Math.floor(minutes / 60);
                if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
                const days = Math.floor(hours / 24);
                return `${days} day${days > 1 ? 's' : ''} ago`;
            },

            /**
             * Setup auto-save listeners
             */
            initializeAutoSave: function() {
                const form = document.getElementById('extraction-form');
                if (!form) return;

                // Save on input/change events (debounced)
                form.addEventListener('input', () => this.debouncedSave());
                form.addEventListener('change', () => this.debouncedSave());

                // Save on step navigation
                const nextBtn = document.getElementById('next-btn');
                const prevBtn = document.getElementById('prev-btn');
                if (nextBtn) nextBtn.addEventListener('click', () => this.saveSession());
                if (prevBtn) prevBtn.addEventListener('click', () => this.saveSession());

                // Save before page unload
                window.addEventListener('beforeunload', () => this.saveSession());

                console.log('Auto-save initialized');
            }
        };

        // ============================================================================
        // SETTINGS MANAGER - Frontend configuration without code editing
        // ============================================================================

        const SettingsManager = {
            STORAGE_KEY: 'clinical_extraction_settings',
            
            /**
             * Load settings from localStorage on startup
             */
            loadSettings: function() {
                try {
                    const encrypted = localStorage.getItem(this.STORAGE_KEY);
                    if (encrypted) {
                        const settings = JSON.parse(atob(encrypted));
                        
                        // Update CONFIG object
                        if (settings.aiProvider) AppState.aiProvider = settings.aiProvider;
                        if (settings.aiApiKey) CONFIG.GEMINI_API_KEY = settings.aiApiKey;
                        if (settings.googleClientId) CONFIG.GOOGLE_CLIENT_ID = settings.googleClientId;
                        if (settings.googleSheetId) CONFIG.GOOGLE_SHEET_ID = settings.googleSheetId;
                        
                        this.updateStatusIndicators();
                        console.log('Settings loaded from localStorage');
                        return settings;
                    }
                } catch (error) {
                    console.error('Failed to load settings:', error);
                }
                return null;
            },
            
            /**
             * Update status badge indicators
             */
            updateStatusIndicators: function() {
                const aiConfigured = CONFIG.GEMINI_API_KEY && CONFIG.GEMINI_API_KEY !== "PASTE_YOUR_GEMINI_API_KEY_HERE";
                const sheetsConfigured = CONFIG.GOOGLE_CLIENT_ID && CONFIG.GOOGLE_CLIENT_ID !== "PASTE_YOUR_CLIENT_ID_HERE.apps.googleusercontent.com" &&
                                        CONFIG.GOOGLE_SHEET_ID && CONFIG.GOOGLE_SHEET_ID !== "PASTE_YOUR_SHEET_ID_HERE";
                
                const aiStatus = document.getElementById('ai-status');
                const sheetsStatus = document.getElementById('sheets-status');
                
                if (aiStatus) {
                    aiStatus.textContent = aiConfigured ? '‚úì Configured' : 'Not Configured';
                    aiStatus.className = aiConfigured ? 'key-status configured' : 'key-status missing';
                }
                
                if (sheetsStatus) {
                    sheetsStatus.textContent = sheetsConfigured ? '‚úì Configured' : 'Not Configured';
                    sheetsStatus.className = sheetsConfigured ? 'key-status configured' : 'key-status missing';
                }
            }
        };
        
        /**
         * Open settings modal and load current values
         */
        window.openSettings = function() {
            const modal = document.getElementById('settings-modal');
            if (!modal) return;
            
            // Load current values (show masked if exists)
            const aiProvider = AppState.aiProvider || 'gemini';
            const aiKey = CONFIG.GEMINI_API_KEY;
            const clientId = CONFIG.GOOGLE_CLIENT_ID;
            const sheetId = CONFIG.GOOGLE_SHEET_ID;
            
            document.getElementById('ai-provider').value = aiProvider;
            
            // Show masked values for security
            if (aiKey && aiKey !== "PASTE_YOUR_GEMINI_API_KEY_HERE") {
                document.getElementById('ai-api-key').value = aiKey.substring(0, 8) + '...' + aiKey.slice(-4);
                document.getElementById('ai-api-key').dataset.fullKey = aiKey;
            }
            
            if (clientId && clientId !== "PASTE_YOUR_CLIENT_ID_HERE.apps.googleusercontent.com") {
                document.getElementById('google-client-id').value = clientId;
            }
            
            if (sheetId && sheetId !== "PASTE_YOUR_SHEET_ID_HERE") {
                document.getElementById('google-sheet-id').value = sheetId;
            }
            
            updateProviderFields();
            updateSessionInfo(); // Update session info display
            modal.classList.add('active');
        };

        /**
         * Update session info in settings modal
         */
        window.updateSessionInfo = function() {
            const sessionInfo = SessionManager.getSessionInfo();
            const statusBadge = document.getElementById('session-status');
            const timestampSpan = document.getElementById('session-timestamp');
            const stepSpan = document.getElementById('session-step');

            if (sessionInfo && sessionInfo.hasData) {
                statusBadge.textContent = 'Active';
                statusBadge.className = 'key-status configured';
                timestampSpan.textContent = sessionInfo.timeAgo;
                stepSpan.textContent = `Step ${(sessionInfo.currentStep || 0) + 1} of 8`;
            } else {
                statusBadge.textContent = 'No Session';
                statusBadge.className = 'key-status missing';
                timestampSpan.textContent = 'Never';
                stepSpan.textContent = 'N/A';
            }
        };

        /**
         * Clear session data
         */
        window.clearSessionData = function() {
            if (confirm('Are you sure you want to clear your saved session? This will erase all form data and progress.')) {
                SessionManager.clearSession();
                updateSessionInfo();

                // Optionally reload page to show cleared state
                if (confirm('Session cleared. Reload page to see changes?')) {
                    location.reload();
                }
            }
        };

        /**
         * Close settings modal without saving
         */
        window.closeSettings = function() {
            const modal = document.getElementById('settings-modal');
            if (modal) modal.classList.remove('active');
        };
        
        /**
         * Update help text based on selected provider
         */
        window.updateProviderFields = function() {
            const provider = document.getElementById('ai-provider').value;
            const helpText = document.getElementById('ai-help-text');
            
            const providerInfo = {
                gemini: 'Get Gemini key from: <a href="https://makersuite.google.com/app/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio</a>',
                anthropic: 'Get Claude key from: <a href="https://console.anthropic.com/settings/keys" target="_blank" rel="noopener noreferrer">Anthropic Console</a>',
                openai: 'Get OpenAI key from: <a href="https://platform.openai.com/api-keys" target="_blank" rel="noopener noreferrer">OpenAI Platform</a>'
            };
            
            helpText.innerHTML = providerInfo[provider] || providerInfo.gemini;
        };
        
        /**
         * Save settings to localStorage
         */
        window.saveSettings = function() {
            const provider = document.getElementById('ai-provider').value;
            let apiKey = document.getElementById('ai-api-key').value;
            const clientId = document.getElementById('google-client-id').value;
            const sheetId = document.getElementById('google-sheet-id').value;
            
            // If key was masked, use the full key from dataset
            if (apiKey.includes('...') && document.getElementById('ai-api-key').dataset.fullKey) {
                apiKey = document.getElementById('ai-api-key').dataset.fullKey;
            }
            
            // Validate inputs
            if (!apiKey || apiKey.length < 10) {
                StatusManager.show('Please enter a valid API key', 'warning');
                return;
            }
            
            // Save to localStorage (encrypted)
            const settings = {
                aiProvider: provider,
                aiApiKey: apiKey,
                googleClientId: clientId,
                googleSheetId: sheetId,
                savedAt: new Date().toISOString()
            };
            
            try {
                const encrypted = btoa(JSON.stringify(settings));
                localStorage.setItem(SettingsManager.STORAGE_KEY, encrypted);
                
                // Update CONFIG
                AppState.aiProvider = provider;
                CONFIG.GEMINI_API_KEY = apiKey; // Used for all providers initially
                CONFIG.GOOGLE_CLIENT_ID = clientId;
                CONFIG.GOOGLE_SHEET_ID = sheetId;
                
                SettingsManager.updateStatusIndicators();
                closeSettings();
                StatusManager.show('‚úì Settings saved successfully!', 'success');
                
                // Reinitialize Google Auth if client ID changed
                if (clientId && window.gisLoaded) {
                    window.gisLoaded();
                }
            } catch (error) {
                console.error('Failed to save settings:', error);
                StatusManager.show('Failed to save settings', 'error');
            }
        };
        
        /**
         * Clear all settings
         */
        window.clearSettings = function() {
            if (!confirm('Clear all API keys and settings? This cannot be undone.')) {
                return;
            }
            
            localStorage.removeItem(SettingsManager.STORAGE_KEY);
            document.getElementById('ai-api-key').value = '';
            document.getElementById('google-client-id').value = '';
            document.getElementById('google-sheet-id').value = '';
            document.getElementById('ai-provider').value = 'gemini';
            
            // Reset CONFIG
            CONFIG.GEMINI_API_KEY = "PASTE_YOUR_GEMINI_API_KEY_HERE";
            CONFIG.GOOGLE_CLIENT_ID = "PASTE_YOUR_CLIENT_ID_HERE.apps.googleusercontent.com";
            CONFIG.GOOGLE_SHEET_ID = "PASTE_YOUR_SHEET_ID_HERE";
            AppState.aiProvider = 'gemini';
            
            SettingsManager.updateStatusIndicators();
            StatusManager.show('All settings cleared', 'info');
        };
        
        // Load settings on startup
        SettingsManager.loadSettings();
        SettingsManager.updateStatusIndicators();

        // Load session and initialize auto-save
        setTimeout(() => {
            SessionManager.loadSession(); // Restore previous session if exists
            SessionManager.initializeAutoSave(); // Setup auto-save listeners
        }, 500); // Delay to ensure FormManager is initialized

        // ============================================================================
        // PDF ANNOTATIONS IMPORTER - Feature 2: Import PDF Annotations
        // ============================================================================
        
        const AnnotationImporter = {
            allAnnotations: [],
            
            async importAnnotations() {
                const state = AppStateManager.getState();
                if (!state.pdfDoc) {
                    StatusManager.show('Please load a PDF first', 'warning');
                    return;
                }
                
                if (state.isProcessing) {
                    StatusManager.show('Please wait for the current operation to finish', 'warning');
                    return;
                }
                
                AppStateManager.setState({ isProcessing: true });
                StatusManager.showLoading(true);
                StatusManager.show('üìù Scanning PDF for annotations...', 'info');
                
                try {
                    this.allAnnotations = [];
                    
                    // Scan all pages for annotations
                    for (let pageNum = 1; pageNum <= state.totalPages; pageNum++) {
                        const page = await state.pdfDoc.getPage(pageNum);
                        const annotations = await page.getAnnotations();
                        
                        annotations.forEach(anno => {
                            // Filter for useful annotation types
                            if (anno.subtype === 'Highlight' || anno.subtype === 'Text' || 
                                anno.subtype === 'FreeText' || anno.subtype === 'Underline') {
                                
                                this.allAnnotations.push({
                                    id: anno.id || `anno_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    page: pageNum,
                                    type: anno.subtype,
                                    content: anno.contents || '',
                                    title: anno.titleObj?.str || anno.title || '',
                                    rect: anno.rect || [0, 0, 0, 0],
                                    color: anno.color || [1, 1, 0],
                                    quadPoints: anno.quadPoints || []
                                });
                            }
                        });
                    }
                    
                    StatusManager.showLoading(false);
                    
                    if (this.allAnnotations.length === 0) {
                        StatusManager.show('No annotations found in this PDF', 'info');
                        AppStateManager.setState({ isProcessing: false });
                        return;
                    }
                    
                    StatusManager.show(`Found ${this.allAnnotations.length} annotation(s)`, 'success');
                    this.showAnnotationsPanel();
                    
                } catch (error) {
                    console.error('Annotation import error:', error);
                    StatusManager.show(`Failed to import annotations: ${error.message}`, 'error');
                } finally {
                    AppStateManager.setState({ isProcessing: false });
                    StatusManager.showLoading(false);
                }
            },
            
            showAnnotationsPanel() {
                // Create modal for annotations
                const existingModal = document.getElementById('annotations-modal');
                if (existingModal) existingModal.remove();
                
                const modal = document.createElement('div');
                modal.id = 'annotations-modal';
                modal.className = 'settings-modal active';
                
                let annotationsHTML = `
                    <div class="settings-content" style="max-width: 700px;">
                        <h2>üìù Import PDF Annotations (${this.allAnnotations.length})</h2>
                        <p class="subtitle" style="margin-bottom: 15px;">
                            Click on an annotation to extract its text, or use "Import All" to batch process.
                        </p>
                        <div style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
                `;
                
                this.allAnnotations.forEach((anno, index) => {
                    const colorRgb = this.colorArrayToRgb(anno.color);
                    annotationsHTML += `
                        <div class="annotation-item" style="
                            background: #f9f9f9;
                            border-left: 4px solid ${colorRgb};
                            padding: 12px;
                            margin-bottom: 10px;
                            border-radius: 4px;
                            cursor: pointer;
                            transition: all 0.2s;
                        " onmouseover="this.style.background='#e3f2fd'" 
                           onmouseout="this.style.background='#f9f9f9'"
                           onclick="importSingleAnnotation(${index})">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <strong style="color: #1976D2;">Page ${anno.page} - ${anno.type}</strong>
                                    ${anno.title ? `<div style="font-size: 12px; color: #666; margin-top: 4px;">üìå ${SecurityUtils.escapeHtml(anno.title)}</div>` : ''}
                                    ${anno.content ? `<div style="font-size: 11px; color: #333; margin-top: 6px; padding: 6px; background: white; border-radius: 3px;">"${SecurityUtils.escapeHtml(anno.content.substring(0, 150))}${anno.content.length > 150 ? '...' : ''}"</div>` : ''}
                                </div>
                                <button onclick="event.stopPropagation(); importSingleAnnotation(${index})" 
                                        style="padding: 6px 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    Import ‚Üí
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                annotationsHTML += `
                        </div>
                        <div class="settings-actions">
                            <button onclick="closeAnnotationsPanel()" style="background: #6c757d;">Close</button>
                            <button onclick="importAllAnnotations()" style="background: #4CAF50;">Import All (${this.allAnnotations.length})</button>
                        </div>
                    </div>
                `;
                
                modal.innerHTML = annotationsHTML;
                document.body.appendChild(modal);
            },
            
            async importSingle(index) {
                const anno = this.allAnnotations[index];
                if (!anno) return;
                
                const state = AppStateManager.getState();
                
                try {
                    // Navigate to annotation page if different
                    if (state.currentPage !== anno.page) {
                        await PDFRenderer.renderPage(anno.page);
                    }
                    
                    // Extract text from annotation area
                    const region = this.rectToRegion(anno.rect);
                    let extractedText = anno.content || anno.title || '';
                    
                    // If no content in annotation metadata, try extracting from coordinates
                    if (!extractedText && region.width > 0 && region.height > 0) {
                        extractedText = await RegionSelectionManager.extractTextFromRegion(region, anno.page);
                    }
                    
                    if (!extractedText) {
                        StatusManager.show('No text found in annotation', 'warning');
                        return;
                    }
                    
                    // Auto-suggest field mapping
                    const suggestedField = this.suggestFieldMapping(extractedText);
                    
                    if (suggestedField && state.activeField !== suggestedField) {
                        const fieldElement = document.getElementById(suggestedField) || 
                                           document.querySelector(`[name="${suggestedField}"]`);
                        if (fieldElement) {
                            fieldElement.focus(); // This will trigger field activation
                            StatusManager.show(`üí° Suggested field: ${suggestedField}`, 'info', 2000);
                            // Wait a bit for field to activate
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    }
                    
                    const currentState = AppStateManager.getState();
                    if (!currentState.activeField) {
                        StatusManager.show('Please select a field to import into', 'warning');
                        return;
                    }
                    
                    // Create extraction record
                    const sanitizedText = SecurityUtils.sanitizeText(extractedText);
                    const extraction = ExtractionTracker.addExtraction({
                        fieldName: currentState.activeField,
                        text: sanitizedText,
                        page: anno.page,
                        coordinates: region,
                        method: 'annotation',
                        documentName: currentState.documentName
                    });
                    
                    if (extraction && currentState.activeFieldElement) {
                        currentState.activeFieldElement.value = sanitizedText;
                        currentState.activeFieldElement.classList.add('has-extraction');
                    }
                    
                    if (extraction) {
                        addExtractionMarker(extraction);
                        StatusManager.show(`‚úì Imported annotation from page ${anno.page}`, 'success');
                        autoAdvanceField();
                    }
                    
                } catch (error) {
                    console.error('Single annotation import error:', error);
                    StatusManager.show(`Import failed: ${error.message}`, 'error');
                }
            },
            
            async importAll() {
                if (!confirm(`Import all ${this.allAnnotations.length} annotations? This will populate available fields.`)) {
                    return;
                }
                
                StatusManager.showLoading(true);
                let successCount = 0;
                
                for (let i = 0; i < this.allAnnotations.length; i++) {
                    try {
                        await this.importSingle(i);
                        successCount++;
                        // Small delay to prevent overwhelming the UI
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (error) {
                        console.error(`Failed to import annotation ${i}:`, error);
                    }
                }
                
                StatusManager.showLoading(false);
                StatusManager.show(`‚úì Imported ${successCount}/${this.allAnnotations.length} annotations`, 'success');
                this.closePanel();
            },
            
            suggestFieldMapping(text) {
                const lowerText = text.toLowerCase();
                
                // Keyword-based field mapping
                const mappings = [
                    { keywords: ['doi', '10.'], field: 'doi' },
                    { keywords: ['pmid', 'pubmed'], field: 'pmid' },
                    { keywords: ['population', 'patients', 'participants'], field: 'eligibility-population' },
                    { keywords: ['intervention', 'surgery', 'treatment'], field: 'eligibility-intervention' },
                    { keywords: ['control', 'comparator', 'comparison'], field: 'eligibility-comparator' },
                    { keywords: ['outcome', 'result', 'endpoint'], field: 'eligibility-outcomes' },
                    { keywords: ['funding', 'grant', 'supported by'], field: 'funding' },
                    { keywords: ['conflict', 'disclosure'], field: 'conflicts' },
                    { keywords: ['registration', 'nct', 'trial id'], field: 'registration' }
                ];
                
                for (const mapping of mappings) {
                    if (mapping.keywords.some(keyword => lowerText.includes(keyword))) {
                        return mapping.field;
                    }
                }
                
                return null; // No suggestion
            },
            
            rectToRegion(rect) {
                // PDF rect format: [x1, y1, x2, y2]
                const x = Math.min(rect[0], rect[2]);
                const y = Math.min(rect[1], rect[3]);
                const width = Math.abs(rect[2] - rect[0]);
                const height = Math.abs(rect[3] - rect[1]);
                
                return { x, y, width, height };
            },
            
            colorArrayToRgb(colorArray) {
                if (!colorArray || colorArray.length < 3) return '#FFFF00';
                const r = Math.round(colorArray[0] * 255);
                const g = Math.round(colorArray[1] * 255);
                const b = Math.round(colorArray[2] * 255);
                return `rgb(${r}, ${g}, ${b})`;
            },
            
            closePanel() {
                const modal = document.getElementById('annotations-modal');
                if (modal) modal.remove();
            }
        };
        
        /**
         * Import PDF annotations
         */
        window.importPDFAnnotations = function() {
            AnnotationImporter.importAnnotations();
        };
        
        /**
         * Import single annotation (called from panel)
         */
        window.importSingleAnnotation = function(index) {
            AnnotationImporter.importSingle(index);
        };
        
        /**
         * Import all annotations (called from panel)
         */
        window.importAllAnnotations = function() {
            AnnotationImporter.importAll();
        };
        
        /**
         * Close annotations panel
         */
        window.closeAnnotationsPanel = function() {
            AnnotationImporter.closePanel();
        };

        // Expose Gemini functions globally
        window.generatePICO = generatePICO;
        window.generateSummary = generateSummary;
        window.validateFieldWithAI = validateFieldWithAI;
        window.findMetadata = findMetadata; // <-- Expose the new function
         
        // Expose Save functions globally
        window.handleSubmitToGoogleSheets = async (e) => {
            e.preventDefault();
            if (!CONFIG.GOOGLE_API_KEY || !CONFIG.GOOGLE_CLIENT_ID || !CONFIG.GOOGLE_SHEET_ID) {
                StatusManager.show('Google Sheets config is missing.', 'error');
                return;
            }
            if (!gapiLoaded || !gapiTokenClient) {
                 StatusManager.show('Google API client is not loaded yet. Please wait.', 'warning');
                 return;
            }
             
            // --- VALIDATION LOGIC REMOVED ---
            /*
            if (!FormManager.validateAllSteps()) {
                 StatusManager.show('Please correct validation errors on all steps before saving.', 'error');
                 return;
            }
            */

            StatusManager.showLoading(true);
            StatusManager.show('Authenticating with Google...', 'info');
             
            try {
                // Get auth token
                gapiTokenClient.callback = async (tokenResponse) => {
                    if (tokenResponse.error) {
                         throw new Error(`Google Auth Error: ${tokenResponse.error}`);
                    }
                    await gapi.client.load('sheets', 'v4');
                    StatusManager.show('Saving to Google Sheets...', 'info');
                     
                    const state = AppStateManager.getState();
                    const formData = FormManager.collectFormData();
                    const extractions = ExtractionTracker.getExtractions();
                    const submissionId = `sub_${Date.now()}`;
                    const timestamp = new Date().toISOString();

                    // --- Define Sheet Headers (Must match your sheet) ---
                    // Example:
                    const submissionHeaders = ["Submission ID", "Timestamp", "Document", "Citation", "DOI", "PMID", "Total N"];
                    const extractionHeaders = ["Submission ID", "Field Name", "Text", "Page", "Method", "X", "Y", "Width", "Height"];

                    // 1. Prepare Submission Row
                    // This is an example. You MUST adjust this to match your 'Submissions' sheet columns exactly.
                    const submissionRow = [
                        submissionId,
                        timestamp,
                        state.documentName,
                        formData.citation || '',
                        formData.doi || '',
                        formData.pmid || '',
                        formData.totalN || ''
                    ];

                    // 2. Prepare Extraction Rows
                    const extractionRows = extractions.map(ext => [
                        submissionId,
                        ext.fieldName,
                        ext.text,
                        ext.page,
                        ext.method,
                        ext.coordinates.x,
                        ext.coordinates.y,
                        ext.coordinates.width,
                        ext.coordinates.height
                    ]);

                    // 3. Append to 'Submissions' Sheet
                    await gapi.client.sheets.spreadsheets.values.append({
                        spreadsheetId: CONFIG.GOOGLE_SHEET_ID,
                        range: 'Submissions!A:A', // Assumes 'Submissions' tab
                        valueInputOption: 'USER_ENTERED',
                        resource: { values: [submissionRow] }
                    });

                    // 4. Append to 'Extractions' Sheet
                    if (extractionRows.length > 0) {
                         await gapi.client.sheets.spreadsheets.values.append({
                            spreadsheetId: CONFIG.GOOGLE_SHEET_ID,
                            range: 'Extractions!A:A', // Assumes 'Extractions' tab
                            valueInputOption: 'USER_ENTERED',
                            resource: { values: extractionRows }
                        });
                    }

                    StatusManager.showLoading(false);
                    StatusManager.show('‚úì Successfully saved to Google Sheets!', 'success');
                };
                 
                // Check if we already have a token
                if (gapi.client.getToken() === null) {
                    // Prompt the user to select a Google Account and ask for consent
                    gapiTokenClient.requestAccessToken({prompt: 'consent'});
                } else {
                    // We already have a token, just run the callback
                    gapiTokenClient.callback(gapi.client.getToken());
                }

            } catch (error) {
                 console.error("Google Sheets Save Error:", error);
                 StatusManager.show(`Google Sheets save failed: ${error.message}`, 'error');
                 StatusManager.showLoading(false);
            }
        };


         // Initial status message
         StatusManager.show('Preview Ready. Load a PDF to begin.', 'info');

        // ============================================================================
        // AUTO-LOAD SAMPLE PDF FOR TESTING
        // ============================================================================
        (async function() {
            try {
                // Auto-load Kim2016.pdf for testing
                const response = await fetch('/Kim2016.pdf');
                if (response.ok) {
                    const blob = await response.blob();
                    const file = new File([blob], 'Kim2016.pdf', { type: 'application/pdf' });
                    StatusManager.show('Auto-loading Kim2016.pdf for testing...', 'info');
                    await PDFLoader.loadPDF(file);
                } else {
                    console.log('Kim2016.pdf not found - manual upload required');
                }
            } catch (error) {
                console.log('Could not auto-load PDF:', error.message);
                // Silent fail - user can still upload manually
            }
        })();

    </script>
</body>
</html>
